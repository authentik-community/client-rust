/*
 * authentik
 *
 * Making authentication simple.
 *
 * The version of the OpenAPI document: 2024.12.5
 * Contact: hello@goauthentik.io
 * Generated by: https://openapi-generator.tech
 */

use super::{configuration, ContentType, Error};
use crate::{apis::ResponseContent, models};
use reqwest;
use serde::{de::Error as _, Deserialize, Serialize};
use tokio::fs::File as TokioFile;
use tokio_util::codec::{BytesCodec, FramedRead};

/// struct for typed errors of method [`sources_all_destroy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesAllDestroyError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_all_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesAllListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_all_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesAllRetrieveError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_all_set_icon_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesAllSetIconCreateError {
    Status400(),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_all_set_icon_url_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesAllSetIconUrlCreateError {
    Status400(),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_all_types_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesAllTypesListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_all_used_by_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesAllUsedByListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_all_user_settings_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesAllUserSettingsListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_group_connections_kerberos_destroy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesGroupConnectionsKerberosDestroyError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_group_connections_kerberos_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesGroupConnectionsKerberosListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_group_connections_kerberos_partial_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesGroupConnectionsKerberosPartialUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_group_connections_kerberos_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesGroupConnectionsKerberosRetrieveError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_group_connections_kerberos_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesGroupConnectionsKerberosUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_group_connections_kerberos_used_by_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesGroupConnectionsKerberosUsedByListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_group_connections_oauth_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesGroupConnectionsOauthCreateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_group_connections_oauth_destroy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesGroupConnectionsOauthDestroyError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_group_connections_oauth_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesGroupConnectionsOauthListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_group_connections_oauth_partial_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesGroupConnectionsOauthPartialUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_group_connections_oauth_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesGroupConnectionsOauthRetrieveError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_group_connections_oauth_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesGroupConnectionsOauthUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_group_connections_oauth_used_by_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesGroupConnectionsOauthUsedByListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_group_connections_plex_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesGroupConnectionsPlexCreateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_group_connections_plex_destroy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesGroupConnectionsPlexDestroyError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_group_connections_plex_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesGroupConnectionsPlexListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_group_connections_plex_partial_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesGroupConnectionsPlexPartialUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_group_connections_plex_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesGroupConnectionsPlexRetrieveError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_group_connections_plex_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesGroupConnectionsPlexUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_group_connections_plex_used_by_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesGroupConnectionsPlexUsedByListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_group_connections_saml_destroy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesGroupConnectionsSamlDestroyError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_group_connections_saml_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesGroupConnectionsSamlListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_group_connections_saml_partial_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesGroupConnectionsSamlPartialUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_group_connections_saml_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesGroupConnectionsSamlRetrieveError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_group_connections_saml_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesGroupConnectionsSamlUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_group_connections_saml_used_by_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesGroupConnectionsSamlUsedByListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_kerberos_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesKerberosCreateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_kerberos_destroy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesKerberosDestroyError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_kerberos_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesKerberosListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_kerberos_partial_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesKerberosPartialUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_kerberos_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesKerberosRetrieveError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_kerberos_sync_status_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesKerberosSyncStatusRetrieveError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_kerberos_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesKerberosUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_kerberos_used_by_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesKerberosUsedByListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_ldap_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesLdapCreateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_ldap_debug_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesLdapDebugRetrieveError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_ldap_destroy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesLdapDestroyError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_ldap_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesLdapListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_ldap_partial_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesLdapPartialUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_ldap_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesLdapRetrieveError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_ldap_sync_status_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesLdapSyncStatusRetrieveError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_ldap_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesLdapUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_ldap_used_by_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesLdapUsedByListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_oauth_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesOauthCreateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_oauth_destroy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesOauthDestroyError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_oauth_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesOauthListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_oauth_partial_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesOauthPartialUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_oauth_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesOauthRetrieveError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_oauth_source_types_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesOauthSourceTypesListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_oauth_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesOauthUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_oauth_used_by_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesOauthUsedByListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_plex_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesPlexCreateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_plex_destroy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesPlexDestroyError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_plex_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesPlexListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_plex_partial_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesPlexPartialUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_plex_redeem_token_authenticated_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesPlexRedeemTokenAuthenticatedCreateError {
    Status400(),
    Status403(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_plex_redeem_token_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesPlexRedeemTokenCreateError {
    Status400(),
    Status403(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_plex_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesPlexRetrieveError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_plex_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesPlexUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_plex_used_by_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesPlexUsedByListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_saml_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesSamlCreateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_saml_destroy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesSamlDestroyError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_saml_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesSamlListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_saml_metadata_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesSamlMetadataRetrieveError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_saml_partial_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesSamlPartialUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_saml_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesSamlRetrieveError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_saml_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesSamlUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_saml_used_by_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesSamlUsedByListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_scim_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesScimCreateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_scim_destroy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesScimDestroyError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_scim_groups_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesScimGroupsCreateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_scim_groups_destroy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesScimGroupsDestroyError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_scim_groups_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesScimGroupsListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_scim_groups_partial_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesScimGroupsPartialUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_scim_groups_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesScimGroupsRetrieveError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_scim_groups_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesScimGroupsUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_scim_groups_used_by_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesScimGroupsUsedByListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_scim_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesScimListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_scim_partial_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesScimPartialUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_scim_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesScimRetrieveError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_scim_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesScimUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_scim_used_by_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesScimUsedByListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_scim_users_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesScimUsersCreateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_scim_users_destroy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesScimUsersDestroyError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_scim_users_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesScimUsersListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_scim_users_partial_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesScimUsersPartialUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_scim_users_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesScimUsersRetrieveError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_scim_users_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesScimUsersUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_scim_users_used_by_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesScimUsersUsedByListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_user_connections_all_destroy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesUserConnectionsAllDestroyError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_user_connections_all_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesUserConnectionsAllListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_user_connections_all_partial_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesUserConnectionsAllPartialUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_user_connections_all_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesUserConnectionsAllRetrieveError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_user_connections_all_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesUserConnectionsAllUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_user_connections_all_used_by_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesUserConnectionsAllUsedByListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_user_connections_kerberos_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesUserConnectionsKerberosCreateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_user_connections_kerberos_destroy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesUserConnectionsKerberosDestroyError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_user_connections_kerberos_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesUserConnectionsKerberosListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_user_connections_kerberos_partial_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesUserConnectionsKerberosPartialUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_user_connections_kerberos_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesUserConnectionsKerberosRetrieveError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_user_connections_kerberos_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesUserConnectionsKerberosUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_user_connections_kerberos_used_by_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesUserConnectionsKerberosUsedByListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_user_connections_oauth_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesUserConnectionsOauthCreateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_user_connections_oauth_destroy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesUserConnectionsOauthDestroyError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_user_connections_oauth_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesUserConnectionsOauthListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_user_connections_oauth_partial_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesUserConnectionsOauthPartialUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_user_connections_oauth_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesUserConnectionsOauthRetrieveError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_user_connections_oauth_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesUserConnectionsOauthUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_user_connections_oauth_used_by_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesUserConnectionsOauthUsedByListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_user_connections_plex_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesUserConnectionsPlexCreateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_user_connections_plex_destroy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesUserConnectionsPlexDestroyError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_user_connections_plex_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesUserConnectionsPlexListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_user_connections_plex_partial_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesUserConnectionsPlexPartialUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_user_connections_plex_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesUserConnectionsPlexRetrieveError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_user_connections_plex_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesUserConnectionsPlexUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_user_connections_plex_used_by_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesUserConnectionsPlexUsedByListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_user_connections_saml_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesUserConnectionsSamlCreateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_user_connections_saml_destroy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesUserConnectionsSamlDestroyError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_user_connections_saml_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesUserConnectionsSamlListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_user_connections_saml_partial_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesUserConnectionsSamlPartialUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_user_connections_saml_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesUserConnectionsSamlRetrieveError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_user_connections_saml_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesUserConnectionsSamlUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`sources_user_connections_saml_used_by_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SourcesUserConnectionsSamlUsedByListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// Source Viewset
pub async fn sources_all_destroy(
    configuration: &configuration::Configuration,
    slug: &str,
) -> Result<(), Error<SourcesAllDestroyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_slug = slug;

    let uri_str = format!(
        "{}/sources/all/{slug}/",
        configuration.base_path,
        slug = crate::apis::urlencode(p_path_slug)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesAllDestroyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Source Viewset
pub async fn sources_all_list(
    configuration: &configuration::Configuration,
    managed: Option<&str>,
    name: Option<&str>,
    ordering: Option<&str>,
    page: Option<i32>,
    page_size: Option<i32>,
    search: Option<&str>,
    slug: Option<&str>,
) -> Result<models::PaginatedSourceList, Error<SourcesAllListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_managed = managed;
    let p_query_name = name;
    let p_query_ordering = ordering;
    let p_query_page = page;
    let p_query_page_size = page_size;
    let p_query_search = search;
    let p_query_slug = slug;

    let uri_str = format!("{}/sources/all/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_managed {
        req_builder = req_builder.query(&[("managed", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ordering {
        req_builder = req_builder.query(&[("ordering", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page_size {
        req_builder = req_builder.query(&[("page_size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_search {
        req_builder = req_builder.query(&[("search", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_slug {
        req_builder = req_builder.query(&[("slug", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginatedSourceList`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginatedSourceList`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesAllListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Source Viewset
pub async fn sources_all_retrieve(
    configuration: &configuration::Configuration,
    slug: &str,
) -> Result<models::Source, Error<SourcesAllRetrieveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_slug = slug;

    let uri_str = format!(
        "{}/sources/all/{slug}/",
        configuration.base_path,
        slug = crate::apis::urlencode(p_path_slug)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::Source`",
                )))
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::Source`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesAllRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Set source icon
pub async fn sources_all_set_icon_create(
    configuration: &configuration::Configuration,
    slug: &str,
    file: Option<std::path::PathBuf>,
    clear: Option<bool>,
) -> Result<(), Error<SourcesAllSetIconCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_slug = slug;
    let p_form_file = file;
    let p_form_clear = clear;

    let uri_str = format!(
        "{}/sources/all/{slug}/set_icon/",
        configuration.base_path,
        slug = crate::apis::urlencode(p_path_slug)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    let mut multipart_form = reqwest::multipart::Form::new();
    // TODO: support file upload for 'file' parameter
    if let Some(param_value) = p_form_clear {
        multipart_form = multipart_form.text("clear", param_value.to_string());
    }
    req_builder = req_builder.multipart(multipart_form);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesAllSetIconCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Set source icon (as URL)
pub async fn sources_all_set_icon_url_create(
    configuration: &configuration::Configuration,
    slug: &str,
    file_path_request: models::FilePathRequest,
) -> Result<(), Error<SourcesAllSetIconUrlCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_slug = slug;
    let p_body_file_path_request = file_path_request;

    let uri_str = format!(
        "{}/sources/all/{slug}/set_icon_url/",
        configuration.base_path,
        slug = crate::apis::urlencode(p_path_slug)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_file_path_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesAllSetIconUrlCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get all creatable types
pub async fn sources_all_types_list(
    configuration: &configuration::Configuration,
) -> Result<Vec<models::TypeCreate>, Error<SourcesAllTypesListError>> {
    let uri_str = format!("{}/sources/all/types/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::TypeCreate&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::TypeCreate&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesAllTypesListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get a list of all objects that use this object
pub async fn sources_all_used_by_list(
    configuration: &configuration::Configuration,
    slug: &str,
) -> Result<Vec<models::UsedBy>, Error<SourcesAllUsedByListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_slug = slug;

    let uri_str = format!(
        "{}/sources/all/{slug}/used_by/",
        configuration.base_path,
        slug = crate::apis::urlencode(p_path_slug)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesAllUsedByListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get all sources the user can configure
pub async fn sources_all_user_settings_list(
    configuration: &configuration::Configuration,
) -> Result<Vec<models::UserSetting>, Error<SourcesAllUserSettingsListError>> {
    let uri_str = format!("{}/sources/all/user_settings/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::UserSetting&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::UserSetting&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesAllUserSettingsListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Group-source connection Viewset
pub async fn sources_group_connections_kerberos_destroy(
    configuration: &configuration::Configuration,
    id: i32,
) -> Result<(), Error<SourcesGroupConnectionsKerberosDestroyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;

    let uri_str = format!(
        "{}/sources/group_connections/kerberos/{id}/",
        configuration.base_path,
        id = p_path_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesGroupConnectionsKerberosDestroyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Group-source connection Viewset
pub async fn sources_group_connections_kerberos_list(
    configuration: &configuration::Configuration,
    group: Option<&str>,
    ordering: Option<&str>,
    page: Option<i32>,
    page_size: Option<i32>,
    search: Option<&str>,
    source__slug: Option<&str>,
) -> Result<models::PaginatedGroupKerberosSourceConnectionList, Error<SourcesGroupConnectionsKerberosListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_group = group;
    let p_query_ordering = ordering;
    let p_query_page = page;
    let p_query_page_size = page_size;
    let p_query_search = search;
    let p_query_source__slug = source__slug;

    let uri_str = format!("{}/sources/group_connections/kerberos/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_group {
        req_builder = req_builder.query(&[("group", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ordering {
        req_builder = req_builder.query(&[("ordering", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page_size {
        req_builder = req_builder.query(&[("page_size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_search {
        req_builder = req_builder.query(&[("search", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_source__slug {
        req_builder = req_builder.query(&[("source__slug", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginatedGroupKerberosSourceConnectionList`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginatedGroupKerberosSourceConnectionList`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesGroupConnectionsKerberosListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Group-source connection Viewset
pub async fn sources_group_connections_kerberos_partial_update(
    configuration: &configuration::Configuration,
    id: i32,
    patched_group_kerberos_source_connection_request: Option<models::PatchedGroupKerberosSourceConnectionRequest>,
) -> Result<models::GroupKerberosSourceConnection, Error<SourcesGroupConnectionsKerberosPartialUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;
    let p_body_patched_group_kerberos_source_connection_request = patched_group_kerberos_source_connection_request;

    let uri_str = format!(
        "{}/sources/group_connections/kerberos/{id}/",
        configuration.base_path,
        id = p_path_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_patched_group_kerberos_source_connection_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GroupKerberosSourceConnection`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GroupKerberosSourceConnection`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesGroupConnectionsKerberosPartialUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Group-source connection Viewset
pub async fn sources_group_connections_kerberos_retrieve(
    configuration: &configuration::Configuration,
    id: i32,
) -> Result<models::GroupKerberosSourceConnection, Error<SourcesGroupConnectionsKerberosRetrieveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;

    let uri_str = format!(
        "{}/sources/group_connections/kerberos/{id}/",
        configuration.base_path,
        id = p_path_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GroupKerberosSourceConnection`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GroupKerberosSourceConnection`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesGroupConnectionsKerberosRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Group-source connection Viewset
pub async fn sources_group_connections_kerberos_update(
    configuration: &configuration::Configuration,
    id: i32,
    group_kerberos_source_connection_request: models::GroupKerberosSourceConnectionRequest,
) -> Result<models::GroupKerberosSourceConnection, Error<SourcesGroupConnectionsKerberosUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;
    let p_body_group_kerberos_source_connection_request = group_kerberos_source_connection_request;

    let uri_str = format!(
        "{}/sources/group_connections/kerberos/{id}/",
        configuration.base_path,
        id = p_path_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_group_kerberos_source_connection_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GroupKerberosSourceConnection`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GroupKerberosSourceConnection`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesGroupConnectionsKerberosUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get a list of all objects that use this object
pub async fn sources_group_connections_kerberos_used_by_list(
    configuration: &configuration::Configuration,
    id: i32,
) -> Result<Vec<models::UsedBy>, Error<SourcesGroupConnectionsKerberosUsedByListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;

    let uri_str = format!(
        "{}/sources/group_connections/kerberos/{id}/used_by/",
        configuration.base_path,
        id = p_path_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesGroupConnectionsKerberosUsedByListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Group-source connection Viewset
pub async fn sources_group_connections_oauth_create(
    configuration: &configuration::Configuration,
    group_o_auth_source_connection_request: models::GroupOAuthSourceConnectionRequest,
) -> Result<models::GroupOAuthSourceConnection, Error<SourcesGroupConnectionsOauthCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_group_o_auth_source_connection_request = group_o_auth_source_connection_request;

    let uri_str = format!("{}/sources/group_connections/oauth/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_group_o_auth_source_connection_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GroupOAuthSourceConnection`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GroupOAuthSourceConnection`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesGroupConnectionsOauthCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Group-source connection Viewset
pub async fn sources_group_connections_oauth_destroy(
    configuration: &configuration::Configuration,
    id: i32,
) -> Result<(), Error<SourcesGroupConnectionsOauthDestroyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;

    let uri_str = format!(
        "{}/sources/group_connections/oauth/{id}/",
        configuration.base_path,
        id = p_path_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesGroupConnectionsOauthDestroyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Group-source connection Viewset
pub async fn sources_group_connections_oauth_list(
    configuration: &configuration::Configuration,
    group: Option<&str>,
    ordering: Option<&str>,
    page: Option<i32>,
    page_size: Option<i32>,
    search: Option<&str>,
    source__slug: Option<&str>,
) -> Result<models::PaginatedGroupOAuthSourceConnectionList, Error<SourcesGroupConnectionsOauthListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_group = group;
    let p_query_ordering = ordering;
    let p_query_page = page;
    let p_query_page_size = page_size;
    let p_query_search = search;
    let p_query_source__slug = source__slug;

    let uri_str = format!("{}/sources/group_connections/oauth/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_group {
        req_builder = req_builder.query(&[("group", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ordering {
        req_builder = req_builder.query(&[("ordering", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page_size {
        req_builder = req_builder.query(&[("page_size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_search {
        req_builder = req_builder.query(&[("search", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_source__slug {
        req_builder = req_builder.query(&[("source__slug", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginatedGroupOAuthSourceConnectionList`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginatedGroupOAuthSourceConnectionList`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesGroupConnectionsOauthListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Group-source connection Viewset
pub async fn sources_group_connections_oauth_partial_update(
    configuration: &configuration::Configuration,
    id: i32,
    patched_group_o_auth_source_connection_request: Option<models::PatchedGroupOAuthSourceConnectionRequest>,
) -> Result<models::GroupOAuthSourceConnection, Error<SourcesGroupConnectionsOauthPartialUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;
    let p_body_patched_group_o_auth_source_connection_request = patched_group_o_auth_source_connection_request;

    let uri_str = format!(
        "{}/sources/group_connections/oauth/{id}/",
        configuration.base_path,
        id = p_path_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_patched_group_o_auth_source_connection_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GroupOAuthSourceConnection`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GroupOAuthSourceConnection`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesGroupConnectionsOauthPartialUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Group-source connection Viewset
pub async fn sources_group_connections_oauth_retrieve(
    configuration: &configuration::Configuration,
    id: i32,
) -> Result<models::GroupOAuthSourceConnection, Error<SourcesGroupConnectionsOauthRetrieveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;

    let uri_str = format!(
        "{}/sources/group_connections/oauth/{id}/",
        configuration.base_path,
        id = p_path_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GroupOAuthSourceConnection`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GroupOAuthSourceConnection`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesGroupConnectionsOauthRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Group-source connection Viewset
pub async fn sources_group_connections_oauth_update(
    configuration: &configuration::Configuration,
    id: i32,
    group_o_auth_source_connection_request: models::GroupOAuthSourceConnectionRequest,
) -> Result<models::GroupOAuthSourceConnection, Error<SourcesGroupConnectionsOauthUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;
    let p_body_group_o_auth_source_connection_request = group_o_auth_source_connection_request;

    let uri_str = format!(
        "{}/sources/group_connections/oauth/{id}/",
        configuration.base_path,
        id = p_path_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_group_o_auth_source_connection_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GroupOAuthSourceConnection`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GroupOAuthSourceConnection`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesGroupConnectionsOauthUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get a list of all objects that use this object
pub async fn sources_group_connections_oauth_used_by_list(
    configuration: &configuration::Configuration,
    id: i32,
) -> Result<Vec<models::UsedBy>, Error<SourcesGroupConnectionsOauthUsedByListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;

    let uri_str = format!(
        "{}/sources/group_connections/oauth/{id}/used_by/",
        configuration.base_path,
        id = p_path_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesGroupConnectionsOauthUsedByListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Group-source connection Viewset
pub async fn sources_group_connections_plex_create(
    configuration: &configuration::Configuration,
    group_plex_source_connection_request: models::GroupPlexSourceConnectionRequest,
) -> Result<models::GroupPlexSourceConnection, Error<SourcesGroupConnectionsPlexCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_group_plex_source_connection_request = group_plex_source_connection_request;

    let uri_str = format!("{}/sources/group_connections/plex/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_group_plex_source_connection_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GroupPlexSourceConnection`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GroupPlexSourceConnection`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesGroupConnectionsPlexCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Group-source connection Viewset
pub async fn sources_group_connections_plex_destroy(
    configuration: &configuration::Configuration,
    id: i32,
) -> Result<(), Error<SourcesGroupConnectionsPlexDestroyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;

    let uri_str = format!(
        "{}/sources/group_connections/plex/{id}/",
        configuration.base_path,
        id = p_path_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesGroupConnectionsPlexDestroyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Group-source connection Viewset
pub async fn sources_group_connections_plex_list(
    configuration: &configuration::Configuration,
    group: Option<&str>,
    ordering: Option<&str>,
    page: Option<i32>,
    page_size: Option<i32>,
    search: Option<&str>,
    source__slug: Option<&str>,
) -> Result<models::PaginatedGroupPlexSourceConnectionList, Error<SourcesGroupConnectionsPlexListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_group = group;
    let p_query_ordering = ordering;
    let p_query_page = page;
    let p_query_page_size = page_size;
    let p_query_search = search;
    let p_query_source__slug = source__slug;

    let uri_str = format!("{}/sources/group_connections/plex/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_group {
        req_builder = req_builder.query(&[("group", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ordering {
        req_builder = req_builder.query(&[("ordering", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page_size {
        req_builder = req_builder.query(&[("page_size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_search {
        req_builder = req_builder.query(&[("search", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_source__slug {
        req_builder = req_builder.query(&[("source__slug", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginatedGroupPlexSourceConnectionList`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginatedGroupPlexSourceConnectionList`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesGroupConnectionsPlexListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Group-source connection Viewset
pub async fn sources_group_connections_plex_partial_update(
    configuration: &configuration::Configuration,
    id: i32,
    patched_group_plex_source_connection_request: Option<models::PatchedGroupPlexSourceConnectionRequest>,
) -> Result<models::GroupPlexSourceConnection, Error<SourcesGroupConnectionsPlexPartialUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;
    let p_body_patched_group_plex_source_connection_request = patched_group_plex_source_connection_request;

    let uri_str = format!(
        "{}/sources/group_connections/plex/{id}/",
        configuration.base_path,
        id = p_path_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_patched_group_plex_source_connection_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GroupPlexSourceConnection`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GroupPlexSourceConnection`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesGroupConnectionsPlexPartialUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Group-source connection Viewset
pub async fn sources_group_connections_plex_retrieve(
    configuration: &configuration::Configuration,
    id: i32,
) -> Result<models::GroupPlexSourceConnection, Error<SourcesGroupConnectionsPlexRetrieveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;

    let uri_str = format!(
        "{}/sources/group_connections/plex/{id}/",
        configuration.base_path,
        id = p_path_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GroupPlexSourceConnection`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GroupPlexSourceConnection`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesGroupConnectionsPlexRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Group-source connection Viewset
pub async fn sources_group_connections_plex_update(
    configuration: &configuration::Configuration,
    id: i32,
    group_plex_source_connection_request: models::GroupPlexSourceConnectionRequest,
) -> Result<models::GroupPlexSourceConnection, Error<SourcesGroupConnectionsPlexUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;
    let p_body_group_plex_source_connection_request = group_plex_source_connection_request;

    let uri_str = format!(
        "{}/sources/group_connections/plex/{id}/",
        configuration.base_path,
        id = p_path_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_group_plex_source_connection_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GroupPlexSourceConnection`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GroupPlexSourceConnection`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesGroupConnectionsPlexUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get a list of all objects that use this object
pub async fn sources_group_connections_plex_used_by_list(
    configuration: &configuration::Configuration,
    id: i32,
) -> Result<Vec<models::UsedBy>, Error<SourcesGroupConnectionsPlexUsedByListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;

    let uri_str = format!(
        "{}/sources/group_connections/plex/{id}/used_by/",
        configuration.base_path,
        id = p_path_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesGroupConnectionsPlexUsedByListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Group-source connection Viewset
pub async fn sources_group_connections_saml_destroy(
    configuration: &configuration::Configuration,
    id: i32,
) -> Result<(), Error<SourcesGroupConnectionsSamlDestroyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;

    let uri_str = format!(
        "{}/sources/group_connections/saml/{id}/",
        configuration.base_path,
        id = p_path_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesGroupConnectionsSamlDestroyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Group-source connection Viewset
pub async fn sources_group_connections_saml_list(
    configuration: &configuration::Configuration,
    group: Option<&str>,
    ordering: Option<&str>,
    page: Option<i32>,
    page_size: Option<i32>,
    search: Option<&str>,
    source__slug: Option<&str>,
) -> Result<models::PaginatedGroupSamlSourceConnectionList, Error<SourcesGroupConnectionsSamlListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_group = group;
    let p_query_ordering = ordering;
    let p_query_page = page;
    let p_query_page_size = page_size;
    let p_query_search = search;
    let p_query_source__slug = source__slug;

    let uri_str = format!("{}/sources/group_connections/saml/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_group {
        req_builder = req_builder.query(&[("group", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ordering {
        req_builder = req_builder.query(&[("ordering", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page_size {
        req_builder = req_builder.query(&[("page_size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_search {
        req_builder = req_builder.query(&[("search", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_source__slug {
        req_builder = req_builder.query(&[("source__slug", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginatedGroupSamlSourceConnectionList`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginatedGroupSamlSourceConnectionList`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesGroupConnectionsSamlListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Group-source connection Viewset
pub async fn sources_group_connections_saml_partial_update(
    configuration: &configuration::Configuration,
    id: i32,
    patched_group_saml_source_connection_request: Option<models::PatchedGroupSamlSourceConnectionRequest>,
) -> Result<models::GroupSamlSourceConnection, Error<SourcesGroupConnectionsSamlPartialUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;
    let p_body_patched_group_saml_source_connection_request = patched_group_saml_source_connection_request;

    let uri_str = format!(
        "{}/sources/group_connections/saml/{id}/",
        configuration.base_path,
        id = p_path_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_patched_group_saml_source_connection_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GroupSamlSourceConnection`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GroupSamlSourceConnection`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesGroupConnectionsSamlPartialUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Group-source connection Viewset
pub async fn sources_group_connections_saml_retrieve(
    configuration: &configuration::Configuration,
    id: i32,
) -> Result<models::GroupSamlSourceConnection, Error<SourcesGroupConnectionsSamlRetrieveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;

    let uri_str = format!(
        "{}/sources/group_connections/saml/{id}/",
        configuration.base_path,
        id = p_path_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GroupSamlSourceConnection`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GroupSamlSourceConnection`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesGroupConnectionsSamlRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Group-source connection Viewset
pub async fn sources_group_connections_saml_update(
    configuration: &configuration::Configuration,
    id: i32,
    group_saml_source_connection_request: models::GroupSamlSourceConnectionRequest,
) -> Result<models::GroupSamlSourceConnection, Error<SourcesGroupConnectionsSamlUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;
    let p_body_group_saml_source_connection_request = group_saml_source_connection_request;

    let uri_str = format!(
        "{}/sources/group_connections/saml/{id}/",
        configuration.base_path,
        id = p_path_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_group_saml_source_connection_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GroupSamlSourceConnection`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GroupSamlSourceConnection`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesGroupConnectionsSamlUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get a list of all objects that use this object
pub async fn sources_group_connections_saml_used_by_list(
    configuration: &configuration::Configuration,
    id: i32,
) -> Result<Vec<models::UsedBy>, Error<SourcesGroupConnectionsSamlUsedByListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;

    let uri_str = format!(
        "{}/sources/group_connections/saml/{id}/used_by/",
        configuration.base_path,
        id = p_path_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesGroupConnectionsSamlUsedByListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Kerberos Source Viewset
pub async fn sources_kerberos_create(
    configuration: &configuration::Configuration,
    kerberos_source_request: models::KerberosSourceRequest,
) -> Result<models::KerberosSource, Error<SourcesKerberosCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_kerberos_source_request = kerberos_source_request;

    let uri_str = format!("{}/sources/kerberos/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_kerberos_source_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::KerberosSource`",
                )))
            }
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!(
                "Received `{unknown_type}` content type response that cannot be converted to `models::KerberosSource`"
            )))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesKerberosCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Kerberos Source Viewset
pub async fn sources_kerberos_destroy(
    configuration: &configuration::Configuration,
    slug: &str,
) -> Result<(), Error<SourcesKerberosDestroyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_slug = slug;

    let uri_str = format!(
        "{}/sources/kerberos/{slug}/",
        configuration.base_path,
        slug = crate::apis::urlencode(p_path_slug)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesKerberosDestroyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Kerberos Source Viewset
pub async fn sources_kerberos_list(
    configuration: &configuration::Configuration,
    enabled: Option<bool>,
    kadmin_type: Option<&str>,
    name: Option<&str>,
    ordering: Option<&str>,
    page: Option<i32>,
    page_size: Option<i32>,
    password_login_update_internal_password: Option<bool>,
    realm: Option<&str>,
    search: Option<&str>,
    slug: Option<&str>,
    spnego_server_name: Option<&str>,
    sync_principal: Option<&str>,
    sync_users: Option<bool>,
    sync_users_password: Option<bool>,
) -> Result<models::PaginatedKerberosSourceList, Error<SourcesKerberosListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_enabled = enabled;
    let p_query_kadmin_type = kadmin_type;
    let p_query_name = name;
    let p_query_ordering = ordering;
    let p_query_page = page;
    let p_query_page_size = page_size;
    let p_query_password_login_update_internal_password = password_login_update_internal_password;
    let p_query_realm = realm;
    let p_query_search = search;
    let p_query_slug = slug;
    let p_query_spnego_server_name = spnego_server_name;
    let p_query_sync_principal = sync_principal;
    let p_query_sync_users = sync_users;
    let p_query_sync_users_password = sync_users_password;

    let uri_str = format!("{}/sources/kerberos/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_enabled {
        req_builder = req_builder.query(&[("enabled", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_kadmin_type {
        req_builder = req_builder.query(&[("kadmin_type", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ordering {
        req_builder = req_builder.query(&[("ordering", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page_size {
        req_builder = req_builder.query(&[("page_size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_password_login_update_internal_password {
        req_builder = req_builder.query(&[("password_login_update_internal_password", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_realm {
        req_builder = req_builder.query(&[("realm", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_search {
        req_builder = req_builder.query(&[("search", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_slug {
        req_builder = req_builder.query(&[("slug", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_spnego_server_name {
        req_builder = req_builder.query(&[("spnego_server_name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sync_principal {
        req_builder = req_builder.query(&[("sync_principal", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sync_users {
        req_builder = req_builder.query(&[("sync_users", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sync_users_password {
        req_builder = req_builder.query(&[("sync_users_password", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginatedKerberosSourceList`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginatedKerberosSourceList`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesKerberosListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Kerberos Source Viewset
pub async fn sources_kerberos_partial_update(
    configuration: &configuration::Configuration,
    slug: &str,
    patched_kerberos_source_request: Option<models::PatchedKerberosSourceRequest>,
) -> Result<models::KerberosSource, Error<SourcesKerberosPartialUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_slug = slug;
    let p_body_patched_kerberos_source_request = patched_kerberos_source_request;

    let uri_str = format!(
        "{}/sources/kerberos/{slug}/",
        configuration.base_path,
        slug = crate::apis::urlencode(p_path_slug)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_patched_kerberos_source_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::KerberosSource`",
                )))
            }
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!(
                "Received `{unknown_type}` content type response that cannot be converted to `models::KerberosSource`"
            )))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesKerberosPartialUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Kerberos Source Viewset
pub async fn sources_kerberos_retrieve(
    configuration: &configuration::Configuration,
    slug: &str,
) -> Result<models::KerberosSource, Error<SourcesKerberosRetrieveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_slug = slug;

    let uri_str = format!(
        "{}/sources/kerberos/{slug}/",
        configuration.base_path,
        slug = crate::apis::urlencode(p_path_slug)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::KerberosSource`",
                )))
            }
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!(
                "Received `{unknown_type}` content type response that cannot be converted to `models::KerberosSource`"
            )))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesKerberosRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get source's sync status
pub async fn sources_kerberos_sync_status_retrieve(
    configuration: &configuration::Configuration,
    slug: &str,
) -> Result<models::KerberosSyncStatus, Error<SourcesKerberosSyncStatusRetrieveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_slug = slug;

    let uri_str = format!(
        "{}/sources/kerberos/{slug}/sync/status/",
        configuration.base_path,
        slug = crate::apis::urlencode(p_path_slug)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::KerberosSyncStatus`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::KerberosSyncStatus`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesKerberosSyncStatusRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Kerberos Source Viewset
pub async fn sources_kerberos_update(
    configuration: &configuration::Configuration,
    slug: &str,
    kerberos_source_request: models::KerberosSourceRequest,
) -> Result<models::KerberosSource, Error<SourcesKerberosUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_slug = slug;
    let p_body_kerberos_source_request = kerberos_source_request;

    let uri_str = format!(
        "{}/sources/kerberos/{slug}/",
        configuration.base_path,
        slug = crate::apis::urlencode(p_path_slug)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_kerberos_source_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::KerberosSource`",
                )))
            }
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!(
                "Received `{unknown_type}` content type response that cannot be converted to `models::KerberosSource`"
            )))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesKerberosUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get a list of all objects that use this object
pub async fn sources_kerberos_used_by_list(
    configuration: &configuration::Configuration,
    slug: &str,
) -> Result<Vec<models::UsedBy>, Error<SourcesKerberosUsedByListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_slug = slug;

    let uri_str = format!(
        "{}/sources/kerberos/{slug}/used_by/",
        configuration.base_path,
        slug = crate::apis::urlencode(p_path_slug)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesKerberosUsedByListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// LDAP Source Viewset
pub async fn sources_ldap_create(
    configuration: &configuration::Configuration,
    ldap_source_request: models::LdapSourceRequest,
) -> Result<models::LdapSource, Error<SourcesLdapCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_ldap_source_request = ldap_source_request;

    let uri_str = format!("{}/sources/ldap/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_ldap_source_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::LdapSource`",
                )))
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::LdapSource`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesLdapCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get raw LDAP data to debug
pub async fn sources_ldap_debug_retrieve(
    configuration: &configuration::Configuration,
    slug: &str,
) -> Result<models::LdapDebug, Error<SourcesLdapDebugRetrieveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_slug = slug;

    let uri_str = format!(
        "{}/sources/ldap/{slug}/debug/",
        configuration.base_path,
        slug = crate::apis::urlencode(p_path_slug)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::LdapDebug`",
                )))
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::LdapDebug`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesLdapDebugRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// LDAP Source Viewset
pub async fn sources_ldap_destroy(
    configuration: &configuration::Configuration,
    slug: &str,
) -> Result<(), Error<SourcesLdapDestroyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_slug = slug;

    let uri_str = format!(
        "{}/sources/ldap/{slug}/",
        configuration.base_path,
        slug = crate::apis::urlencode(p_path_slug)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesLdapDestroyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// LDAP Source Viewset
pub async fn sources_ldap_list(
    configuration: &configuration::Configuration,
    additional_group_dn: Option<&str>,
    additional_user_dn: Option<&str>,
    base_dn: Option<&str>,
    bind_cn: Option<&str>,
    client_certificate: Option<&str>,
    enabled: Option<bool>,
    group_membership_field: Option<&str>,
    group_object_filter: Option<&str>,
    group_property_mappings: Option<Vec<uuid::Uuid>>,
    name: Option<&str>,
    object_uniqueness_field: Option<&str>,
    ordering: Option<&str>,
    page: Option<i32>,
    page_size: Option<i32>,
    password_login_update_internal_password: Option<bool>,
    peer_certificate: Option<&str>,
    search: Option<&str>,
    server_uri: Option<&str>,
    slug: Option<&str>,
    sni: Option<bool>,
    start_tls: Option<bool>,
    sync_groups: Option<bool>,
    sync_parent_group: Option<&str>,
    sync_users: Option<bool>,
    sync_users_password: Option<bool>,
    user_object_filter: Option<&str>,
    user_property_mappings: Option<Vec<uuid::Uuid>>,
) -> Result<models::PaginatedLdapSourceList, Error<SourcesLdapListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_additional_group_dn = additional_group_dn;
    let p_query_additional_user_dn = additional_user_dn;
    let p_query_base_dn = base_dn;
    let p_query_bind_cn = bind_cn;
    let p_query_client_certificate = client_certificate;
    let p_query_enabled = enabled;
    let p_query_group_membership_field = group_membership_field;
    let p_query_group_object_filter = group_object_filter;
    let p_query_group_property_mappings = group_property_mappings;
    let p_query_name = name;
    let p_query_object_uniqueness_field = object_uniqueness_field;
    let p_query_ordering = ordering;
    let p_query_page = page;
    let p_query_page_size = page_size;
    let p_query_password_login_update_internal_password = password_login_update_internal_password;
    let p_query_peer_certificate = peer_certificate;
    let p_query_search = search;
    let p_query_server_uri = server_uri;
    let p_query_slug = slug;
    let p_query_sni = sni;
    let p_query_start_tls = start_tls;
    let p_query_sync_groups = sync_groups;
    let p_query_sync_parent_group = sync_parent_group;
    let p_query_sync_users = sync_users;
    let p_query_sync_users_password = sync_users_password;
    let p_query_user_object_filter = user_object_filter;
    let p_query_user_property_mappings = user_property_mappings;

    let uri_str = format!("{}/sources/ldap/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_additional_group_dn {
        req_builder = req_builder.query(&[("additional_group_dn", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_additional_user_dn {
        req_builder = req_builder.query(&[("additional_user_dn", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_base_dn {
        req_builder = req_builder.query(&[("base_dn", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_bind_cn {
        req_builder = req_builder.query(&[("bind_cn", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_client_certificate {
        req_builder = req_builder.query(&[("client_certificate", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_enabled {
        req_builder = req_builder.query(&[("enabled", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_group_membership_field {
        req_builder = req_builder.query(&[("group_membership_field", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_group_object_filter {
        req_builder = req_builder.query(&[("group_object_filter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_group_property_mappings {
        req_builder = match "multi" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("group_property_mappings".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "group_property_mappings",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = p_query_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_object_uniqueness_field {
        req_builder = req_builder.query(&[("object_uniqueness_field", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ordering {
        req_builder = req_builder.query(&[("ordering", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page_size {
        req_builder = req_builder.query(&[("page_size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_password_login_update_internal_password {
        req_builder = req_builder.query(&[("password_login_update_internal_password", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_peer_certificate {
        req_builder = req_builder.query(&[("peer_certificate", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_search {
        req_builder = req_builder.query(&[("search", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_server_uri {
        req_builder = req_builder.query(&[("server_uri", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_slug {
        req_builder = req_builder.query(&[("slug", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sni {
        req_builder = req_builder.query(&[("sni", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_start_tls {
        req_builder = req_builder.query(&[("start_tls", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sync_groups {
        req_builder = req_builder.query(&[("sync_groups", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sync_parent_group {
        req_builder = req_builder.query(&[("sync_parent_group", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sync_users {
        req_builder = req_builder.query(&[("sync_users", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sync_users_password {
        req_builder = req_builder.query(&[("sync_users_password", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_user_object_filter {
        req_builder = req_builder.query(&[("user_object_filter", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_user_property_mappings {
        req_builder = match "multi" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("user_property_mappings".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "user_property_mappings",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginatedLdapSourceList`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginatedLdapSourceList`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesLdapListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// LDAP Source Viewset
pub async fn sources_ldap_partial_update(
    configuration: &configuration::Configuration,
    slug: &str,
    patched_ldap_source_request: Option<models::PatchedLdapSourceRequest>,
) -> Result<models::LdapSource, Error<SourcesLdapPartialUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_slug = slug;
    let p_body_patched_ldap_source_request = patched_ldap_source_request;

    let uri_str = format!(
        "{}/sources/ldap/{slug}/",
        configuration.base_path,
        slug = crate::apis::urlencode(p_path_slug)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_patched_ldap_source_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::LdapSource`",
                )))
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::LdapSource`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesLdapPartialUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// LDAP Source Viewset
pub async fn sources_ldap_retrieve(
    configuration: &configuration::Configuration,
    slug: &str,
) -> Result<models::LdapSource, Error<SourcesLdapRetrieveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_slug = slug;

    let uri_str = format!(
        "{}/sources/ldap/{slug}/",
        configuration.base_path,
        slug = crate::apis::urlencode(p_path_slug)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::LdapSource`",
                )))
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::LdapSource`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesLdapRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get source's sync status
pub async fn sources_ldap_sync_status_retrieve(
    configuration: &configuration::Configuration,
    slug: &str,
) -> Result<models::SyncStatus, Error<SourcesLdapSyncStatusRetrieveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_slug = slug;

    let uri_str = format!(
        "{}/sources/ldap/{slug}/sync/status/",
        configuration.base_path,
        slug = crate::apis::urlencode(p_path_slug)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::SyncStatus`",
                )))
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::SyncStatus`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesLdapSyncStatusRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// LDAP Source Viewset
pub async fn sources_ldap_update(
    configuration: &configuration::Configuration,
    slug: &str,
    ldap_source_request: models::LdapSourceRequest,
) -> Result<models::LdapSource, Error<SourcesLdapUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_slug = slug;
    let p_body_ldap_source_request = ldap_source_request;

    let uri_str = format!(
        "{}/sources/ldap/{slug}/",
        configuration.base_path,
        slug = crate::apis::urlencode(p_path_slug)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_ldap_source_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::LdapSource`",
                )))
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::LdapSource`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesLdapUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get a list of all objects that use this object
pub async fn sources_ldap_used_by_list(
    configuration: &configuration::Configuration,
    slug: &str,
) -> Result<Vec<models::UsedBy>, Error<SourcesLdapUsedByListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_slug = slug;

    let uri_str = format!(
        "{}/sources/ldap/{slug}/used_by/",
        configuration.base_path,
        slug = crate::apis::urlencode(p_path_slug)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesLdapUsedByListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Source Viewset
pub async fn sources_oauth_create(
    configuration: &configuration::Configuration,
    o_auth_source_request: models::OAuthSourceRequest,
) -> Result<models::OAuthSource, Error<SourcesOauthCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_o_auth_source_request = o_auth_source_request;

    let uri_str = format!("{}/sources/oauth/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_o_auth_source_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::OAuthSource`",
                )))
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::OAuthSource`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesOauthCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Source Viewset
pub async fn sources_oauth_destroy(
    configuration: &configuration::Configuration,
    slug: &str,
) -> Result<(), Error<SourcesOauthDestroyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_slug = slug;

    let uri_str = format!(
        "{}/sources/oauth/{slug}/",
        configuration.base_path,
        slug = crate::apis::urlencode(p_path_slug)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesOauthDestroyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Source Viewset
pub async fn sources_oauth_list(
    configuration: &configuration::Configuration,
    access_token_url: Option<&str>,
    additional_scopes: Option<&str>,
    authentication_flow: Option<&str>,
    authorization_url: Option<&str>,
    consumer_key: Option<&str>,
    enabled: Option<bool>,
    enrollment_flow: Option<&str>,
    group_matching_mode: Option<&str>,
    has_jwks: Option<bool>,
    name: Option<&str>,
    ordering: Option<&str>,
    page: Option<i32>,
    page_size: Option<i32>,
    policy_engine_mode: Option<&str>,
    profile_url: Option<&str>,
    provider_type: Option<&str>,
    request_token_url: Option<&str>,
    search: Option<&str>,
    slug: Option<&str>,
    user_matching_mode: Option<&str>,
) -> Result<models::PaginatedOAuthSourceList, Error<SourcesOauthListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_access_token_url = access_token_url;
    let p_query_additional_scopes = additional_scopes;
    let p_query_authentication_flow = authentication_flow;
    let p_query_authorization_url = authorization_url;
    let p_query_consumer_key = consumer_key;
    let p_query_enabled = enabled;
    let p_query_enrollment_flow = enrollment_flow;
    let p_query_group_matching_mode = group_matching_mode;
    let p_query_has_jwks = has_jwks;
    let p_query_name = name;
    let p_query_ordering = ordering;
    let p_query_page = page;
    let p_query_page_size = page_size;
    let p_query_policy_engine_mode = policy_engine_mode;
    let p_query_profile_url = profile_url;
    let p_query_provider_type = provider_type;
    let p_query_request_token_url = request_token_url;
    let p_query_search = search;
    let p_query_slug = slug;
    let p_query_user_matching_mode = user_matching_mode;

    let uri_str = format!("{}/sources/oauth/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_access_token_url {
        req_builder = req_builder.query(&[("access_token_url", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_additional_scopes {
        req_builder = req_builder.query(&[("additional_scopes", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_authentication_flow {
        req_builder = req_builder.query(&[("authentication_flow", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_authorization_url {
        req_builder = req_builder.query(&[("authorization_url", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_consumer_key {
        req_builder = req_builder.query(&[("consumer_key", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_enabled {
        req_builder = req_builder.query(&[("enabled", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_enrollment_flow {
        req_builder = req_builder.query(&[("enrollment_flow", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_group_matching_mode {
        req_builder = req_builder.query(&[("group_matching_mode", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_has_jwks {
        req_builder = req_builder.query(&[("has_jwks", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ordering {
        req_builder = req_builder.query(&[("ordering", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page_size {
        req_builder = req_builder.query(&[("page_size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_policy_engine_mode {
        req_builder = req_builder.query(&[("policy_engine_mode", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_profile_url {
        req_builder = req_builder.query(&[("profile_url", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_provider_type {
        req_builder = req_builder.query(&[("provider_type", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_request_token_url {
        req_builder = req_builder.query(&[("request_token_url", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_search {
        req_builder = req_builder.query(&[("search", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_slug {
        req_builder = req_builder.query(&[("slug", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_user_matching_mode {
        req_builder = req_builder.query(&[("user_matching_mode", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginatedOAuthSourceList`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginatedOAuthSourceList`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesOauthListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Source Viewset
pub async fn sources_oauth_partial_update(
    configuration: &configuration::Configuration,
    slug: &str,
    patched_o_auth_source_request: Option<models::PatchedOAuthSourceRequest>,
) -> Result<models::OAuthSource, Error<SourcesOauthPartialUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_slug = slug;
    let p_body_patched_o_auth_source_request = patched_o_auth_source_request;

    let uri_str = format!(
        "{}/sources/oauth/{slug}/",
        configuration.base_path,
        slug = crate::apis::urlencode(p_path_slug)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_patched_o_auth_source_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::OAuthSource`",
                )))
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::OAuthSource`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesOauthPartialUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Source Viewset
pub async fn sources_oauth_retrieve(
    configuration: &configuration::Configuration,
    slug: &str,
) -> Result<models::OAuthSource, Error<SourcesOauthRetrieveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_slug = slug;

    let uri_str = format!(
        "{}/sources/oauth/{slug}/",
        configuration.base_path,
        slug = crate::apis::urlencode(p_path_slug)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::OAuthSource`",
                )))
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::OAuthSource`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesOauthRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get all creatable source types. If ?name is set, only returns the type for <name>. If <name> isn't found, returns the default type.
pub async fn sources_oauth_source_types_list(
    configuration: &configuration::Configuration,
    name: Option<&str>,
) -> Result<Vec<models::SourceType>, Error<SourcesOauthSourceTypesListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_name = name;

    let uri_str = format!("{}/sources/oauth/source_types/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::SourceType&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::SourceType&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesOauthSourceTypesListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Source Viewset
pub async fn sources_oauth_update(
    configuration: &configuration::Configuration,
    slug: &str,
    o_auth_source_request: models::OAuthSourceRequest,
) -> Result<models::OAuthSource, Error<SourcesOauthUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_slug = slug;
    let p_body_o_auth_source_request = o_auth_source_request;

    let uri_str = format!(
        "{}/sources/oauth/{slug}/",
        configuration.base_path,
        slug = crate::apis::urlencode(p_path_slug)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_o_auth_source_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::OAuthSource`",
                )))
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::OAuthSource`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesOauthUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get a list of all objects that use this object
pub async fn sources_oauth_used_by_list(
    configuration: &configuration::Configuration,
    slug: &str,
) -> Result<Vec<models::UsedBy>, Error<SourcesOauthUsedByListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_slug = slug;

    let uri_str = format!(
        "{}/sources/oauth/{slug}/used_by/",
        configuration.base_path,
        slug = crate::apis::urlencode(p_path_slug)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesOauthUsedByListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Plex source Viewset
pub async fn sources_plex_create(
    configuration: &configuration::Configuration,
    plex_source_request: models::PlexSourceRequest,
) -> Result<models::PlexSource, Error<SourcesPlexCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_plex_source_request = plex_source_request;

    let uri_str = format!("{}/sources/plex/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_plex_source_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::PlexSource`",
                )))
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::PlexSource`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesPlexCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Plex source Viewset
pub async fn sources_plex_destroy(
    configuration: &configuration::Configuration,
    slug: &str,
) -> Result<(), Error<SourcesPlexDestroyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_slug = slug;

    let uri_str = format!(
        "{}/sources/plex/{slug}/",
        configuration.base_path,
        slug = crate::apis::urlencode(p_path_slug)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesPlexDestroyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Plex source Viewset
pub async fn sources_plex_list(
    configuration: &configuration::Configuration,
    allow_friends: Option<bool>,
    authentication_flow: Option<&str>,
    client_id: Option<&str>,
    enabled: Option<bool>,
    enrollment_flow: Option<&str>,
    group_matching_mode: Option<&str>,
    name: Option<&str>,
    ordering: Option<&str>,
    page: Option<i32>,
    page_size: Option<i32>,
    policy_engine_mode: Option<&str>,
    search: Option<&str>,
    slug: Option<&str>,
    user_matching_mode: Option<&str>,
) -> Result<models::PaginatedPlexSourceList, Error<SourcesPlexListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_allow_friends = allow_friends;
    let p_query_authentication_flow = authentication_flow;
    let p_query_client_id = client_id;
    let p_query_enabled = enabled;
    let p_query_enrollment_flow = enrollment_flow;
    let p_query_group_matching_mode = group_matching_mode;
    let p_query_name = name;
    let p_query_ordering = ordering;
    let p_query_page = page;
    let p_query_page_size = page_size;
    let p_query_policy_engine_mode = policy_engine_mode;
    let p_query_search = search;
    let p_query_slug = slug;
    let p_query_user_matching_mode = user_matching_mode;

    let uri_str = format!("{}/sources/plex/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_allow_friends {
        req_builder = req_builder.query(&[("allow_friends", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_authentication_flow {
        req_builder = req_builder.query(&[("authentication_flow", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_client_id {
        req_builder = req_builder.query(&[("client_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_enabled {
        req_builder = req_builder.query(&[("enabled", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_enrollment_flow {
        req_builder = req_builder.query(&[("enrollment_flow", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_group_matching_mode {
        req_builder = req_builder.query(&[("group_matching_mode", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ordering {
        req_builder = req_builder.query(&[("ordering", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page_size {
        req_builder = req_builder.query(&[("page_size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_policy_engine_mode {
        req_builder = req_builder.query(&[("policy_engine_mode", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_search {
        req_builder = req_builder.query(&[("search", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_slug {
        req_builder = req_builder.query(&[("slug", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_user_matching_mode {
        req_builder = req_builder.query(&[("user_matching_mode", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginatedPlexSourceList`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginatedPlexSourceList`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesPlexListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Plex source Viewset
pub async fn sources_plex_partial_update(
    configuration: &configuration::Configuration,
    slug: &str,
    patched_plex_source_request: Option<models::PatchedPlexSourceRequest>,
) -> Result<models::PlexSource, Error<SourcesPlexPartialUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_slug = slug;
    let p_body_patched_plex_source_request = patched_plex_source_request;

    let uri_str = format!(
        "{}/sources/plex/{slug}/",
        configuration.base_path,
        slug = crate::apis::urlencode(p_path_slug)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_patched_plex_source_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::PlexSource`",
                )))
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::PlexSource`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesPlexPartialUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Redeem a plex token for an authenticated user, creating a connection
pub async fn sources_plex_redeem_token_authenticated_create(
    configuration: &configuration::Configuration,
    plex_token_redeem_request: models::PlexTokenRedeemRequest,
    slug: Option<&str>,
) -> Result<(), Error<SourcesPlexRedeemTokenAuthenticatedCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_plex_token_redeem_request = plex_token_redeem_request;
    let p_query_slug = slug;

    let uri_str = format!("{}/sources/plex/redeem_token_authenticated/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_slug {
        req_builder = req_builder.query(&[("slug", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_plex_token_redeem_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesPlexRedeemTokenAuthenticatedCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Redeem a plex token, check it's access to resources against what's allowed for the source, and redirect to an authentication/enrollment flow.
pub async fn sources_plex_redeem_token_create(
    configuration: &configuration::Configuration,
    plex_token_redeem_request: models::PlexTokenRedeemRequest,
    slug: Option<&str>,
) -> Result<models::RedirectChallenge, Error<SourcesPlexRedeemTokenCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_plex_token_redeem_request = plex_token_redeem_request;
    let p_query_slug = slug;

    let uri_str = format!("{}/sources/plex/redeem_token/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_slug {
        req_builder = req_builder.query(&[("slug", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_plex_token_redeem_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RedirectChallenge`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RedirectChallenge`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesPlexRedeemTokenCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Plex source Viewset
pub async fn sources_plex_retrieve(
    configuration: &configuration::Configuration,
    slug: &str,
) -> Result<models::PlexSource, Error<SourcesPlexRetrieveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_slug = slug;

    let uri_str = format!(
        "{}/sources/plex/{slug}/",
        configuration.base_path,
        slug = crate::apis::urlencode(p_path_slug)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::PlexSource`",
                )))
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::PlexSource`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesPlexRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Plex source Viewset
pub async fn sources_plex_update(
    configuration: &configuration::Configuration,
    slug: &str,
    plex_source_request: models::PlexSourceRequest,
) -> Result<models::PlexSource, Error<SourcesPlexUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_slug = slug;
    let p_body_plex_source_request = plex_source_request;

    let uri_str = format!(
        "{}/sources/plex/{slug}/",
        configuration.base_path,
        slug = crate::apis::urlencode(p_path_slug)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_plex_source_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::PlexSource`",
                )))
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::PlexSource`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesPlexUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get a list of all objects that use this object
pub async fn sources_plex_used_by_list(
    configuration: &configuration::Configuration,
    slug: &str,
) -> Result<Vec<models::UsedBy>, Error<SourcesPlexUsedByListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_slug = slug;

    let uri_str = format!(
        "{}/sources/plex/{slug}/used_by/",
        configuration.base_path,
        slug = crate::apis::urlencode(p_path_slug)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesPlexUsedByListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// SAMLSource Viewset
pub async fn sources_saml_create(
    configuration: &configuration::Configuration,
    saml_source_request: models::SamlSourceRequest,
) -> Result<models::SamlSource, Error<SourcesSamlCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_saml_source_request = saml_source_request;

    let uri_str = format!("{}/sources/saml/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_saml_source_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::SamlSource`",
                )))
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::SamlSource`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesSamlCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// SAMLSource Viewset
pub async fn sources_saml_destroy(
    configuration: &configuration::Configuration,
    slug: &str,
) -> Result<(), Error<SourcesSamlDestroyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_slug = slug;

    let uri_str = format!(
        "{}/sources/saml/{slug}/",
        configuration.base_path,
        slug = crate::apis::urlencode(p_path_slug)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesSamlDestroyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// SAMLSource Viewset
pub async fn sources_saml_list(
    configuration: &configuration::Configuration,
    allow_idp_initiated: Option<bool>,
    authentication_flow: Option<&str>,
    binding_type: Option<&str>,
    digest_algorithm: Option<&str>,
    enabled: Option<bool>,
    enrollment_flow: Option<&str>,
    issuer: Option<&str>,
    managed: Option<&str>,
    name: Option<&str>,
    name_id_policy: Option<&str>,
    ordering: Option<&str>,
    page: Option<i32>,
    page_size: Option<i32>,
    policy_engine_mode: Option<&str>,
    pre_authentication_flow: Option<&str>,
    search: Option<&str>,
    signature_algorithm: Option<&str>,
    signing_kp: Option<&str>,
    slo_url: Option<&str>,
    slug: Option<&str>,
    sso_url: Option<&str>,
    temporary_user_delete_after: Option<&str>,
    user_matching_mode: Option<&str>,
    verification_kp: Option<&str>,
) -> Result<models::PaginatedSamlSourceList, Error<SourcesSamlListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_allow_idp_initiated = allow_idp_initiated;
    let p_query_authentication_flow = authentication_flow;
    let p_query_binding_type = binding_type;
    let p_query_digest_algorithm = digest_algorithm;
    let p_query_enabled = enabled;
    let p_query_enrollment_flow = enrollment_flow;
    let p_query_issuer = issuer;
    let p_query_managed = managed;
    let p_query_name = name;
    let p_query_name_id_policy = name_id_policy;
    let p_query_ordering = ordering;
    let p_query_page = page;
    let p_query_page_size = page_size;
    let p_query_policy_engine_mode = policy_engine_mode;
    let p_query_pre_authentication_flow = pre_authentication_flow;
    let p_query_search = search;
    let p_query_signature_algorithm = signature_algorithm;
    let p_query_signing_kp = signing_kp;
    let p_query_slo_url = slo_url;
    let p_query_slug = slug;
    let p_query_sso_url = sso_url;
    let p_query_temporary_user_delete_after = temporary_user_delete_after;
    let p_query_user_matching_mode = user_matching_mode;
    let p_query_verification_kp = verification_kp;

    let uri_str = format!("{}/sources/saml/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_allow_idp_initiated {
        req_builder = req_builder.query(&[("allow_idp_initiated", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_authentication_flow {
        req_builder = req_builder.query(&[("authentication_flow", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_binding_type {
        req_builder = req_builder.query(&[("binding_type", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_digest_algorithm {
        req_builder = req_builder.query(&[("digest_algorithm", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_enabled {
        req_builder = req_builder.query(&[("enabled", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_enrollment_flow {
        req_builder = req_builder.query(&[("enrollment_flow", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_issuer {
        req_builder = req_builder.query(&[("issuer", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_managed {
        req_builder = req_builder.query(&[("managed", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_name_id_policy {
        req_builder = req_builder.query(&[("name_id_policy", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ordering {
        req_builder = req_builder.query(&[("ordering", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page_size {
        req_builder = req_builder.query(&[("page_size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_policy_engine_mode {
        req_builder = req_builder.query(&[("policy_engine_mode", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_pre_authentication_flow {
        req_builder = req_builder.query(&[("pre_authentication_flow", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_search {
        req_builder = req_builder.query(&[("search", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_signature_algorithm {
        req_builder = req_builder.query(&[("signature_algorithm", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_signing_kp {
        req_builder = req_builder.query(&[("signing_kp", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_slo_url {
        req_builder = req_builder.query(&[("slo_url", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_slug {
        req_builder = req_builder.query(&[("slug", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_sso_url {
        req_builder = req_builder.query(&[("sso_url", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_temporary_user_delete_after {
        req_builder = req_builder.query(&[("temporary_user_delete_after", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_user_matching_mode {
        req_builder = req_builder.query(&[("user_matching_mode", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_verification_kp {
        req_builder = req_builder.query(&[("verification_kp", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginatedSamlSourceList`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginatedSamlSourceList`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesSamlListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Return metadata as XML string
pub async fn sources_saml_metadata_retrieve(
    configuration: &configuration::Configuration,
    slug: &str,
) -> Result<models::SamlMetadata, Error<SourcesSamlMetadataRetrieveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_slug = slug;

    let uri_str = format!(
        "{}/sources/saml/{slug}/metadata/",
        configuration.base_path,
        slug = crate::apis::urlencode(p_path_slug)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::SamlMetadata`",
                )))
            }
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!(
                "Received `{unknown_type}` content type response that cannot be converted to `models::SamlMetadata`"
            )))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesSamlMetadataRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// SAMLSource Viewset
pub async fn sources_saml_partial_update(
    configuration: &configuration::Configuration,
    slug: &str,
    patched_saml_source_request: Option<models::PatchedSamlSourceRequest>,
) -> Result<models::SamlSource, Error<SourcesSamlPartialUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_slug = slug;
    let p_body_patched_saml_source_request = patched_saml_source_request;

    let uri_str = format!(
        "{}/sources/saml/{slug}/",
        configuration.base_path,
        slug = crate::apis::urlencode(p_path_slug)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_patched_saml_source_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::SamlSource`",
                )))
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::SamlSource`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesSamlPartialUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// SAMLSource Viewset
pub async fn sources_saml_retrieve(
    configuration: &configuration::Configuration,
    slug: &str,
) -> Result<models::SamlSource, Error<SourcesSamlRetrieveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_slug = slug;

    let uri_str = format!(
        "{}/sources/saml/{slug}/",
        configuration.base_path,
        slug = crate::apis::urlencode(p_path_slug)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::SamlSource`",
                )))
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::SamlSource`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesSamlRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// SAMLSource Viewset
pub async fn sources_saml_update(
    configuration: &configuration::Configuration,
    slug: &str,
    saml_source_request: models::SamlSourceRequest,
) -> Result<models::SamlSource, Error<SourcesSamlUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_slug = slug;
    let p_body_saml_source_request = saml_source_request;

    let uri_str = format!(
        "{}/sources/saml/{slug}/",
        configuration.base_path,
        slug = crate::apis::urlencode(p_path_slug)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_saml_source_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::SamlSource`",
                )))
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::SamlSource`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesSamlUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get a list of all objects that use this object
pub async fn sources_saml_used_by_list(
    configuration: &configuration::Configuration,
    slug: &str,
) -> Result<Vec<models::UsedBy>, Error<SourcesSamlUsedByListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_slug = slug;

    let uri_str = format!(
        "{}/sources/saml/{slug}/used_by/",
        configuration.base_path,
        slug = crate::apis::urlencode(p_path_slug)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesSamlUsedByListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// SCIMSource Viewset
pub async fn sources_scim_create(
    configuration: &configuration::Configuration,
    scim_source_request: models::ScimSourceRequest,
) -> Result<models::ScimSource, Error<SourcesScimCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_scim_source_request = scim_source_request;

    let uri_str = format!("{}/sources/scim/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_scim_source_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::ScimSource`",
                )))
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::ScimSource`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesScimCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// SCIMSource Viewset
pub async fn sources_scim_destroy(
    configuration: &configuration::Configuration,
    slug: &str,
) -> Result<(), Error<SourcesScimDestroyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_slug = slug;

    let uri_str = format!(
        "{}/sources/scim/{slug}/",
        configuration.base_path,
        slug = crate::apis::urlencode(p_path_slug)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesScimDestroyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// SCIMSourceGroup Viewset
pub async fn sources_scim_groups_create(
    configuration: &configuration::Configuration,
    scim_source_group_request: models::ScimSourceGroupRequest,
) -> Result<models::ScimSourceGroup, Error<SourcesScimGroupsCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_scim_source_group_request = scim_source_group_request;

    let uri_str = format!("{}/sources/scim_groups/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_scim_source_group_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::ScimSourceGroup`",
                )))
            }
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!(
                "Received `{unknown_type}` content type response that cannot be converted to `models::ScimSourceGroup`"
            )))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesScimGroupsCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// SCIMSourceGroup Viewset
pub async fn sources_scim_groups_destroy(
    configuration: &configuration::Configuration,
    id: &str,
) -> Result<(), Error<SourcesScimGroupsDestroyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;

    let uri_str = format!(
        "{}/sources/scim_groups/{id}/",
        configuration.base_path,
        id = crate::apis::urlencode(p_path_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesScimGroupsDestroyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// SCIMSourceGroup Viewset
pub async fn sources_scim_groups_list(
    configuration: &configuration::Configuration,
    group__group_uuid: Option<&str>,
    group__name: Option<&str>,
    ordering: Option<&str>,
    page: Option<i32>,
    page_size: Option<i32>,
    search: Option<&str>,
    source__slug: Option<&str>,
) -> Result<models::PaginatedScimSourceGroupList, Error<SourcesScimGroupsListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_group__group_uuid = group__group_uuid;
    let p_query_group__name = group__name;
    let p_query_ordering = ordering;
    let p_query_page = page;
    let p_query_page_size = page_size;
    let p_query_search = search;
    let p_query_source__slug = source__slug;

    let uri_str = format!("{}/sources/scim_groups/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_group__group_uuid {
        req_builder = req_builder.query(&[("group__group_uuid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_group__name {
        req_builder = req_builder.query(&[("group__name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ordering {
        req_builder = req_builder.query(&[("ordering", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page_size {
        req_builder = req_builder.query(&[("page_size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_search {
        req_builder = req_builder.query(&[("search", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_source__slug {
        req_builder = req_builder.query(&[("source__slug", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginatedScimSourceGroupList`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginatedScimSourceGroupList`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesScimGroupsListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// SCIMSourceGroup Viewset
pub async fn sources_scim_groups_partial_update(
    configuration: &configuration::Configuration,
    id: &str,
    patched_scim_source_group_request: Option<models::PatchedScimSourceGroupRequest>,
) -> Result<models::ScimSourceGroup, Error<SourcesScimGroupsPartialUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;
    let p_body_patched_scim_source_group_request = patched_scim_source_group_request;

    let uri_str = format!(
        "{}/sources/scim_groups/{id}/",
        configuration.base_path,
        id = crate::apis::urlencode(p_path_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_patched_scim_source_group_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::ScimSourceGroup`",
                )))
            }
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!(
                "Received `{unknown_type}` content type response that cannot be converted to `models::ScimSourceGroup`"
            )))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesScimGroupsPartialUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// SCIMSourceGroup Viewset
pub async fn sources_scim_groups_retrieve(
    configuration: &configuration::Configuration,
    id: &str,
) -> Result<models::ScimSourceGroup, Error<SourcesScimGroupsRetrieveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;

    let uri_str = format!(
        "{}/sources/scim_groups/{id}/",
        configuration.base_path,
        id = crate::apis::urlencode(p_path_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::ScimSourceGroup`",
                )))
            }
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!(
                "Received `{unknown_type}` content type response that cannot be converted to `models::ScimSourceGroup`"
            )))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesScimGroupsRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// SCIMSourceGroup Viewset
pub async fn sources_scim_groups_update(
    configuration: &configuration::Configuration,
    id: &str,
    scim_source_group_request: models::ScimSourceGroupRequest,
) -> Result<models::ScimSourceGroup, Error<SourcesScimGroupsUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;
    let p_body_scim_source_group_request = scim_source_group_request;

    let uri_str = format!(
        "{}/sources/scim_groups/{id}/",
        configuration.base_path,
        id = crate::apis::urlencode(p_path_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_scim_source_group_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::ScimSourceGroup`",
                )))
            }
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!(
                "Received `{unknown_type}` content type response that cannot be converted to `models::ScimSourceGroup`"
            )))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesScimGroupsUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get a list of all objects that use this object
pub async fn sources_scim_groups_used_by_list(
    configuration: &configuration::Configuration,
    id: &str,
) -> Result<Vec<models::UsedBy>, Error<SourcesScimGroupsUsedByListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;

    let uri_str = format!(
        "{}/sources/scim_groups/{id}/used_by/",
        configuration.base_path,
        id = crate::apis::urlencode(p_path_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesScimGroupsUsedByListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// SCIMSource Viewset
pub async fn sources_scim_list(
    configuration: &configuration::Configuration,
    name: Option<&str>,
    ordering: Option<&str>,
    page: Option<i32>,
    page_size: Option<i32>,
    search: Option<&str>,
    slug: Option<&str>,
) -> Result<models::PaginatedScimSourceList, Error<SourcesScimListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_name = name;
    let p_query_ordering = ordering;
    let p_query_page = page;
    let p_query_page_size = page_size;
    let p_query_search = search;
    let p_query_slug = slug;

    let uri_str = format!("{}/sources/scim/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ordering {
        req_builder = req_builder.query(&[("ordering", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page_size {
        req_builder = req_builder.query(&[("page_size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_search {
        req_builder = req_builder.query(&[("search", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_slug {
        req_builder = req_builder.query(&[("slug", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginatedScimSourceList`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginatedScimSourceList`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesScimListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// SCIMSource Viewset
pub async fn sources_scim_partial_update(
    configuration: &configuration::Configuration,
    slug: &str,
    patched_scim_source_request: Option<models::PatchedScimSourceRequest>,
) -> Result<models::ScimSource, Error<SourcesScimPartialUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_slug = slug;
    let p_body_patched_scim_source_request = patched_scim_source_request;

    let uri_str = format!(
        "{}/sources/scim/{slug}/",
        configuration.base_path,
        slug = crate::apis::urlencode(p_path_slug)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_patched_scim_source_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::ScimSource`",
                )))
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::ScimSource`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesScimPartialUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// SCIMSource Viewset
pub async fn sources_scim_retrieve(
    configuration: &configuration::Configuration,
    slug: &str,
) -> Result<models::ScimSource, Error<SourcesScimRetrieveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_slug = slug;

    let uri_str = format!(
        "{}/sources/scim/{slug}/",
        configuration.base_path,
        slug = crate::apis::urlencode(p_path_slug)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::ScimSource`",
                )))
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::ScimSource`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesScimRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// SCIMSource Viewset
pub async fn sources_scim_update(
    configuration: &configuration::Configuration,
    slug: &str,
    scim_source_request: models::ScimSourceRequest,
) -> Result<models::ScimSource, Error<SourcesScimUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_slug = slug;
    let p_body_scim_source_request = scim_source_request;

    let uri_str = format!(
        "{}/sources/scim/{slug}/",
        configuration.base_path,
        slug = crate::apis::urlencode(p_path_slug)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_scim_source_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::ScimSource`",
                )))
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::ScimSource`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesScimUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get a list of all objects that use this object
pub async fn sources_scim_used_by_list(
    configuration: &configuration::Configuration,
    slug: &str,
) -> Result<Vec<models::UsedBy>, Error<SourcesScimUsedByListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_slug = slug;

    let uri_str = format!(
        "{}/sources/scim/{slug}/used_by/",
        configuration.base_path,
        slug = crate::apis::urlencode(p_path_slug)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesScimUsedByListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// SCIMSourceUser Viewset
pub async fn sources_scim_users_create(
    configuration: &configuration::Configuration,
    scim_source_user_request: models::ScimSourceUserRequest,
) -> Result<models::ScimSourceUser, Error<SourcesScimUsersCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_scim_source_user_request = scim_source_user_request;

    let uri_str = format!("{}/sources/scim_users/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_scim_source_user_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::ScimSourceUser`",
                )))
            }
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!(
                "Received `{unknown_type}` content type response that cannot be converted to `models::ScimSourceUser`"
            )))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesScimUsersCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// SCIMSourceUser Viewset
pub async fn sources_scim_users_destroy(
    configuration: &configuration::Configuration,
    id: &str,
) -> Result<(), Error<SourcesScimUsersDestroyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;

    let uri_str = format!(
        "{}/sources/scim_users/{id}/",
        configuration.base_path,
        id = crate::apis::urlencode(p_path_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesScimUsersDestroyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// SCIMSourceUser Viewset
pub async fn sources_scim_users_list(
    configuration: &configuration::Configuration,
    ordering: Option<&str>,
    page: Option<i32>,
    page_size: Option<i32>,
    search: Option<&str>,
    source__slug: Option<&str>,
    user__id: Option<i32>,
    user__username: Option<&str>,
) -> Result<models::PaginatedScimSourceUserList, Error<SourcesScimUsersListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_ordering = ordering;
    let p_query_page = page;
    let p_query_page_size = page_size;
    let p_query_search = search;
    let p_query_source__slug = source__slug;
    let p_query_user__id = user__id;
    let p_query_user__username = user__username;

    let uri_str = format!("{}/sources/scim_users/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_ordering {
        req_builder = req_builder.query(&[("ordering", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page_size {
        req_builder = req_builder.query(&[("page_size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_search {
        req_builder = req_builder.query(&[("search", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_source__slug {
        req_builder = req_builder.query(&[("source__slug", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_user__id {
        req_builder = req_builder.query(&[("user__id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_user__username {
        req_builder = req_builder.query(&[("user__username", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginatedScimSourceUserList`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginatedScimSourceUserList`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesScimUsersListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// SCIMSourceUser Viewset
pub async fn sources_scim_users_partial_update(
    configuration: &configuration::Configuration,
    id: &str,
    patched_scim_source_user_request: Option<models::PatchedScimSourceUserRequest>,
) -> Result<models::ScimSourceUser, Error<SourcesScimUsersPartialUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;
    let p_body_patched_scim_source_user_request = patched_scim_source_user_request;

    let uri_str = format!(
        "{}/sources/scim_users/{id}/",
        configuration.base_path,
        id = crate::apis::urlencode(p_path_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_patched_scim_source_user_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::ScimSourceUser`",
                )))
            }
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!(
                "Received `{unknown_type}` content type response that cannot be converted to `models::ScimSourceUser`"
            )))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesScimUsersPartialUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// SCIMSourceUser Viewset
pub async fn sources_scim_users_retrieve(
    configuration: &configuration::Configuration,
    id: &str,
) -> Result<models::ScimSourceUser, Error<SourcesScimUsersRetrieveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;

    let uri_str = format!(
        "{}/sources/scim_users/{id}/",
        configuration.base_path,
        id = crate::apis::urlencode(p_path_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::ScimSourceUser`",
                )))
            }
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!(
                "Received `{unknown_type}` content type response that cannot be converted to `models::ScimSourceUser`"
            )))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesScimUsersRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// SCIMSourceUser Viewset
pub async fn sources_scim_users_update(
    configuration: &configuration::Configuration,
    id: &str,
    scim_source_user_request: models::ScimSourceUserRequest,
) -> Result<models::ScimSourceUser, Error<SourcesScimUsersUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;
    let p_body_scim_source_user_request = scim_source_user_request;

    let uri_str = format!(
        "{}/sources/scim_users/{id}/",
        configuration.base_path,
        id = crate::apis::urlencode(p_path_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_scim_source_user_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::ScimSourceUser`",
                )))
            }
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!(
                "Received `{unknown_type}` content type response that cannot be converted to `models::ScimSourceUser`"
            )))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesScimUsersUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get a list of all objects that use this object
pub async fn sources_scim_users_used_by_list(
    configuration: &configuration::Configuration,
    id: &str,
) -> Result<Vec<models::UsedBy>, Error<SourcesScimUsersUsedByListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;

    let uri_str = format!(
        "{}/sources/scim_users/{id}/used_by/",
        configuration.base_path,
        id = crate::apis::urlencode(p_path_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesScimUsersUsedByListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// User-source connection Viewset
pub async fn sources_user_connections_all_destroy(
    configuration: &configuration::Configuration,
    id: i32,
) -> Result<(), Error<SourcesUserConnectionsAllDestroyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;

    let uri_str = format!(
        "{}/sources/user_connections/all/{id}/",
        configuration.base_path,
        id = p_path_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesUserConnectionsAllDestroyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// User-source connection Viewset
pub async fn sources_user_connections_all_list(
    configuration: &configuration::Configuration,
    ordering: Option<&str>,
    page: Option<i32>,
    page_size: Option<i32>,
    search: Option<&str>,
    source__slug: Option<&str>,
    user: Option<i32>,
) -> Result<models::PaginatedUserSourceConnectionList, Error<SourcesUserConnectionsAllListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_ordering = ordering;
    let p_query_page = page;
    let p_query_page_size = page_size;
    let p_query_search = search;
    let p_query_source__slug = source__slug;
    let p_query_user = user;

    let uri_str = format!("{}/sources/user_connections/all/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_ordering {
        req_builder = req_builder.query(&[("ordering", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page_size {
        req_builder = req_builder.query(&[("page_size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_search {
        req_builder = req_builder.query(&[("search", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_source__slug {
        req_builder = req_builder.query(&[("source__slug", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_user {
        req_builder = req_builder.query(&[("user", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginatedUserSourceConnectionList`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginatedUserSourceConnectionList`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesUserConnectionsAllListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// User-source connection Viewset
pub async fn sources_user_connections_all_partial_update(
    configuration: &configuration::Configuration,
    id: i32,
    patched_user_source_connection_request: Option<models::PatchedUserSourceConnectionRequest>,
) -> Result<models::UserSourceConnection, Error<SourcesUserConnectionsAllPartialUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;
    let p_body_patched_user_source_connection_request = patched_user_source_connection_request;

    let uri_str = format!(
        "{}/sources/user_connections/all/{id}/",
        configuration.base_path,
        id = p_path_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_patched_user_source_connection_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UserSourceConnection`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UserSourceConnection`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesUserConnectionsAllPartialUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// User-source connection Viewset
pub async fn sources_user_connections_all_retrieve(
    configuration: &configuration::Configuration,
    id: i32,
) -> Result<models::UserSourceConnection, Error<SourcesUserConnectionsAllRetrieveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;

    let uri_str = format!(
        "{}/sources/user_connections/all/{id}/",
        configuration.base_path,
        id = p_path_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UserSourceConnection`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UserSourceConnection`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesUserConnectionsAllRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// User-source connection Viewset
pub async fn sources_user_connections_all_update(
    configuration: &configuration::Configuration,
    id: i32,
    user_source_connection_request: models::UserSourceConnectionRequest,
) -> Result<models::UserSourceConnection, Error<SourcesUserConnectionsAllUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;
    let p_body_user_source_connection_request = user_source_connection_request;

    let uri_str = format!(
        "{}/sources/user_connections/all/{id}/",
        configuration.base_path,
        id = p_path_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_user_source_connection_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UserSourceConnection`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UserSourceConnection`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesUserConnectionsAllUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get a list of all objects that use this object
pub async fn sources_user_connections_all_used_by_list(
    configuration: &configuration::Configuration,
    id: i32,
) -> Result<Vec<models::UsedBy>, Error<SourcesUserConnectionsAllUsedByListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;

    let uri_str = format!(
        "{}/sources/user_connections/all/{id}/used_by/",
        configuration.base_path,
        id = p_path_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesUserConnectionsAllUsedByListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Source Viewset
pub async fn sources_user_connections_kerberos_create(
    configuration: &configuration::Configuration,
    user_kerberos_source_connection_request: models::UserKerberosSourceConnectionRequest,
) -> Result<models::UserKerberosSourceConnection, Error<SourcesUserConnectionsKerberosCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_user_kerberos_source_connection_request = user_kerberos_source_connection_request;

    let uri_str = format!("{}/sources/user_connections/kerberos/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_user_kerberos_source_connection_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UserKerberosSourceConnection`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UserKerberosSourceConnection`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesUserConnectionsKerberosCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Source Viewset
pub async fn sources_user_connections_kerberos_destroy(
    configuration: &configuration::Configuration,
    id: i32,
) -> Result<(), Error<SourcesUserConnectionsKerberosDestroyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;

    let uri_str = format!(
        "{}/sources/user_connections/kerberos/{id}/",
        configuration.base_path,
        id = p_path_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesUserConnectionsKerberosDestroyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Source Viewset
pub async fn sources_user_connections_kerberos_list(
    configuration: &configuration::Configuration,
    ordering: Option<&str>,
    page: Option<i32>,
    page_size: Option<i32>,
    search: Option<&str>,
    source__slug: Option<&str>,
) -> Result<models::PaginatedUserKerberosSourceConnectionList, Error<SourcesUserConnectionsKerberosListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_ordering = ordering;
    let p_query_page = page;
    let p_query_page_size = page_size;
    let p_query_search = search;
    let p_query_source__slug = source__slug;

    let uri_str = format!("{}/sources/user_connections/kerberos/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_ordering {
        req_builder = req_builder.query(&[("ordering", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page_size {
        req_builder = req_builder.query(&[("page_size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_search {
        req_builder = req_builder.query(&[("search", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_source__slug {
        req_builder = req_builder.query(&[("source__slug", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginatedUserKerberosSourceConnectionList`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginatedUserKerberosSourceConnectionList`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesUserConnectionsKerberosListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Source Viewset
pub async fn sources_user_connections_kerberos_partial_update(
    configuration: &configuration::Configuration,
    id: i32,
    patched_user_kerberos_source_connection_request: Option<models::PatchedUserKerberosSourceConnectionRequest>,
) -> Result<models::UserKerberosSourceConnection, Error<SourcesUserConnectionsKerberosPartialUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;
    let p_body_patched_user_kerberos_source_connection_request = patched_user_kerberos_source_connection_request;

    let uri_str = format!(
        "{}/sources/user_connections/kerberos/{id}/",
        configuration.base_path,
        id = p_path_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_patched_user_kerberos_source_connection_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UserKerberosSourceConnection`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UserKerberosSourceConnection`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesUserConnectionsKerberosPartialUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Source Viewset
pub async fn sources_user_connections_kerberos_retrieve(
    configuration: &configuration::Configuration,
    id: i32,
) -> Result<models::UserKerberosSourceConnection, Error<SourcesUserConnectionsKerberosRetrieveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;

    let uri_str = format!(
        "{}/sources/user_connections/kerberos/{id}/",
        configuration.base_path,
        id = p_path_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UserKerberosSourceConnection`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UserKerberosSourceConnection`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesUserConnectionsKerberosRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Source Viewset
pub async fn sources_user_connections_kerberos_update(
    configuration: &configuration::Configuration,
    id: i32,
    user_kerberos_source_connection_request: models::UserKerberosSourceConnectionRequest,
) -> Result<models::UserKerberosSourceConnection, Error<SourcesUserConnectionsKerberosUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;
    let p_body_user_kerberos_source_connection_request = user_kerberos_source_connection_request;

    let uri_str = format!(
        "{}/sources/user_connections/kerberos/{id}/",
        configuration.base_path,
        id = p_path_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_user_kerberos_source_connection_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UserKerberosSourceConnection`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UserKerberosSourceConnection`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesUserConnectionsKerberosUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get a list of all objects that use this object
pub async fn sources_user_connections_kerberos_used_by_list(
    configuration: &configuration::Configuration,
    id: i32,
) -> Result<Vec<models::UsedBy>, Error<SourcesUserConnectionsKerberosUsedByListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;

    let uri_str = format!(
        "{}/sources/user_connections/kerberos/{id}/used_by/",
        configuration.base_path,
        id = p_path_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesUserConnectionsKerberosUsedByListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Source Viewset
pub async fn sources_user_connections_oauth_create(
    configuration: &configuration::Configuration,
    user_o_auth_source_connection_request: models::UserOAuthSourceConnectionRequest,
) -> Result<models::UserOAuthSourceConnection, Error<SourcesUserConnectionsOauthCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_user_o_auth_source_connection_request = user_o_auth_source_connection_request;

    let uri_str = format!("{}/sources/user_connections/oauth/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_user_o_auth_source_connection_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UserOAuthSourceConnection`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UserOAuthSourceConnection`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesUserConnectionsOauthCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Source Viewset
pub async fn sources_user_connections_oauth_destroy(
    configuration: &configuration::Configuration,
    id: i32,
) -> Result<(), Error<SourcesUserConnectionsOauthDestroyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;

    let uri_str = format!(
        "{}/sources/user_connections/oauth/{id}/",
        configuration.base_path,
        id = p_path_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesUserConnectionsOauthDestroyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Source Viewset
pub async fn sources_user_connections_oauth_list(
    configuration: &configuration::Configuration,
    ordering: Option<&str>,
    page: Option<i32>,
    page_size: Option<i32>,
    search: Option<&str>,
    source__slug: Option<&str>,
    user: Option<i32>,
) -> Result<models::PaginatedUserOAuthSourceConnectionList, Error<SourcesUserConnectionsOauthListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_ordering = ordering;
    let p_query_page = page;
    let p_query_page_size = page_size;
    let p_query_search = search;
    let p_query_source__slug = source__slug;
    let p_query_user = user;

    let uri_str = format!("{}/sources/user_connections/oauth/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_ordering {
        req_builder = req_builder.query(&[("ordering", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page_size {
        req_builder = req_builder.query(&[("page_size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_search {
        req_builder = req_builder.query(&[("search", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_source__slug {
        req_builder = req_builder.query(&[("source__slug", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_user {
        req_builder = req_builder.query(&[("user", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginatedUserOAuthSourceConnectionList`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginatedUserOAuthSourceConnectionList`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesUserConnectionsOauthListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Source Viewset
pub async fn sources_user_connections_oauth_partial_update(
    configuration: &configuration::Configuration,
    id: i32,
    patched_user_o_auth_source_connection_request: Option<models::PatchedUserOAuthSourceConnectionRequest>,
) -> Result<models::UserOAuthSourceConnection, Error<SourcesUserConnectionsOauthPartialUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;
    let p_body_patched_user_o_auth_source_connection_request = patched_user_o_auth_source_connection_request;

    let uri_str = format!(
        "{}/sources/user_connections/oauth/{id}/",
        configuration.base_path,
        id = p_path_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_patched_user_o_auth_source_connection_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UserOAuthSourceConnection`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UserOAuthSourceConnection`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesUserConnectionsOauthPartialUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Source Viewset
pub async fn sources_user_connections_oauth_retrieve(
    configuration: &configuration::Configuration,
    id: i32,
) -> Result<models::UserOAuthSourceConnection, Error<SourcesUserConnectionsOauthRetrieveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;

    let uri_str = format!(
        "{}/sources/user_connections/oauth/{id}/",
        configuration.base_path,
        id = p_path_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UserOAuthSourceConnection`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UserOAuthSourceConnection`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesUserConnectionsOauthRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Source Viewset
pub async fn sources_user_connections_oauth_update(
    configuration: &configuration::Configuration,
    id: i32,
    user_o_auth_source_connection_request: models::UserOAuthSourceConnectionRequest,
) -> Result<models::UserOAuthSourceConnection, Error<SourcesUserConnectionsOauthUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;
    let p_body_user_o_auth_source_connection_request = user_o_auth_source_connection_request;

    let uri_str = format!(
        "{}/sources/user_connections/oauth/{id}/",
        configuration.base_path,
        id = p_path_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_user_o_auth_source_connection_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UserOAuthSourceConnection`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UserOAuthSourceConnection`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesUserConnectionsOauthUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get a list of all objects that use this object
pub async fn sources_user_connections_oauth_used_by_list(
    configuration: &configuration::Configuration,
    id: i32,
) -> Result<Vec<models::UsedBy>, Error<SourcesUserConnectionsOauthUsedByListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;

    let uri_str = format!(
        "{}/sources/user_connections/oauth/{id}/used_by/",
        configuration.base_path,
        id = p_path_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesUserConnectionsOauthUsedByListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Plex Source connection Serializer
pub async fn sources_user_connections_plex_create(
    configuration: &configuration::Configuration,
    user_plex_source_connection_request: models::UserPlexSourceConnectionRequest,
) -> Result<models::UserPlexSourceConnection, Error<SourcesUserConnectionsPlexCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_user_plex_source_connection_request = user_plex_source_connection_request;

    let uri_str = format!("{}/sources/user_connections/plex/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_user_plex_source_connection_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UserPlexSourceConnection`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UserPlexSourceConnection`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesUserConnectionsPlexCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Plex Source connection Serializer
pub async fn sources_user_connections_plex_destroy(
    configuration: &configuration::Configuration,
    id: i32,
) -> Result<(), Error<SourcesUserConnectionsPlexDestroyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;

    let uri_str = format!(
        "{}/sources/user_connections/plex/{id}/",
        configuration.base_path,
        id = p_path_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesUserConnectionsPlexDestroyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Plex Source connection Serializer
pub async fn sources_user_connections_plex_list(
    configuration: &configuration::Configuration,
    ordering: Option<&str>,
    page: Option<i32>,
    page_size: Option<i32>,
    search: Option<&str>,
    source__slug: Option<&str>,
    user: Option<i32>,
) -> Result<models::PaginatedUserPlexSourceConnectionList, Error<SourcesUserConnectionsPlexListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_ordering = ordering;
    let p_query_page = page;
    let p_query_page_size = page_size;
    let p_query_search = search;
    let p_query_source__slug = source__slug;
    let p_query_user = user;

    let uri_str = format!("{}/sources/user_connections/plex/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_ordering {
        req_builder = req_builder.query(&[("ordering", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page_size {
        req_builder = req_builder.query(&[("page_size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_search {
        req_builder = req_builder.query(&[("search", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_source__slug {
        req_builder = req_builder.query(&[("source__slug", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_user {
        req_builder = req_builder.query(&[("user", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginatedUserPlexSourceConnectionList`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginatedUserPlexSourceConnectionList`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesUserConnectionsPlexListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Plex Source connection Serializer
pub async fn sources_user_connections_plex_partial_update(
    configuration: &configuration::Configuration,
    id: i32,
    patched_user_plex_source_connection_request: Option<models::PatchedUserPlexSourceConnectionRequest>,
) -> Result<models::UserPlexSourceConnection, Error<SourcesUserConnectionsPlexPartialUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;
    let p_body_patched_user_plex_source_connection_request = patched_user_plex_source_connection_request;

    let uri_str = format!(
        "{}/sources/user_connections/plex/{id}/",
        configuration.base_path,
        id = p_path_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_patched_user_plex_source_connection_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UserPlexSourceConnection`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UserPlexSourceConnection`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesUserConnectionsPlexPartialUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Plex Source connection Serializer
pub async fn sources_user_connections_plex_retrieve(
    configuration: &configuration::Configuration,
    id: i32,
) -> Result<models::UserPlexSourceConnection, Error<SourcesUserConnectionsPlexRetrieveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;

    let uri_str = format!(
        "{}/sources/user_connections/plex/{id}/",
        configuration.base_path,
        id = p_path_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UserPlexSourceConnection`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UserPlexSourceConnection`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesUserConnectionsPlexRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Plex Source connection Serializer
pub async fn sources_user_connections_plex_update(
    configuration: &configuration::Configuration,
    id: i32,
    user_plex_source_connection_request: models::UserPlexSourceConnectionRequest,
) -> Result<models::UserPlexSourceConnection, Error<SourcesUserConnectionsPlexUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;
    let p_body_user_plex_source_connection_request = user_plex_source_connection_request;

    let uri_str = format!(
        "{}/sources/user_connections/plex/{id}/",
        configuration.base_path,
        id = p_path_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_user_plex_source_connection_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UserPlexSourceConnection`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UserPlexSourceConnection`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesUserConnectionsPlexUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get a list of all objects that use this object
pub async fn sources_user_connections_plex_used_by_list(
    configuration: &configuration::Configuration,
    id: i32,
) -> Result<Vec<models::UsedBy>, Error<SourcesUserConnectionsPlexUsedByListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;

    let uri_str = format!(
        "{}/sources/user_connections/plex/{id}/used_by/",
        configuration.base_path,
        id = p_path_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesUserConnectionsPlexUsedByListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Source Viewset
pub async fn sources_user_connections_saml_create(
    configuration: &configuration::Configuration,
    user_saml_source_connection_request: models::UserSamlSourceConnectionRequest,
) -> Result<models::UserSamlSourceConnection, Error<SourcesUserConnectionsSamlCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_user_saml_source_connection_request = user_saml_source_connection_request;

    let uri_str = format!("{}/sources/user_connections/saml/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_user_saml_source_connection_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UserSamlSourceConnection`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UserSamlSourceConnection`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesUserConnectionsSamlCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Source Viewset
pub async fn sources_user_connections_saml_destroy(
    configuration: &configuration::Configuration,
    id: i32,
) -> Result<(), Error<SourcesUserConnectionsSamlDestroyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;

    let uri_str = format!(
        "{}/sources/user_connections/saml/{id}/",
        configuration.base_path,
        id = p_path_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesUserConnectionsSamlDestroyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Source Viewset
pub async fn sources_user_connections_saml_list(
    configuration: &configuration::Configuration,
    ordering: Option<&str>,
    page: Option<i32>,
    page_size: Option<i32>,
    search: Option<&str>,
    source__slug: Option<&str>,
    user: Option<i32>,
) -> Result<models::PaginatedUserSamlSourceConnectionList, Error<SourcesUserConnectionsSamlListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_ordering = ordering;
    let p_query_page = page;
    let p_query_page_size = page_size;
    let p_query_search = search;
    let p_query_source__slug = source__slug;
    let p_query_user = user;

    let uri_str = format!("{}/sources/user_connections/saml/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_ordering {
        req_builder = req_builder.query(&[("ordering", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page_size {
        req_builder = req_builder.query(&[("page_size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_search {
        req_builder = req_builder.query(&[("search", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_source__slug {
        req_builder = req_builder.query(&[("source__slug", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_user {
        req_builder = req_builder.query(&[("user", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginatedUserSamlSourceConnectionList`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginatedUserSamlSourceConnectionList`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesUserConnectionsSamlListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Source Viewset
pub async fn sources_user_connections_saml_partial_update(
    configuration: &configuration::Configuration,
    id: i32,
    patched_user_saml_source_connection_request: Option<models::PatchedUserSamlSourceConnectionRequest>,
) -> Result<models::UserSamlSourceConnection, Error<SourcesUserConnectionsSamlPartialUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;
    let p_body_patched_user_saml_source_connection_request = patched_user_saml_source_connection_request;

    let uri_str = format!(
        "{}/sources/user_connections/saml/{id}/",
        configuration.base_path,
        id = p_path_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_patched_user_saml_source_connection_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UserSamlSourceConnection`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UserSamlSourceConnection`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesUserConnectionsSamlPartialUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Source Viewset
pub async fn sources_user_connections_saml_retrieve(
    configuration: &configuration::Configuration,
    id: i32,
) -> Result<models::UserSamlSourceConnection, Error<SourcesUserConnectionsSamlRetrieveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;

    let uri_str = format!(
        "{}/sources/user_connections/saml/{id}/",
        configuration.base_path,
        id = p_path_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UserSamlSourceConnection`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UserSamlSourceConnection`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesUserConnectionsSamlRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Source Viewset
pub async fn sources_user_connections_saml_update(
    configuration: &configuration::Configuration,
    id: i32,
    user_saml_source_connection_request: models::UserSamlSourceConnectionRequest,
) -> Result<models::UserSamlSourceConnection, Error<SourcesUserConnectionsSamlUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;
    let p_body_user_saml_source_connection_request = user_saml_source_connection_request;

    let uri_str = format!(
        "{}/sources/user_connections/saml/{id}/",
        configuration.base_path,
        id = p_path_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_user_saml_source_connection_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UserSamlSourceConnection`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UserSamlSourceConnection`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesUserConnectionsSamlUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get a list of all objects that use this object
pub async fn sources_user_connections_saml_used_by_list(
    configuration: &configuration::Configuration,
    id: i32,
) -> Result<Vec<models::UsedBy>, Error<SourcesUserConnectionsSamlUsedByListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;

    let uri_str = format!(
        "{}/sources/user_connections/saml/{id}/used_by/",
        configuration.base_path,
        id = p_path_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<SourcesUserConnectionsSamlUsedByListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
