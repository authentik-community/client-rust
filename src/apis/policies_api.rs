/*
 * authentik
 *
 * Making authentication simple.
 *
 * The version of the OpenAPI document: 2025.6.3
 * Contact: hello@goauthentik.io
 * Generated by: https://openapi-generator.tech
 */

use super::{configuration, ContentType, Error};
use crate::{apis::ResponseContent, models};
use reqwest;
use serde::{de::Error as _, Deserialize, Serialize};

/// struct for typed errors of method [`policies_all_cache_clear_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PoliciesAllCacheClearCreateError {
    Status400(),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`policies_all_cache_info_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PoliciesAllCacheInfoRetrieveError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`policies_all_destroy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PoliciesAllDestroyError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`policies_all_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PoliciesAllListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`policies_all_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PoliciesAllRetrieveError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`policies_all_test_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PoliciesAllTestCreateError {
    Status400(),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`policies_all_types_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PoliciesAllTypesListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`policies_all_used_by_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PoliciesAllUsedByListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`policies_bindings_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PoliciesBindingsCreateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`policies_bindings_destroy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PoliciesBindingsDestroyError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`policies_bindings_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PoliciesBindingsListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`policies_bindings_partial_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PoliciesBindingsPartialUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`policies_bindings_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PoliciesBindingsRetrieveError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`policies_bindings_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PoliciesBindingsUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`policies_bindings_used_by_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PoliciesBindingsUsedByListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`policies_dummy_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PoliciesDummyCreateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`policies_dummy_destroy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PoliciesDummyDestroyError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`policies_dummy_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PoliciesDummyListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`policies_dummy_partial_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PoliciesDummyPartialUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`policies_dummy_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PoliciesDummyRetrieveError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`policies_dummy_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PoliciesDummyUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`policies_dummy_used_by_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PoliciesDummyUsedByListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`policies_event_matcher_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PoliciesEventMatcherCreateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`policies_event_matcher_destroy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PoliciesEventMatcherDestroyError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`policies_event_matcher_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PoliciesEventMatcherListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`policies_event_matcher_partial_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PoliciesEventMatcherPartialUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`policies_event_matcher_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PoliciesEventMatcherRetrieveError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`policies_event_matcher_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PoliciesEventMatcherUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`policies_event_matcher_used_by_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PoliciesEventMatcherUsedByListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`policies_expression_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PoliciesExpressionCreateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`policies_expression_destroy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PoliciesExpressionDestroyError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`policies_expression_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PoliciesExpressionListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`policies_expression_partial_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PoliciesExpressionPartialUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`policies_expression_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PoliciesExpressionRetrieveError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`policies_expression_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PoliciesExpressionUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`policies_expression_used_by_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PoliciesExpressionUsedByListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`policies_geoip_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PoliciesGeoipCreateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`policies_geoip_destroy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PoliciesGeoipDestroyError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`policies_geoip_iso3166_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PoliciesGeoipIso3166ListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`policies_geoip_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PoliciesGeoipListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`policies_geoip_partial_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PoliciesGeoipPartialUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`policies_geoip_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PoliciesGeoipRetrieveError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`policies_geoip_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PoliciesGeoipUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`policies_geoip_used_by_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PoliciesGeoipUsedByListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`policies_password_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PoliciesPasswordCreateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`policies_password_destroy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PoliciesPasswordDestroyError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`policies_password_expiry_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PoliciesPasswordExpiryCreateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`policies_password_expiry_destroy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PoliciesPasswordExpiryDestroyError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`policies_password_expiry_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PoliciesPasswordExpiryListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`policies_password_expiry_partial_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PoliciesPasswordExpiryPartialUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`policies_password_expiry_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PoliciesPasswordExpiryRetrieveError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`policies_password_expiry_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PoliciesPasswordExpiryUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`policies_password_expiry_used_by_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PoliciesPasswordExpiryUsedByListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`policies_password_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PoliciesPasswordListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`policies_password_partial_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PoliciesPasswordPartialUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`policies_password_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PoliciesPasswordRetrieveError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`policies_password_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PoliciesPasswordUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`policies_password_used_by_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PoliciesPasswordUsedByListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`policies_reputation_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PoliciesReputationCreateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`policies_reputation_destroy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PoliciesReputationDestroyError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`policies_reputation_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PoliciesReputationListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`policies_reputation_partial_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PoliciesReputationPartialUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`policies_reputation_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PoliciesReputationRetrieveError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`policies_reputation_scores_destroy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PoliciesReputationScoresDestroyError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`policies_reputation_scores_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PoliciesReputationScoresListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`policies_reputation_scores_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PoliciesReputationScoresRetrieveError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`policies_reputation_scores_used_by_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PoliciesReputationScoresUsedByListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`policies_reputation_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PoliciesReputationUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`policies_reputation_used_by_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PoliciesReputationUsedByListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`policies_unique_password_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PoliciesUniquePasswordCreateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`policies_unique_password_destroy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PoliciesUniquePasswordDestroyError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`policies_unique_password_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PoliciesUniquePasswordListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`policies_unique_password_partial_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PoliciesUniquePasswordPartialUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`policies_unique_password_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PoliciesUniquePasswordRetrieveError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`policies_unique_password_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PoliciesUniquePasswordUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`policies_unique_password_used_by_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PoliciesUniquePasswordUsedByListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// Clear policy cache
pub async fn policies_all_cache_clear_create(
    configuration: &configuration::Configuration,
) -> Result<(), Error<PoliciesAllCacheClearCreateError>> {
    let uri_str = format!("{}/policies/all/cache_clear/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<PoliciesAllCacheClearCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Info about cached policies
pub async fn policies_all_cache_info_retrieve(
    configuration: &configuration::Configuration,
) -> Result<models::Cache, Error<PoliciesAllCacheInfoRetrieveError>> {
    let uri_str = format!("{}/policies/all/cache_info/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::Cache`",
                )))
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::Cache`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PoliciesAllCacheInfoRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Policy Viewset
pub async fn policies_all_destroy(
    configuration: &configuration::Configuration,
    policy_uuid: &str,
) -> Result<(), Error<PoliciesAllDestroyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_policy_uuid = policy_uuid;

    let uri_str = format!(
        "{}/policies/all/{policy_uuid}/",
        configuration.base_path,
        policy_uuid = crate::apis::urlencode(p_path_policy_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<PoliciesAllDestroyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Policy Viewset
pub async fn policies_all_list(
    configuration: &configuration::Configuration,
    bindings__isnull: Option<bool>,
    ordering: Option<&str>,
    page: Option<i32>,
    page_size: Option<i32>,
    promptstage__isnull: Option<bool>,
    search: Option<&str>,
) -> Result<models::PaginatedPolicyList, Error<PoliciesAllListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_bindings__isnull = bindings__isnull;
    let p_query_ordering = ordering;
    let p_query_page = page;
    let p_query_page_size = page_size;
    let p_query_promptstage__isnull = promptstage__isnull;
    let p_query_search = search;

    let uri_str = format!("{}/policies/all/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_bindings__isnull {
        req_builder = req_builder.query(&[("bindings__isnull", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ordering {
        req_builder = req_builder.query(&[("ordering", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page_size {
        req_builder = req_builder.query(&[("page_size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_promptstage__isnull {
        req_builder = req_builder.query(&[("promptstage__isnull", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_search {
        req_builder = req_builder.query(&[("search", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginatedPolicyList`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginatedPolicyList`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PoliciesAllListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Policy Viewset
pub async fn policies_all_retrieve(
    configuration: &configuration::Configuration,
    policy_uuid: &str,
) -> Result<models::Policy, Error<PoliciesAllRetrieveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_policy_uuid = policy_uuid;

    let uri_str = format!(
        "{}/policies/all/{policy_uuid}/",
        configuration.base_path,
        policy_uuid = crate::apis::urlencode(p_path_policy_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::Policy`",
                )))
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::Policy`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PoliciesAllRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Test policy
pub async fn policies_all_test_create(
    configuration: &configuration::Configuration,
    policy_uuid: &str,
    policy_test_request: models::PolicyTestRequest,
) -> Result<models::PolicyTestResult, Error<PoliciesAllTestCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_policy_uuid = policy_uuid;
    let p_body_policy_test_request = policy_test_request;

    let uri_str = format!(
        "{}/policies/all/{policy_uuid}/test/",
        configuration.base_path,
        policy_uuid = crate::apis::urlencode(p_path_policy_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_policy_test_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PolicyTestResult`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PolicyTestResult`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PoliciesAllTestCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get all creatable types
pub async fn policies_all_types_list(
    configuration: &configuration::Configuration,
) -> Result<Vec<models::TypeCreate>, Error<PoliciesAllTypesListError>> {
    let uri_str = format!("{}/policies/all/types/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::TypeCreate&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::TypeCreate&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PoliciesAllTypesListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get a list of all objects that use this object
pub async fn policies_all_used_by_list(
    configuration: &configuration::Configuration,
    policy_uuid: &str,
) -> Result<Vec<models::UsedBy>, Error<PoliciesAllUsedByListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_policy_uuid = policy_uuid;

    let uri_str = format!(
        "{}/policies/all/{policy_uuid}/used_by/",
        configuration.base_path,
        policy_uuid = crate::apis::urlencode(p_path_policy_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PoliciesAllUsedByListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// PolicyBinding Viewset
pub async fn policies_bindings_create(
    configuration: &configuration::Configuration,
    policy_binding_request: models::PolicyBindingRequest,
) -> Result<models::PolicyBinding, Error<PoliciesBindingsCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_policy_binding_request = policy_binding_request;

    let uri_str = format!("{}/policies/bindings/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_policy_binding_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::PolicyBinding`",
                )))
            }
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!(
                "Received `{unknown_type}` content type response that cannot be converted to `models::PolicyBinding`"
            )))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PoliciesBindingsCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// PolicyBinding Viewset
pub async fn policies_bindings_destroy(
    configuration: &configuration::Configuration,
    policy_binding_uuid: &str,
) -> Result<(), Error<PoliciesBindingsDestroyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_policy_binding_uuid = policy_binding_uuid;

    let uri_str = format!(
        "{}/policies/bindings/{policy_binding_uuid}/",
        configuration.base_path,
        policy_binding_uuid = crate::apis::urlencode(p_path_policy_binding_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<PoliciesBindingsDestroyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// PolicyBinding Viewset
pub async fn policies_bindings_list(
    configuration: &configuration::Configuration,
    enabled: Option<bool>,
    order: Option<i32>,
    ordering: Option<&str>,
    page: Option<i32>,
    page_size: Option<i32>,
    policy: Option<&str>,
    policy__isnull: Option<bool>,
    search: Option<&str>,
    target: Option<&str>,
    target_in: Option<Vec<uuid::Uuid>>,
    timeout: Option<i32>,
) -> Result<models::PaginatedPolicyBindingList, Error<PoliciesBindingsListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_enabled = enabled;
    let p_query_order = order;
    let p_query_ordering = ordering;
    let p_query_page = page;
    let p_query_page_size = page_size;
    let p_query_policy = policy;
    let p_query_policy__isnull = policy__isnull;
    let p_query_search = search;
    let p_query_target = target;
    let p_query_target_in = target_in;
    let p_query_timeout = timeout;

    let uri_str = format!("{}/policies/bindings/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_enabled {
        req_builder = req_builder.query(&[("enabled", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_order {
        req_builder = req_builder.query(&[("order", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ordering {
        req_builder = req_builder.query(&[("ordering", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page_size {
        req_builder = req_builder.query(&[("page_size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_policy {
        req_builder = req_builder.query(&[("policy", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_policy__isnull {
        req_builder = req_builder.query(&[("policy__isnull", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_search {
        req_builder = req_builder.query(&[("search", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_target {
        req_builder = req_builder.query(&[("target", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_target_in {
        req_builder = match "multi" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("target_in".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "target_in",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = p_query_timeout {
        req_builder = req_builder.query(&[("timeout", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginatedPolicyBindingList`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginatedPolicyBindingList`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PoliciesBindingsListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// PolicyBinding Viewset
pub async fn policies_bindings_partial_update(
    configuration: &configuration::Configuration,
    policy_binding_uuid: &str,
    patched_policy_binding_request: Option<models::PatchedPolicyBindingRequest>,
) -> Result<models::PolicyBinding, Error<PoliciesBindingsPartialUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_policy_binding_uuid = policy_binding_uuid;
    let p_body_patched_policy_binding_request = patched_policy_binding_request;

    let uri_str = format!(
        "{}/policies/bindings/{policy_binding_uuid}/",
        configuration.base_path,
        policy_binding_uuid = crate::apis::urlencode(p_path_policy_binding_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_patched_policy_binding_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::PolicyBinding`",
                )))
            }
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!(
                "Received `{unknown_type}` content type response that cannot be converted to `models::PolicyBinding`"
            )))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PoliciesBindingsPartialUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// PolicyBinding Viewset
pub async fn policies_bindings_retrieve(
    configuration: &configuration::Configuration,
    policy_binding_uuid: &str,
) -> Result<models::PolicyBinding, Error<PoliciesBindingsRetrieveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_policy_binding_uuid = policy_binding_uuid;

    let uri_str = format!(
        "{}/policies/bindings/{policy_binding_uuid}/",
        configuration.base_path,
        policy_binding_uuid = crate::apis::urlencode(p_path_policy_binding_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::PolicyBinding`",
                )))
            }
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!(
                "Received `{unknown_type}` content type response that cannot be converted to `models::PolicyBinding`"
            )))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PoliciesBindingsRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// PolicyBinding Viewset
pub async fn policies_bindings_update(
    configuration: &configuration::Configuration,
    policy_binding_uuid: &str,
    policy_binding_request: models::PolicyBindingRequest,
) -> Result<models::PolicyBinding, Error<PoliciesBindingsUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_policy_binding_uuid = policy_binding_uuid;
    let p_body_policy_binding_request = policy_binding_request;

    let uri_str = format!(
        "{}/policies/bindings/{policy_binding_uuid}/",
        configuration.base_path,
        policy_binding_uuid = crate::apis::urlencode(p_path_policy_binding_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_policy_binding_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::PolicyBinding`",
                )))
            }
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!(
                "Received `{unknown_type}` content type response that cannot be converted to `models::PolicyBinding`"
            )))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PoliciesBindingsUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get a list of all objects that use this object
pub async fn policies_bindings_used_by_list(
    configuration: &configuration::Configuration,
    policy_binding_uuid: &str,
) -> Result<Vec<models::UsedBy>, Error<PoliciesBindingsUsedByListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_policy_binding_uuid = policy_binding_uuid;

    let uri_str = format!(
        "{}/policies/bindings/{policy_binding_uuid}/used_by/",
        configuration.base_path,
        policy_binding_uuid = crate::apis::urlencode(p_path_policy_binding_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PoliciesBindingsUsedByListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Dummy Viewset
pub async fn policies_dummy_create(
    configuration: &configuration::Configuration,
    dummy_policy_request: models::DummyPolicyRequest,
) -> Result<models::DummyPolicy, Error<PoliciesDummyCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_dummy_policy_request = dummy_policy_request;

    let uri_str = format!("{}/policies/dummy/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_dummy_policy_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::DummyPolicy`",
                )))
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::DummyPolicy`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PoliciesDummyCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Dummy Viewset
pub async fn policies_dummy_destroy(
    configuration: &configuration::Configuration,
    policy_uuid: &str,
) -> Result<(), Error<PoliciesDummyDestroyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_policy_uuid = policy_uuid;

    let uri_str = format!(
        "{}/policies/dummy/{policy_uuid}/",
        configuration.base_path,
        policy_uuid = crate::apis::urlencode(p_path_policy_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<PoliciesDummyDestroyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Dummy Viewset
pub async fn policies_dummy_list(
    configuration: &configuration::Configuration,
    created: Option<String>,
    execution_logging: Option<bool>,
    last_updated: Option<String>,
    name: Option<&str>,
    ordering: Option<&str>,
    page: Option<i32>,
    page_size: Option<i32>,
    policy_uuid: Option<&str>,
    result: Option<bool>,
    search: Option<&str>,
    wait_max: Option<i32>,
    wait_min: Option<i32>,
) -> Result<models::PaginatedDummyPolicyList, Error<PoliciesDummyListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_created = created;
    let p_query_execution_logging = execution_logging;
    let p_query_last_updated = last_updated;
    let p_query_name = name;
    let p_query_ordering = ordering;
    let p_query_page = page;
    let p_query_page_size = page_size;
    let p_query_policy_uuid = policy_uuid;
    let p_query_result = result;
    let p_query_search = search;
    let p_query_wait_max = wait_max;
    let p_query_wait_min = wait_min;

    let uri_str = format!("{}/policies/dummy/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_created {
        req_builder = req_builder.query(&[("created", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_execution_logging {
        req_builder = req_builder.query(&[("execution_logging", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_last_updated {
        req_builder = req_builder.query(&[("last_updated", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ordering {
        req_builder = req_builder.query(&[("ordering", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page_size {
        req_builder = req_builder.query(&[("page_size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_policy_uuid {
        req_builder = req_builder.query(&[("policy_uuid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_result {
        req_builder = req_builder.query(&[("result", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_search {
        req_builder = req_builder.query(&[("search", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_wait_max {
        req_builder = req_builder.query(&[("wait_max", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_wait_min {
        req_builder = req_builder.query(&[("wait_min", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginatedDummyPolicyList`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginatedDummyPolicyList`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PoliciesDummyListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Dummy Viewset
pub async fn policies_dummy_partial_update(
    configuration: &configuration::Configuration,
    policy_uuid: &str,
    patched_dummy_policy_request: Option<models::PatchedDummyPolicyRequest>,
) -> Result<models::DummyPolicy, Error<PoliciesDummyPartialUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_policy_uuid = policy_uuid;
    let p_body_patched_dummy_policy_request = patched_dummy_policy_request;

    let uri_str = format!(
        "{}/policies/dummy/{policy_uuid}/",
        configuration.base_path,
        policy_uuid = crate::apis::urlencode(p_path_policy_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_patched_dummy_policy_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::DummyPolicy`",
                )))
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::DummyPolicy`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PoliciesDummyPartialUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Dummy Viewset
pub async fn policies_dummy_retrieve(
    configuration: &configuration::Configuration,
    policy_uuid: &str,
) -> Result<models::DummyPolicy, Error<PoliciesDummyRetrieveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_policy_uuid = policy_uuid;

    let uri_str = format!(
        "{}/policies/dummy/{policy_uuid}/",
        configuration.base_path,
        policy_uuid = crate::apis::urlencode(p_path_policy_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::DummyPolicy`",
                )))
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::DummyPolicy`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PoliciesDummyRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Dummy Viewset
pub async fn policies_dummy_update(
    configuration: &configuration::Configuration,
    policy_uuid: &str,
    dummy_policy_request: models::DummyPolicyRequest,
) -> Result<models::DummyPolicy, Error<PoliciesDummyUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_policy_uuid = policy_uuid;
    let p_body_dummy_policy_request = dummy_policy_request;

    let uri_str = format!(
        "{}/policies/dummy/{policy_uuid}/",
        configuration.base_path,
        policy_uuid = crate::apis::urlencode(p_path_policy_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_dummy_policy_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::DummyPolicy`",
                )))
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::DummyPolicy`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PoliciesDummyUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get a list of all objects that use this object
pub async fn policies_dummy_used_by_list(
    configuration: &configuration::Configuration,
    policy_uuid: &str,
) -> Result<Vec<models::UsedBy>, Error<PoliciesDummyUsedByListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_policy_uuid = policy_uuid;

    let uri_str = format!(
        "{}/policies/dummy/{policy_uuid}/used_by/",
        configuration.base_path,
        policy_uuid = crate::apis::urlencode(p_path_policy_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PoliciesDummyUsedByListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Event Matcher Policy Viewset
pub async fn policies_event_matcher_create(
    configuration: &configuration::Configuration,
    event_matcher_policy_request: models::EventMatcherPolicyRequest,
) -> Result<models::EventMatcherPolicy, Error<PoliciesEventMatcherCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_event_matcher_policy_request = event_matcher_policy_request;

    let uri_str = format!("{}/policies/event_matcher/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_event_matcher_policy_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EventMatcherPolicy`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EventMatcherPolicy`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PoliciesEventMatcherCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Event Matcher Policy Viewset
pub async fn policies_event_matcher_destroy(
    configuration: &configuration::Configuration,
    policy_uuid: &str,
) -> Result<(), Error<PoliciesEventMatcherDestroyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_policy_uuid = policy_uuid;

    let uri_str = format!(
        "{}/policies/event_matcher/{policy_uuid}/",
        configuration.base_path,
        policy_uuid = crate::apis::urlencode(p_path_policy_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<PoliciesEventMatcherDestroyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Event Matcher Policy Viewset
pub async fn policies_event_matcher_list(
    configuration: &configuration::Configuration,
    action: Option<&str>,
    app: Option<&str>,
    client_ip: Option<&str>,
    created: Option<String>,
    execution_logging: Option<bool>,
    last_updated: Option<String>,
    model: Option<&str>,
    name: Option<&str>,
    ordering: Option<&str>,
    page: Option<i32>,
    page_size: Option<i32>,
    policy_uuid: Option<&str>,
    search: Option<&str>,
) -> Result<models::PaginatedEventMatcherPolicyList, Error<PoliciesEventMatcherListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_action = action;
    let p_query_app = app;
    let p_query_client_ip = client_ip;
    let p_query_created = created;
    let p_query_execution_logging = execution_logging;
    let p_query_last_updated = last_updated;
    let p_query_model = model;
    let p_query_name = name;
    let p_query_ordering = ordering;
    let p_query_page = page;
    let p_query_page_size = page_size;
    let p_query_policy_uuid = policy_uuid;
    let p_query_search = search;

    let uri_str = format!("{}/policies/event_matcher/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_action {
        req_builder = req_builder.query(&[("action", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_app {
        req_builder = req_builder.query(&[("app", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_client_ip {
        req_builder = req_builder.query(&[("client_ip", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_created {
        req_builder = req_builder.query(&[("created", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_execution_logging {
        req_builder = req_builder.query(&[("execution_logging", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_last_updated {
        req_builder = req_builder.query(&[("last_updated", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_model {
        req_builder = req_builder.query(&[("model", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ordering {
        req_builder = req_builder.query(&[("ordering", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page_size {
        req_builder = req_builder.query(&[("page_size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_policy_uuid {
        req_builder = req_builder.query(&[("policy_uuid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_search {
        req_builder = req_builder.query(&[("search", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginatedEventMatcherPolicyList`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginatedEventMatcherPolicyList`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PoliciesEventMatcherListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Event Matcher Policy Viewset
pub async fn policies_event_matcher_partial_update(
    configuration: &configuration::Configuration,
    policy_uuid: &str,
    patched_event_matcher_policy_request: Option<models::PatchedEventMatcherPolicyRequest>,
) -> Result<models::EventMatcherPolicy, Error<PoliciesEventMatcherPartialUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_policy_uuid = policy_uuid;
    let p_body_patched_event_matcher_policy_request = patched_event_matcher_policy_request;

    let uri_str = format!(
        "{}/policies/event_matcher/{policy_uuid}/",
        configuration.base_path,
        policy_uuid = crate::apis::urlencode(p_path_policy_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_patched_event_matcher_policy_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EventMatcherPolicy`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EventMatcherPolicy`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PoliciesEventMatcherPartialUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Event Matcher Policy Viewset
pub async fn policies_event_matcher_retrieve(
    configuration: &configuration::Configuration,
    policy_uuid: &str,
) -> Result<models::EventMatcherPolicy, Error<PoliciesEventMatcherRetrieveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_policy_uuid = policy_uuid;

    let uri_str = format!(
        "{}/policies/event_matcher/{policy_uuid}/",
        configuration.base_path,
        policy_uuid = crate::apis::urlencode(p_path_policy_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EventMatcherPolicy`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EventMatcherPolicy`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PoliciesEventMatcherRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Event Matcher Policy Viewset
pub async fn policies_event_matcher_update(
    configuration: &configuration::Configuration,
    policy_uuid: &str,
    event_matcher_policy_request: models::EventMatcherPolicyRequest,
) -> Result<models::EventMatcherPolicy, Error<PoliciesEventMatcherUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_policy_uuid = policy_uuid;
    let p_body_event_matcher_policy_request = event_matcher_policy_request;

    let uri_str = format!(
        "{}/policies/event_matcher/{policy_uuid}/",
        configuration.base_path,
        policy_uuid = crate::apis::urlencode(p_path_policy_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_event_matcher_policy_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EventMatcherPolicy`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EventMatcherPolicy`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PoliciesEventMatcherUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get a list of all objects that use this object
pub async fn policies_event_matcher_used_by_list(
    configuration: &configuration::Configuration,
    policy_uuid: &str,
) -> Result<Vec<models::UsedBy>, Error<PoliciesEventMatcherUsedByListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_policy_uuid = policy_uuid;

    let uri_str = format!(
        "{}/policies/event_matcher/{policy_uuid}/used_by/",
        configuration.base_path,
        policy_uuid = crate::apis::urlencode(p_path_policy_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PoliciesEventMatcherUsedByListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Source Viewset
pub async fn policies_expression_create(
    configuration: &configuration::Configuration,
    expression_policy_request: models::ExpressionPolicyRequest,
) -> Result<models::ExpressionPolicy, Error<PoliciesExpressionCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_expression_policy_request = expression_policy_request;

    let uri_str = format!("{}/policies/expression/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_expression_policy_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ExpressionPolicy`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ExpressionPolicy`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PoliciesExpressionCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Source Viewset
pub async fn policies_expression_destroy(
    configuration: &configuration::Configuration,
    policy_uuid: &str,
) -> Result<(), Error<PoliciesExpressionDestroyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_policy_uuid = policy_uuid;

    let uri_str = format!(
        "{}/policies/expression/{policy_uuid}/",
        configuration.base_path,
        policy_uuid = crate::apis::urlencode(p_path_policy_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<PoliciesExpressionDestroyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Source Viewset
pub async fn policies_expression_list(
    configuration: &configuration::Configuration,
    created: Option<String>,
    execution_logging: Option<bool>,
    expression: Option<&str>,
    last_updated: Option<String>,
    name: Option<&str>,
    ordering: Option<&str>,
    page: Option<i32>,
    page_size: Option<i32>,
    policy_uuid: Option<&str>,
    search: Option<&str>,
) -> Result<models::PaginatedExpressionPolicyList, Error<PoliciesExpressionListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_created = created;
    let p_query_execution_logging = execution_logging;
    let p_query_expression = expression;
    let p_query_last_updated = last_updated;
    let p_query_name = name;
    let p_query_ordering = ordering;
    let p_query_page = page;
    let p_query_page_size = page_size;
    let p_query_policy_uuid = policy_uuid;
    let p_query_search = search;

    let uri_str = format!("{}/policies/expression/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_created {
        req_builder = req_builder.query(&[("created", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_execution_logging {
        req_builder = req_builder.query(&[("execution_logging", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_expression {
        req_builder = req_builder.query(&[("expression", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_last_updated {
        req_builder = req_builder.query(&[("last_updated", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ordering {
        req_builder = req_builder.query(&[("ordering", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page_size {
        req_builder = req_builder.query(&[("page_size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_policy_uuid {
        req_builder = req_builder.query(&[("policy_uuid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_search {
        req_builder = req_builder.query(&[("search", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginatedExpressionPolicyList`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginatedExpressionPolicyList`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PoliciesExpressionListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Source Viewset
pub async fn policies_expression_partial_update(
    configuration: &configuration::Configuration,
    policy_uuid: &str,
    patched_expression_policy_request: Option<models::PatchedExpressionPolicyRequest>,
) -> Result<models::ExpressionPolicy, Error<PoliciesExpressionPartialUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_policy_uuid = policy_uuid;
    let p_body_patched_expression_policy_request = patched_expression_policy_request;

    let uri_str = format!(
        "{}/policies/expression/{policy_uuid}/",
        configuration.base_path,
        policy_uuid = crate::apis::urlencode(p_path_policy_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_patched_expression_policy_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ExpressionPolicy`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ExpressionPolicy`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PoliciesExpressionPartialUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Source Viewset
pub async fn policies_expression_retrieve(
    configuration: &configuration::Configuration,
    policy_uuid: &str,
) -> Result<models::ExpressionPolicy, Error<PoliciesExpressionRetrieveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_policy_uuid = policy_uuid;

    let uri_str = format!(
        "{}/policies/expression/{policy_uuid}/",
        configuration.base_path,
        policy_uuid = crate::apis::urlencode(p_path_policy_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ExpressionPolicy`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ExpressionPolicy`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PoliciesExpressionRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Source Viewset
pub async fn policies_expression_update(
    configuration: &configuration::Configuration,
    policy_uuid: &str,
    expression_policy_request: models::ExpressionPolicyRequest,
) -> Result<models::ExpressionPolicy, Error<PoliciesExpressionUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_policy_uuid = policy_uuid;
    let p_body_expression_policy_request = expression_policy_request;

    let uri_str = format!(
        "{}/policies/expression/{policy_uuid}/",
        configuration.base_path,
        policy_uuid = crate::apis::urlencode(p_path_policy_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_expression_policy_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ExpressionPolicy`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ExpressionPolicy`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PoliciesExpressionUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get a list of all objects that use this object
pub async fn policies_expression_used_by_list(
    configuration: &configuration::Configuration,
    policy_uuid: &str,
) -> Result<Vec<models::UsedBy>, Error<PoliciesExpressionUsedByListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_policy_uuid = policy_uuid;

    let uri_str = format!(
        "{}/policies/expression/{policy_uuid}/used_by/",
        configuration.base_path,
        policy_uuid = crate::apis::urlencode(p_path_policy_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PoliciesExpressionUsedByListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// GeoIP Viewset
pub async fn policies_geoip_create(
    configuration: &configuration::Configuration,
    geo_ip_policy_request: models::GeoIpPolicyRequest,
) -> Result<models::GeoIpPolicy, Error<PoliciesGeoipCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_geo_ip_policy_request = geo_ip_policy_request;

    let uri_str = format!("{}/policies/geoip/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_geo_ip_policy_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::GeoIpPolicy`",
                )))
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::GeoIpPolicy`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PoliciesGeoipCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// GeoIP Viewset
pub async fn policies_geoip_destroy(
    configuration: &configuration::Configuration,
    policy_uuid: &str,
) -> Result<(), Error<PoliciesGeoipDestroyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_policy_uuid = policy_uuid;

    let uri_str = format!(
        "{}/policies/geoip/{policy_uuid}/",
        configuration.base_path,
        policy_uuid = crate::apis::urlencode(p_path_policy_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<PoliciesGeoipDestroyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get all countries in ISO-3166-1
pub async fn policies_geoip_iso3166_list(
    configuration: &configuration::Configuration,
) -> Result<Vec<models::DetailedCountry>, Error<PoliciesGeoipIso3166ListError>> {
    let uri_str = format!("{}/policies/geoip_iso3166/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::DetailedCountry&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::DetailedCountry&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PoliciesGeoipIso3166ListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// GeoIP Viewset
pub async fn policies_geoip_list(
    configuration: &configuration::Configuration,
    name: Option<&str>,
    ordering: Option<&str>,
    page: Option<i32>,
    page_size: Option<i32>,
    search: Option<&str>,
) -> Result<models::PaginatedGeoIpPolicyList, Error<PoliciesGeoipListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_name = name;
    let p_query_ordering = ordering;
    let p_query_page = page;
    let p_query_page_size = page_size;
    let p_query_search = search;

    let uri_str = format!("{}/policies/geoip/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ordering {
        req_builder = req_builder.query(&[("ordering", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page_size {
        req_builder = req_builder.query(&[("page_size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_search {
        req_builder = req_builder.query(&[("search", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginatedGeoIpPolicyList`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginatedGeoIpPolicyList`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PoliciesGeoipListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// GeoIP Viewset
pub async fn policies_geoip_partial_update(
    configuration: &configuration::Configuration,
    policy_uuid: &str,
    patched_geo_ip_policy_request: Option<models::PatchedGeoIpPolicyRequest>,
) -> Result<models::GeoIpPolicy, Error<PoliciesGeoipPartialUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_policy_uuid = policy_uuid;
    let p_body_patched_geo_ip_policy_request = patched_geo_ip_policy_request;

    let uri_str = format!(
        "{}/policies/geoip/{policy_uuid}/",
        configuration.base_path,
        policy_uuid = crate::apis::urlencode(p_path_policy_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_patched_geo_ip_policy_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::GeoIpPolicy`",
                )))
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::GeoIpPolicy`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PoliciesGeoipPartialUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// GeoIP Viewset
pub async fn policies_geoip_retrieve(
    configuration: &configuration::Configuration,
    policy_uuid: &str,
) -> Result<models::GeoIpPolicy, Error<PoliciesGeoipRetrieveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_policy_uuid = policy_uuid;

    let uri_str = format!(
        "{}/policies/geoip/{policy_uuid}/",
        configuration.base_path,
        policy_uuid = crate::apis::urlencode(p_path_policy_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::GeoIpPolicy`",
                )))
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::GeoIpPolicy`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PoliciesGeoipRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// GeoIP Viewset
pub async fn policies_geoip_update(
    configuration: &configuration::Configuration,
    policy_uuid: &str,
    geo_ip_policy_request: models::GeoIpPolicyRequest,
) -> Result<models::GeoIpPolicy, Error<PoliciesGeoipUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_policy_uuid = policy_uuid;
    let p_body_geo_ip_policy_request = geo_ip_policy_request;

    let uri_str = format!(
        "{}/policies/geoip/{policy_uuid}/",
        configuration.base_path,
        policy_uuid = crate::apis::urlencode(p_path_policy_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_geo_ip_policy_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::GeoIpPolicy`",
                )))
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::GeoIpPolicy`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PoliciesGeoipUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get a list of all objects that use this object
pub async fn policies_geoip_used_by_list(
    configuration: &configuration::Configuration,
    policy_uuid: &str,
) -> Result<Vec<models::UsedBy>, Error<PoliciesGeoipUsedByListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_policy_uuid = policy_uuid;

    let uri_str = format!(
        "{}/policies/geoip/{policy_uuid}/used_by/",
        configuration.base_path,
        policy_uuid = crate::apis::urlencode(p_path_policy_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PoliciesGeoipUsedByListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Password Policy Viewset
pub async fn policies_password_create(
    configuration: &configuration::Configuration,
    password_policy_request: models::PasswordPolicyRequest,
) -> Result<models::PasswordPolicy, Error<PoliciesPasswordCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_password_policy_request = password_policy_request;

    let uri_str = format!("{}/policies/password/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_password_policy_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::PasswordPolicy`",
                )))
            }
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!(
                "Received `{unknown_type}` content type response that cannot be converted to `models::PasswordPolicy`"
            )))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PoliciesPasswordCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Password Policy Viewset
pub async fn policies_password_destroy(
    configuration: &configuration::Configuration,
    policy_uuid: &str,
) -> Result<(), Error<PoliciesPasswordDestroyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_policy_uuid = policy_uuid;

    let uri_str = format!(
        "{}/policies/password/{policy_uuid}/",
        configuration.base_path,
        policy_uuid = crate::apis::urlencode(p_path_policy_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<PoliciesPasswordDestroyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Password Expiry Viewset
pub async fn policies_password_expiry_create(
    configuration: &configuration::Configuration,
    password_expiry_policy_request: models::PasswordExpiryPolicyRequest,
) -> Result<models::PasswordExpiryPolicy, Error<PoliciesPasswordExpiryCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_password_expiry_policy_request = password_expiry_policy_request;

    let uri_str = format!("{}/policies/password_expiry/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_password_expiry_policy_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PasswordExpiryPolicy`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PasswordExpiryPolicy`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PoliciesPasswordExpiryCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Password Expiry Viewset
pub async fn policies_password_expiry_destroy(
    configuration: &configuration::Configuration,
    policy_uuid: &str,
) -> Result<(), Error<PoliciesPasswordExpiryDestroyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_policy_uuid = policy_uuid;

    let uri_str = format!(
        "{}/policies/password_expiry/{policy_uuid}/",
        configuration.base_path,
        policy_uuid = crate::apis::urlencode(p_path_policy_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<PoliciesPasswordExpiryDestroyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Password Expiry Viewset
pub async fn policies_password_expiry_list(
    configuration: &configuration::Configuration,
    created: Option<String>,
    days: Option<i32>,
    deny_only: Option<bool>,
    execution_logging: Option<bool>,
    last_updated: Option<String>,
    name: Option<&str>,
    ordering: Option<&str>,
    page: Option<i32>,
    page_size: Option<i32>,
    policy_uuid: Option<&str>,
    search: Option<&str>,
) -> Result<models::PaginatedPasswordExpiryPolicyList, Error<PoliciesPasswordExpiryListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_created = created;
    let p_query_days = days;
    let p_query_deny_only = deny_only;
    let p_query_execution_logging = execution_logging;
    let p_query_last_updated = last_updated;
    let p_query_name = name;
    let p_query_ordering = ordering;
    let p_query_page = page;
    let p_query_page_size = page_size;
    let p_query_policy_uuid = policy_uuid;
    let p_query_search = search;

    let uri_str = format!("{}/policies/password_expiry/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_created {
        req_builder = req_builder.query(&[("created", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_days {
        req_builder = req_builder.query(&[("days", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_deny_only {
        req_builder = req_builder.query(&[("deny_only", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_execution_logging {
        req_builder = req_builder.query(&[("execution_logging", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_last_updated {
        req_builder = req_builder.query(&[("last_updated", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ordering {
        req_builder = req_builder.query(&[("ordering", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page_size {
        req_builder = req_builder.query(&[("page_size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_policy_uuid {
        req_builder = req_builder.query(&[("policy_uuid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_search {
        req_builder = req_builder.query(&[("search", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginatedPasswordExpiryPolicyList`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginatedPasswordExpiryPolicyList`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PoliciesPasswordExpiryListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Password Expiry Viewset
pub async fn policies_password_expiry_partial_update(
    configuration: &configuration::Configuration,
    policy_uuid: &str,
    patched_password_expiry_policy_request: Option<models::PatchedPasswordExpiryPolicyRequest>,
) -> Result<models::PasswordExpiryPolicy, Error<PoliciesPasswordExpiryPartialUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_policy_uuid = policy_uuid;
    let p_body_patched_password_expiry_policy_request = patched_password_expiry_policy_request;

    let uri_str = format!(
        "{}/policies/password_expiry/{policy_uuid}/",
        configuration.base_path,
        policy_uuid = crate::apis::urlencode(p_path_policy_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_patched_password_expiry_policy_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PasswordExpiryPolicy`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PasswordExpiryPolicy`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PoliciesPasswordExpiryPartialUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Password Expiry Viewset
pub async fn policies_password_expiry_retrieve(
    configuration: &configuration::Configuration,
    policy_uuid: &str,
) -> Result<models::PasswordExpiryPolicy, Error<PoliciesPasswordExpiryRetrieveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_policy_uuid = policy_uuid;

    let uri_str = format!(
        "{}/policies/password_expiry/{policy_uuid}/",
        configuration.base_path,
        policy_uuid = crate::apis::urlencode(p_path_policy_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PasswordExpiryPolicy`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PasswordExpiryPolicy`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PoliciesPasswordExpiryRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Password Expiry Viewset
pub async fn policies_password_expiry_update(
    configuration: &configuration::Configuration,
    policy_uuid: &str,
    password_expiry_policy_request: models::PasswordExpiryPolicyRequest,
) -> Result<models::PasswordExpiryPolicy, Error<PoliciesPasswordExpiryUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_policy_uuid = policy_uuid;
    let p_body_password_expiry_policy_request = password_expiry_policy_request;

    let uri_str = format!(
        "{}/policies/password_expiry/{policy_uuid}/",
        configuration.base_path,
        policy_uuid = crate::apis::urlencode(p_path_policy_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_password_expiry_policy_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PasswordExpiryPolicy`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PasswordExpiryPolicy`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PoliciesPasswordExpiryUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get a list of all objects that use this object
pub async fn policies_password_expiry_used_by_list(
    configuration: &configuration::Configuration,
    policy_uuid: &str,
) -> Result<Vec<models::UsedBy>, Error<PoliciesPasswordExpiryUsedByListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_policy_uuid = policy_uuid;

    let uri_str = format!(
        "{}/policies/password_expiry/{policy_uuid}/used_by/",
        configuration.base_path,
        policy_uuid = crate::apis::urlencode(p_path_policy_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PoliciesPasswordExpiryUsedByListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Password Policy Viewset
pub async fn policies_password_list(
    configuration: &configuration::Configuration,
    amount_digits: Option<i32>,
    amount_lowercase: Option<i32>,
    amount_symbols: Option<i32>,
    amount_uppercase: Option<i32>,
    check_have_i_been_pwned: Option<bool>,
    check_static_rules: Option<bool>,
    check_zxcvbn: Option<bool>,
    created: Option<String>,
    error_message: Option<&str>,
    execution_logging: Option<bool>,
    hibp_allowed_count: Option<i32>,
    last_updated: Option<String>,
    length_min: Option<i32>,
    name: Option<&str>,
    ordering: Option<&str>,
    page: Option<i32>,
    page_size: Option<i32>,
    password_field: Option<&str>,
    policy_uuid: Option<&str>,
    search: Option<&str>,
    symbol_charset: Option<&str>,
    zxcvbn_score_threshold: Option<i32>,
) -> Result<models::PaginatedPasswordPolicyList, Error<PoliciesPasswordListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_amount_digits = amount_digits;
    let p_query_amount_lowercase = amount_lowercase;
    let p_query_amount_symbols = amount_symbols;
    let p_query_amount_uppercase = amount_uppercase;
    let p_query_check_have_i_been_pwned = check_have_i_been_pwned;
    let p_query_check_static_rules = check_static_rules;
    let p_query_check_zxcvbn = check_zxcvbn;
    let p_query_created = created;
    let p_query_error_message = error_message;
    let p_query_execution_logging = execution_logging;
    let p_query_hibp_allowed_count = hibp_allowed_count;
    let p_query_last_updated = last_updated;
    let p_query_length_min = length_min;
    let p_query_name = name;
    let p_query_ordering = ordering;
    let p_query_page = page;
    let p_query_page_size = page_size;
    let p_query_password_field = password_field;
    let p_query_policy_uuid = policy_uuid;
    let p_query_search = search;
    let p_query_symbol_charset = symbol_charset;
    let p_query_zxcvbn_score_threshold = zxcvbn_score_threshold;

    let uri_str = format!("{}/policies/password/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_amount_digits {
        req_builder = req_builder.query(&[("amount_digits", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_amount_lowercase {
        req_builder = req_builder.query(&[("amount_lowercase", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_amount_symbols {
        req_builder = req_builder.query(&[("amount_symbols", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_amount_uppercase {
        req_builder = req_builder.query(&[("amount_uppercase", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_check_have_i_been_pwned {
        req_builder = req_builder.query(&[("check_have_i_been_pwned", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_check_static_rules {
        req_builder = req_builder.query(&[("check_static_rules", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_check_zxcvbn {
        req_builder = req_builder.query(&[("check_zxcvbn", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_created {
        req_builder = req_builder.query(&[("created", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_error_message {
        req_builder = req_builder.query(&[("error_message", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_execution_logging {
        req_builder = req_builder.query(&[("execution_logging", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_hibp_allowed_count {
        req_builder = req_builder.query(&[("hibp_allowed_count", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_last_updated {
        req_builder = req_builder.query(&[("last_updated", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_length_min {
        req_builder = req_builder.query(&[("length_min", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ordering {
        req_builder = req_builder.query(&[("ordering", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page_size {
        req_builder = req_builder.query(&[("page_size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_password_field {
        req_builder = req_builder.query(&[("password_field", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_policy_uuid {
        req_builder = req_builder.query(&[("policy_uuid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_search {
        req_builder = req_builder.query(&[("search", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_symbol_charset {
        req_builder = req_builder.query(&[("symbol_charset", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_zxcvbn_score_threshold {
        req_builder = req_builder.query(&[("zxcvbn_score_threshold", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginatedPasswordPolicyList`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginatedPasswordPolicyList`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PoliciesPasswordListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Password Policy Viewset
pub async fn policies_password_partial_update(
    configuration: &configuration::Configuration,
    policy_uuid: &str,
    patched_password_policy_request: Option<models::PatchedPasswordPolicyRequest>,
) -> Result<models::PasswordPolicy, Error<PoliciesPasswordPartialUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_policy_uuid = policy_uuid;
    let p_body_patched_password_policy_request = patched_password_policy_request;

    let uri_str = format!(
        "{}/policies/password/{policy_uuid}/",
        configuration.base_path,
        policy_uuid = crate::apis::urlencode(p_path_policy_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_patched_password_policy_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::PasswordPolicy`",
                )))
            }
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!(
                "Received `{unknown_type}` content type response that cannot be converted to `models::PasswordPolicy`"
            )))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PoliciesPasswordPartialUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Password Policy Viewset
pub async fn policies_password_retrieve(
    configuration: &configuration::Configuration,
    policy_uuid: &str,
) -> Result<models::PasswordPolicy, Error<PoliciesPasswordRetrieveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_policy_uuid = policy_uuid;

    let uri_str = format!(
        "{}/policies/password/{policy_uuid}/",
        configuration.base_path,
        policy_uuid = crate::apis::urlencode(p_path_policy_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::PasswordPolicy`",
                )))
            }
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!(
                "Received `{unknown_type}` content type response that cannot be converted to `models::PasswordPolicy`"
            )))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PoliciesPasswordRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Password Policy Viewset
pub async fn policies_password_update(
    configuration: &configuration::Configuration,
    policy_uuid: &str,
    password_policy_request: models::PasswordPolicyRequest,
) -> Result<models::PasswordPolicy, Error<PoliciesPasswordUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_policy_uuid = policy_uuid;
    let p_body_password_policy_request = password_policy_request;

    let uri_str = format!(
        "{}/policies/password/{policy_uuid}/",
        configuration.base_path,
        policy_uuid = crate::apis::urlencode(p_path_policy_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_password_policy_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::PasswordPolicy`",
                )))
            }
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!(
                "Received `{unknown_type}` content type response that cannot be converted to `models::PasswordPolicy`"
            )))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PoliciesPasswordUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get a list of all objects that use this object
pub async fn policies_password_used_by_list(
    configuration: &configuration::Configuration,
    policy_uuid: &str,
) -> Result<Vec<models::UsedBy>, Error<PoliciesPasswordUsedByListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_policy_uuid = policy_uuid;

    let uri_str = format!(
        "{}/policies/password/{policy_uuid}/used_by/",
        configuration.base_path,
        policy_uuid = crate::apis::urlencode(p_path_policy_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PoliciesPasswordUsedByListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Reputation Policy Viewset
pub async fn policies_reputation_create(
    configuration: &configuration::Configuration,
    reputation_policy_request: models::ReputationPolicyRequest,
) -> Result<models::ReputationPolicy, Error<PoliciesReputationCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_reputation_policy_request = reputation_policy_request;

    let uri_str = format!("{}/policies/reputation/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_reputation_policy_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ReputationPolicy`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ReputationPolicy`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PoliciesReputationCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Reputation Policy Viewset
pub async fn policies_reputation_destroy(
    configuration: &configuration::Configuration,
    policy_uuid: &str,
) -> Result<(), Error<PoliciesReputationDestroyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_policy_uuid = policy_uuid;

    let uri_str = format!(
        "{}/policies/reputation/{policy_uuid}/",
        configuration.base_path,
        policy_uuid = crate::apis::urlencode(p_path_policy_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<PoliciesReputationDestroyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Reputation Policy Viewset
pub async fn policies_reputation_list(
    configuration: &configuration::Configuration,
    check_ip: Option<bool>,
    check_username: Option<bool>,
    created: Option<String>,
    execution_logging: Option<bool>,
    last_updated: Option<String>,
    name: Option<&str>,
    ordering: Option<&str>,
    page: Option<i32>,
    page_size: Option<i32>,
    policy_uuid: Option<&str>,
    search: Option<&str>,
    threshold: Option<i32>,
) -> Result<models::PaginatedReputationPolicyList, Error<PoliciesReputationListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_check_ip = check_ip;
    let p_query_check_username = check_username;
    let p_query_created = created;
    let p_query_execution_logging = execution_logging;
    let p_query_last_updated = last_updated;
    let p_query_name = name;
    let p_query_ordering = ordering;
    let p_query_page = page;
    let p_query_page_size = page_size;
    let p_query_policy_uuid = policy_uuid;
    let p_query_search = search;
    let p_query_threshold = threshold;

    let uri_str = format!("{}/policies/reputation/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_check_ip {
        req_builder = req_builder.query(&[("check_ip", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_check_username {
        req_builder = req_builder.query(&[("check_username", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_created {
        req_builder = req_builder.query(&[("created", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_execution_logging {
        req_builder = req_builder.query(&[("execution_logging", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_last_updated {
        req_builder = req_builder.query(&[("last_updated", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ordering {
        req_builder = req_builder.query(&[("ordering", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page_size {
        req_builder = req_builder.query(&[("page_size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_policy_uuid {
        req_builder = req_builder.query(&[("policy_uuid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_search {
        req_builder = req_builder.query(&[("search", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_threshold {
        req_builder = req_builder.query(&[("threshold", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginatedReputationPolicyList`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginatedReputationPolicyList`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PoliciesReputationListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Reputation Policy Viewset
pub async fn policies_reputation_partial_update(
    configuration: &configuration::Configuration,
    policy_uuid: &str,
    patched_reputation_policy_request: Option<models::PatchedReputationPolicyRequest>,
) -> Result<models::ReputationPolicy, Error<PoliciesReputationPartialUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_policy_uuid = policy_uuid;
    let p_body_patched_reputation_policy_request = patched_reputation_policy_request;

    let uri_str = format!(
        "{}/policies/reputation/{policy_uuid}/",
        configuration.base_path,
        policy_uuid = crate::apis::urlencode(p_path_policy_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_patched_reputation_policy_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ReputationPolicy`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ReputationPolicy`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PoliciesReputationPartialUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Reputation Policy Viewset
pub async fn policies_reputation_retrieve(
    configuration: &configuration::Configuration,
    policy_uuid: &str,
) -> Result<models::ReputationPolicy, Error<PoliciesReputationRetrieveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_policy_uuid = policy_uuid;

    let uri_str = format!(
        "{}/policies/reputation/{policy_uuid}/",
        configuration.base_path,
        policy_uuid = crate::apis::urlencode(p_path_policy_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ReputationPolicy`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ReputationPolicy`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PoliciesReputationRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Reputation Viewset
pub async fn policies_reputation_scores_destroy(
    configuration: &configuration::Configuration,
    reputation_uuid: &str,
) -> Result<(), Error<PoliciesReputationScoresDestroyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_reputation_uuid = reputation_uuid;

    let uri_str = format!(
        "{}/policies/reputation/scores/{reputation_uuid}/",
        configuration.base_path,
        reputation_uuid = crate::apis::urlencode(p_path_reputation_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<PoliciesReputationScoresDestroyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Reputation Viewset
pub async fn policies_reputation_scores_list(
    configuration: &configuration::Configuration,
    identifier: Option<&str>,
    identifier_in: Option<Vec<String>>,
    ip: Option<&str>,
    ordering: Option<&str>,
    page: Option<i32>,
    page_size: Option<i32>,
    score: Option<i32>,
    search: Option<&str>,
) -> Result<models::PaginatedReputationList, Error<PoliciesReputationScoresListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_identifier = identifier;
    let p_query_identifier_in = identifier_in;
    let p_query_ip = ip;
    let p_query_ordering = ordering;
    let p_query_page = page;
    let p_query_page_size = page_size;
    let p_query_score = score;
    let p_query_search = search;

    let uri_str = format!("{}/policies/reputation/scores/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_identifier {
        req_builder = req_builder.query(&[("identifier", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_identifier_in {
        req_builder = match "csv" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("identifier_in".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "identifier_in",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = p_query_ip {
        req_builder = req_builder.query(&[("ip", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ordering {
        req_builder = req_builder.query(&[("ordering", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page_size {
        req_builder = req_builder.query(&[("page_size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_score {
        req_builder = req_builder.query(&[("score", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_search {
        req_builder = req_builder.query(&[("search", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginatedReputationList`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginatedReputationList`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PoliciesReputationScoresListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Reputation Viewset
pub async fn policies_reputation_scores_retrieve(
    configuration: &configuration::Configuration,
    reputation_uuid: &str,
) -> Result<models::Reputation, Error<PoliciesReputationScoresRetrieveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_reputation_uuid = reputation_uuid;

    let uri_str = format!(
        "{}/policies/reputation/scores/{reputation_uuid}/",
        configuration.base_path,
        reputation_uuid = crate::apis::urlencode(p_path_reputation_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::Reputation`",
                )))
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::Reputation`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PoliciesReputationScoresRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get a list of all objects that use this object
pub async fn policies_reputation_scores_used_by_list(
    configuration: &configuration::Configuration,
    reputation_uuid: &str,
) -> Result<Vec<models::UsedBy>, Error<PoliciesReputationScoresUsedByListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_reputation_uuid = reputation_uuid;

    let uri_str = format!(
        "{}/policies/reputation/scores/{reputation_uuid}/used_by/",
        configuration.base_path,
        reputation_uuid = crate::apis::urlencode(p_path_reputation_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PoliciesReputationScoresUsedByListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Reputation Policy Viewset
pub async fn policies_reputation_update(
    configuration: &configuration::Configuration,
    policy_uuid: &str,
    reputation_policy_request: models::ReputationPolicyRequest,
) -> Result<models::ReputationPolicy, Error<PoliciesReputationUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_policy_uuid = policy_uuid;
    let p_body_reputation_policy_request = reputation_policy_request;

    let uri_str = format!(
        "{}/policies/reputation/{policy_uuid}/",
        configuration.base_path,
        policy_uuid = crate::apis::urlencode(p_path_policy_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_reputation_policy_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ReputationPolicy`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ReputationPolicy`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PoliciesReputationUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get a list of all objects that use this object
pub async fn policies_reputation_used_by_list(
    configuration: &configuration::Configuration,
    policy_uuid: &str,
) -> Result<Vec<models::UsedBy>, Error<PoliciesReputationUsedByListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_policy_uuid = policy_uuid;

    let uri_str = format!(
        "{}/policies/reputation/{policy_uuid}/used_by/",
        configuration.base_path,
        policy_uuid = crate::apis::urlencode(p_path_policy_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PoliciesReputationUsedByListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Password Uniqueness Policy Viewset
pub async fn policies_unique_password_create(
    configuration: &configuration::Configuration,
    unique_password_policy_request: models::UniquePasswordPolicyRequest,
) -> Result<models::UniquePasswordPolicy, Error<PoliciesUniquePasswordCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_unique_password_policy_request = unique_password_policy_request;

    let uri_str = format!("{}/policies/unique_password/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_unique_password_policy_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UniquePasswordPolicy`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UniquePasswordPolicy`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PoliciesUniquePasswordCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Password Uniqueness Policy Viewset
pub async fn policies_unique_password_destroy(
    configuration: &configuration::Configuration,
    policy_uuid: &str,
) -> Result<(), Error<PoliciesUniquePasswordDestroyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_policy_uuid = policy_uuid;

    let uri_str = format!(
        "{}/policies/unique_password/{policy_uuid}/",
        configuration.base_path,
        policy_uuid = crate::apis::urlencode(p_path_policy_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<PoliciesUniquePasswordDestroyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Password Uniqueness Policy Viewset
pub async fn policies_unique_password_list(
    configuration: &configuration::Configuration,
    created: Option<String>,
    execution_logging: Option<bool>,
    last_updated: Option<String>,
    name: Option<&str>,
    num_historical_passwords: Option<i32>,
    ordering: Option<&str>,
    page: Option<i32>,
    page_size: Option<i32>,
    password_field: Option<&str>,
    policy_uuid: Option<&str>,
    search: Option<&str>,
) -> Result<models::PaginatedUniquePasswordPolicyList, Error<PoliciesUniquePasswordListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_created = created;
    let p_query_execution_logging = execution_logging;
    let p_query_last_updated = last_updated;
    let p_query_name = name;
    let p_query_num_historical_passwords = num_historical_passwords;
    let p_query_ordering = ordering;
    let p_query_page = page;
    let p_query_page_size = page_size;
    let p_query_password_field = password_field;
    let p_query_policy_uuid = policy_uuid;
    let p_query_search = search;

    let uri_str = format!("{}/policies/unique_password/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_created {
        req_builder = req_builder.query(&[("created", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_execution_logging {
        req_builder = req_builder.query(&[("execution_logging", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_last_updated {
        req_builder = req_builder.query(&[("last_updated", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_num_historical_passwords {
        req_builder = req_builder.query(&[("num_historical_passwords", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ordering {
        req_builder = req_builder.query(&[("ordering", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page_size {
        req_builder = req_builder.query(&[("page_size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_password_field {
        req_builder = req_builder.query(&[("password_field", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_policy_uuid {
        req_builder = req_builder.query(&[("policy_uuid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_search {
        req_builder = req_builder.query(&[("search", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginatedUniquePasswordPolicyList`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginatedUniquePasswordPolicyList`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PoliciesUniquePasswordListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Password Uniqueness Policy Viewset
pub async fn policies_unique_password_partial_update(
    configuration: &configuration::Configuration,
    policy_uuid: &str,
    patched_unique_password_policy_request: Option<models::PatchedUniquePasswordPolicyRequest>,
) -> Result<models::UniquePasswordPolicy, Error<PoliciesUniquePasswordPartialUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_policy_uuid = policy_uuid;
    let p_body_patched_unique_password_policy_request = patched_unique_password_policy_request;

    let uri_str = format!(
        "{}/policies/unique_password/{policy_uuid}/",
        configuration.base_path,
        policy_uuid = crate::apis::urlencode(p_path_policy_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_patched_unique_password_policy_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UniquePasswordPolicy`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UniquePasswordPolicy`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PoliciesUniquePasswordPartialUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Password Uniqueness Policy Viewset
pub async fn policies_unique_password_retrieve(
    configuration: &configuration::Configuration,
    policy_uuid: &str,
) -> Result<models::UniquePasswordPolicy, Error<PoliciesUniquePasswordRetrieveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_policy_uuid = policy_uuid;

    let uri_str = format!(
        "{}/policies/unique_password/{policy_uuid}/",
        configuration.base_path,
        policy_uuid = crate::apis::urlencode(p_path_policy_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UniquePasswordPolicy`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UniquePasswordPolicy`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PoliciesUniquePasswordRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Password Uniqueness Policy Viewset
pub async fn policies_unique_password_update(
    configuration: &configuration::Configuration,
    policy_uuid: &str,
    unique_password_policy_request: models::UniquePasswordPolicyRequest,
) -> Result<models::UniquePasswordPolicy, Error<PoliciesUniquePasswordUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_policy_uuid = policy_uuid;
    let p_body_unique_password_policy_request = unique_password_policy_request;

    let uri_str = format!(
        "{}/policies/unique_password/{policy_uuid}/",
        configuration.base_path,
        policy_uuid = crate::apis::urlencode(p_path_policy_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_unique_password_policy_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UniquePasswordPolicy`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UniquePasswordPolicy`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PoliciesUniquePasswordUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get a list of all objects that use this object
pub async fn policies_unique_password_used_by_list(
    configuration: &configuration::Configuration,
    policy_uuid: &str,
) -> Result<Vec<models::UsedBy>, Error<PoliciesUniquePasswordUsedByListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_policy_uuid = policy_uuid;

    let uri_str = format!(
        "{}/policies/unique_password/{policy_uuid}/used_by/",
        configuration.base_path,
        policy_uuid = crate::apis::urlencode(p_path_policy_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PoliciesUniquePasswordUsedByListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
