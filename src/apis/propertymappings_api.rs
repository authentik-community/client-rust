/*
 * authentik
 *
 * Making authentication simple.
 *
 * The version of the OpenAPI document: 2025.6.4
 * Contact: hello@goauthentik.io
 * Generated by: https://openapi-generator.tech
 */

use super::{configuration, ContentType, Error};
use crate::{apis::ResponseContent, models};
use reqwest;
use serde::{de::Error as _, Deserialize, Serialize};

/// struct for typed errors of method [`propertymappings_all_destroy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsAllDestroyError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`propertymappings_all_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsAllListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`propertymappings_all_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsAllRetrieveError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`propertymappings_all_test_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsAllTestCreateError {
    Status400(),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`propertymappings_all_types_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsAllTypesListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`propertymappings_all_used_by_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsAllUsedByListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`propertymappings_notification_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsNotificationCreateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`propertymappings_notification_destroy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsNotificationDestroyError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`propertymappings_notification_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsNotificationListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`propertymappings_notification_partial_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsNotificationPartialUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`propertymappings_notification_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsNotificationRetrieveError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`propertymappings_notification_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsNotificationUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`propertymappings_notification_used_by_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsNotificationUsedByListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`propertymappings_provider_google_workspace_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsProviderGoogleWorkspaceCreateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`propertymappings_provider_google_workspace_destroy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsProviderGoogleWorkspaceDestroyError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`propertymappings_provider_google_workspace_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsProviderGoogleWorkspaceListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`propertymappings_provider_google_workspace_partial_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsProviderGoogleWorkspacePartialUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`propertymappings_provider_google_workspace_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsProviderGoogleWorkspaceRetrieveError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`propertymappings_provider_google_workspace_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsProviderGoogleWorkspaceUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`propertymappings_provider_google_workspace_used_by_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsProviderGoogleWorkspaceUsedByListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`propertymappings_provider_microsoft_entra_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsProviderMicrosoftEntraCreateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`propertymappings_provider_microsoft_entra_destroy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsProviderMicrosoftEntraDestroyError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`propertymappings_provider_microsoft_entra_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsProviderMicrosoftEntraListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`propertymappings_provider_microsoft_entra_partial_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsProviderMicrosoftEntraPartialUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`propertymappings_provider_microsoft_entra_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsProviderMicrosoftEntraRetrieveError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`propertymappings_provider_microsoft_entra_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsProviderMicrosoftEntraUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`propertymappings_provider_microsoft_entra_used_by_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsProviderMicrosoftEntraUsedByListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`propertymappings_provider_rac_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsProviderRacCreateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`propertymappings_provider_rac_destroy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsProviderRacDestroyError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`propertymappings_provider_rac_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsProviderRacListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`propertymappings_provider_rac_partial_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsProviderRacPartialUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`propertymappings_provider_rac_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsProviderRacRetrieveError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`propertymappings_provider_rac_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsProviderRacUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`propertymappings_provider_rac_used_by_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsProviderRacUsedByListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`propertymappings_provider_radius_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsProviderRadiusCreateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`propertymappings_provider_radius_destroy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsProviderRadiusDestroyError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`propertymappings_provider_radius_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsProviderRadiusListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`propertymappings_provider_radius_partial_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsProviderRadiusPartialUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`propertymappings_provider_radius_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsProviderRadiusRetrieveError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`propertymappings_provider_radius_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsProviderRadiusUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`propertymappings_provider_radius_used_by_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsProviderRadiusUsedByListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`propertymappings_provider_saml_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsProviderSamlCreateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`propertymappings_provider_saml_destroy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsProviderSamlDestroyError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`propertymappings_provider_saml_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsProviderSamlListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`propertymappings_provider_saml_partial_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsProviderSamlPartialUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`propertymappings_provider_saml_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsProviderSamlRetrieveError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`propertymappings_provider_saml_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsProviderSamlUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`propertymappings_provider_saml_used_by_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsProviderSamlUsedByListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`propertymappings_provider_scim_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsProviderScimCreateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`propertymappings_provider_scim_destroy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsProviderScimDestroyError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`propertymappings_provider_scim_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsProviderScimListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`propertymappings_provider_scim_partial_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsProviderScimPartialUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`propertymappings_provider_scim_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsProviderScimRetrieveError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`propertymappings_provider_scim_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsProviderScimUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`propertymappings_provider_scim_used_by_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsProviderScimUsedByListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`propertymappings_provider_scope_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsProviderScopeCreateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`propertymappings_provider_scope_destroy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsProviderScopeDestroyError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`propertymappings_provider_scope_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsProviderScopeListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`propertymappings_provider_scope_partial_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsProviderScopePartialUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`propertymappings_provider_scope_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsProviderScopeRetrieveError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`propertymappings_provider_scope_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsProviderScopeUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`propertymappings_provider_scope_used_by_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsProviderScopeUsedByListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`propertymappings_source_kerberos_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsSourceKerberosCreateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`propertymappings_source_kerberos_destroy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsSourceKerberosDestroyError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`propertymappings_source_kerberos_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsSourceKerberosListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`propertymappings_source_kerberos_partial_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsSourceKerberosPartialUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`propertymappings_source_kerberos_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsSourceKerberosRetrieveError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`propertymappings_source_kerberos_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsSourceKerberosUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`propertymappings_source_kerberos_used_by_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsSourceKerberosUsedByListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`propertymappings_source_ldap_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsSourceLdapCreateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`propertymappings_source_ldap_destroy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsSourceLdapDestroyError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`propertymappings_source_ldap_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsSourceLdapListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`propertymappings_source_ldap_partial_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsSourceLdapPartialUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`propertymappings_source_ldap_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsSourceLdapRetrieveError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`propertymappings_source_ldap_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsSourceLdapUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`propertymappings_source_ldap_used_by_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsSourceLdapUsedByListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`propertymappings_source_oauth_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsSourceOauthCreateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`propertymappings_source_oauth_destroy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsSourceOauthDestroyError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`propertymappings_source_oauth_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsSourceOauthListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`propertymappings_source_oauth_partial_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsSourceOauthPartialUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`propertymappings_source_oauth_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsSourceOauthRetrieveError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`propertymappings_source_oauth_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsSourceOauthUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`propertymappings_source_oauth_used_by_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsSourceOauthUsedByListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`propertymappings_source_plex_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsSourcePlexCreateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`propertymappings_source_plex_destroy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsSourcePlexDestroyError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`propertymappings_source_plex_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsSourcePlexListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`propertymappings_source_plex_partial_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsSourcePlexPartialUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`propertymappings_source_plex_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsSourcePlexRetrieveError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`propertymappings_source_plex_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsSourcePlexUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`propertymappings_source_plex_used_by_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsSourcePlexUsedByListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`propertymappings_source_saml_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsSourceSamlCreateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`propertymappings_source_saml_destroy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsSourceSamlDestroyError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`propertymappings_source_saml_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsSourceSamlListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`propertymappings_source_saml_partial_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsSourceSamlPartialUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`propertymappings_source_saml_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsSourceSamlRetrieveError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`propertymappings_source_saml_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsSourceSamlUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`propertymappings_source_saml_used_by_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsSourceSamlUsedByListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`propertymappings_source_scim_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsSourceScimCreateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`propertymappings_source_scim_destroy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsSourceScimDestroyError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`propertymappings_source_scim_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsSourceScimListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`propertymappings_source_scim_partial_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsSourceScimPartialUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`propertymappings_source_scim_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsSourceScimRetrieveError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`propertymappings_source_scim_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsSourceScimUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`propertymappings_source_scim_used_by_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PropertymappingsSourceScimUsedByListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// PropertyMapping Viewset
pub async fn propertymappings_all_destroy(
    configuration: &configuration::Configuration,
    pm_uuid: &str,
) -> Result<(), Error<PropertymappingsAllDestroyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_pm_uuid = pm_uuid;

    let uri_str = format!(
        "{}/propertymappings/all/{pm_uuid}/",
        configuration.base_path,
        pm_uuid = crate::apis::urlencode(p_pm_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsAllDestroyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// PropertyMapping Viewset
pub async fn propertymappings_all_list(
    configuration: &configuration::Configuration,
    managed: Option<Vec<String>>,
    managed__isnull: Option<bool>,
    name: Option<&str>,
    ordering: Option<&str>,
    page: Option<i32>,
    page_size: Option<i32>,
    search: Option<&str>,
) -> Result<models::PaginatedPropertyMappingList, Error<PropertymappingsAllListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_managed = managed;
    let p_managed__isnull = managed__isnull;
    let p_name = name;
    let p_ordering = ordering;
    let p_page = page;
    let p_page_size = page_size;
    let p_search = search;

    let uri_str = format!("{}/propertymappings/all/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_managed {
        req_builder = match "multi" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("managed".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "managed",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = p_managed__isnull {
        req_builder = req_builder.query(&[("managed__isnull", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_ordering {
        req_builder = req_builder.query(&[("ordering", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page_size {
        req_builder = req_builder.query(&[("page_size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_search {
        req_builder = req_builder.query(&[("search", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginatedPropertyMappingList`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginatedPropertyMappingList`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsAllListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// PropertyMapping Viewset
pub async fn propertymappings_all_retrieve(
    configuration: &configuration::Configuration,
    pm_uuid: &str,
) -> Result<models::PropertyMapping, Error<PropertymappingsAllRetrieveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_pm_uuid = pm_uuid;

    let uri_str = format!(
        "{}/propertymappings/all/{pm_uuid}/",
        configuration.base_path,
        pm_uuid = crate::apis::urlencode(p_pm_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::PropertyMapping`",
                )))
            }
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!(
                "Received `{unknown_type}` content type response that cannot be converted to `models::PropertyMapping`"
            )))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsAllRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Test Property Mapping
pub async fn propertymappings_all_test_create(
    configuration: &configuration::Configuration,
    pm_uuid: &str,
    format_result: Option<bool>,
    property_mapping_test_request: Option<models::PropertyMappingTestRequest>,
) -> Result<models::PropertyMappingTestResult, Error<PropertymappingsAllTestCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_pm_uuid = pm_uuid;
    let p_format_result = format_result;
    let p_property_mapping_test_request = property_mapping_test_request;

    let uri_str = format!(
        "{}/propertymappings/all/{pm_uuid}/test/",
        configuration.base_path,
        pm_uuid = crate::apis::urlencode(p_pm_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_format_result {
        req_builder = req_builder.query(&[("format_result", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_property_mapping_test_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PropertyMappingTestResult`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PropertyMappingTestResult`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsAllTestCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get all creatable types
pub async fn propertymappings_all_types_list(
    configuration: &configuration::Configuration,
) -> Result<Vec<models::TypeCreate>, Error<PropertymappingsAllTypesListError>> {
    let uri_str = format!("{}/propertymappings/all/types/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::TypeCreate&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::TypeCreate&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsAllTypesListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get a list of all objects that use this object
pub async fn propertymappings_all_used_by_list(
    configuration: &configuration::Configuration,
    pm_uuid: &str,
) -> Result<Vec<models::UsedBy>, Error<PropertymappingsAllUsedByListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_pm_uuid = pm_uuid;

    let uri_str = format!(
        "{}/propertymappings/all/{pm_uuid}/used_by/",
        configuration.base_path,
        pm_uuid = crate::apis::urlencode(p_pm_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsAllUsedByListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// NotificationWebhookMapping Viewset
pub async fn propertymappings_notification_create(
    configuration: &configuration::Configuration,
    notification_webhook_mapping_request: models::NotificationWebhookMappingRequest,
) -> Result<models::NotificationWebhookMapping, Error<PropertymappingsNotificationCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_notification_webhook_mapping_request = notification_webhook_mapping_request;

    let uri_str = format!("{}/propertymappings/notification/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_notification_webhook_mapping_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::NotificationWebhookMapping`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::NotificationWebhookMapping`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsNotificationCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// NotificationWebhookMapping Viewset
pub async fn propertymappings_notification_destroy(
    configuration: &configuration::Configuration,
    pm_uuid: &str,
) -> Result<(), Error<PropertymappingsNotificationDestroyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_pm_uuid = pm_uuid;

    let uri_str = format!(
        "{}/propertymappings/notification/{pm_uuid}/",
        configuration.base_path,
        pm_uuid = crate::apis::urlencode(p_pm_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsNotificationDestroyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// NotificationWebhookMapping Viewset
pub async fn propertymappings_notification_list(
    configuration: &configuration::Configuration,
    name: Option<&str>,
    ordering: Option<&str>,
    page: Option<i32>,
    page_size: Option<i32>,
    search: Option<&str>,
) -> Result<models::PaginatedNotificationWebhookMappingList, Error<PropertymappingsNotificationListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_name = name;
    let p_ordering = ordering;
    let p_page = page;
    let p_page_size = page_size;
    let p_search = search;

    let uri_str = format!("{}/propertymappings/notification/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_ordering {
        req_builder = req_builder.query(&[("ordering", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page_size {
        req_builder = req_builder.query(&[("page_size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_search {
        req_builder = req_builder.query(&[("search", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginatedNotificationWebhookMappingList`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginatedNotificationWebhookMappingList`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsNotificationListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// NotificationWebhookMapping Viewset
pub async fn propertymappings_notification_partial_update(
    configuration: &configuration::Configuration,
    pm_uuid: &str,
    patched_notification_webhook_mapping_request: Option<models::PatchedNotificationWebhookMappingRequest>,
) -> Result<models::NotificationWebhookMapping, Error<PropertymappingsNotificationPartialUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_pm_uuid = pm_uuid;
    let p_patched_notification_webhook_mapping_request = patched_notification_webhook_mapping_request;

    let uri_str = format!(
        "{}/propertymappings/notification/{pm_uuid}/",
        configuration.base_path,
        pm_uuid = crate::apis::urlencode(p_pm_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_patched_notification_webhook_mapping_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::NotificationWebhookMapping`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::NotificationWebhookMapping`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsNotificationPartialUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// NotificationWebhookMapping Viewset
pub async fn propertymappings_notification_retrieve(
    configuration: &configuration::Configuration,
    pm_uuid: &str,
) -> Result<models::NotificationWebhookMapping, Error<PropertymappingsNotificationRetrieveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_pm_uuid = pm_uuid;

    let uri_str = format!(
        "{}/propertymappings/notification/{pm_uuid}/",
        configuration.base_path,
        pm_uuid = crate::apis::urlencode(p_pm_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::NotificationWebhookMapping`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::NotificationWebhookMapping`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsNotificationRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// NotificationWebhookMapping Viewset
pub async fn propertymappings_notification_update(
    configuration: &configuration::Configuration,
    pm_uuid: &str,
    notification_webhook_mapping_request: models::NotificationWebhookMappingRequest,
) -> Result<models::NotificationWebhookMapping, Error<PropertymappingsNotificationUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_pm_uuid = pm_uuid;
    let p_notification_webhook_mapping_request = notification_webhook_mapping_request;

    let uri_str = format!(
        "{}/propertymappings/notification/{pm_uuid}/",
        configuration.base_path,
        pm_uuid = crate::apis::urlencode(p_pm_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_notification_webhook_mapping_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::NotificationWebhookMapping`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::NotificationWebhookMapping`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsNotificationUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get a list of all objects that use this object
pub async fn propertymappings_notification_used_by_list(
    configuration: &configuration::Configuration,
    pm_uuid: &str,
) -> Result<Vec<models::UsedBy>, Error<PropertymappingsNotificationUsedByListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_pm_uuid = pm_uuid;

    let uri_str = format!(
        "{}/propertymappings/notification/{pm_uuid}/used_by/",
        configuration.base_path,
        pm_uuid = crate::apis::urlencode(p_pm_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsNotificationUsedByListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// GoogleWorkspaceProviderMapping Viewset
pub async fn propertymappings_provider_google_workspace_create(
    configuration: &configuration::Configuration,
    google_workspace_provider_mapping_request: models::GoogleWorkspaceProviderMappingRequest,
) -> Result<models::GoogleWorkspaceProviderMapping, Error<PropertymappingsProviderGoogleWorkspaceCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_google_workspace_provider_mapping_request = google_workspace_provider_mapping_request;

    let uri_str = format!(
        "{}/propertymappings/provider/google_workspace/",
        configuration.base_path
    );
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_google_workspace_provider_mapping_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GoogleWorkspaceProviderMapping`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GoogleWorkspaceProviderMapping`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsProviderGoogleWorkspaceCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// GoogleWorkspaceProviderMapping Viewset
pub async fn propertymappings_provider_google_workspace_destroy(
    configuration: &configuration::Configuration,
    pm_uuid: &str,
) -> Result<(), Error<PropertymappingsProviderGoogleWorkspaceDestroyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_pm_uuid = pm_uuid;

    let uri_str = format!(
        "{}/propertymappings/provider/google_workspace/{pm_uuid}/",
        configuration.base_path,
        pm_uuid = crate::apis::urlencode(p_pm_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsProviderGoogleWorkspaceDestroyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// GoogleWorkspaceProviderMapping Viewset
pub async fn propertymappings_provider_google_workspace_list(
    configuration: &configuration::Configuration,
    expression: Option<&str>,
    managed: Option<Vec<String>>,
    name: Option<&str>,
    ordering: Option<&str>,
    page: Option<i32>,
    page_size: Option<i32>,
    pm_uuid: Option<&str>,
    search: Option<&str>,
) -> Result<models::PaginatedGoogleWorkspaceProviderMappingList, Error<PropertymappingsProviderGoogleWorkspaceListError>>
{
    // add a prefix to parameters to efficiently prevent name collisions
    let p_expression = expression;
    let p_managed = managed;
    let p_name = name;
    let p_ordering = ordering;
    let p_page = page;
    let p_page_size = page_size;
    let p_pm_uuid = pm_uuid;
    let p_search = search;

    let uri_str = format!(
        "{}/propertymappings/provider/google_workspace/",
        configuration.base_path
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_expression {
        req_builder = req_builder.query(&[("expression", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_managed {
        req_builder = match "multi" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("managed".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "managed",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = p_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_ordering {
        req_builder = req_builder.query(&[("ordering", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page_size {
        req_builder = req_builder.query(&[("page_size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_pm_uuid {
        req_builder = req_builder.query(&[("pm_uuid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_search {
        req_builder = req_builder.query(&[("search", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginatedGoogleWorkspaceProviderMappingList`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginatedGoogleWorkspaceProviderMappingList`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsProviderGoogleWorkspaceListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// GoogleWorkspaceProviderMapping Viewset
pub async fn propertymappings_provider_google_workspace_partial_update(
    configuration: &configuration::Configuration,
    pm_uuid: &str,
    patched_google_workspace_provider_mapping_request: Option<models::PatchedGoogleWorkspaceProviderMappingRequest>,
) -> Result<models::GoogleWorkspaceProviderMapping, Error<PropertymappingsProviderGoogleWorkspacePartialUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_pm_uuid = pm_uuid;
    let p_patched_google_workspace_provider_mapping_request = patched_google_workspace_provider_mapping_request;

    let uri_str = format!(
        "{}/propertymappings/provider/google_workspace/{pm_uuid}/",
        configuration.base_path,
        pm_uuid = crate::apis::urlencode(p_pm_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_patched_google_workspace_provider_mapping_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GoogleWorkspaceProviderMapping`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GoogleWorkspaceProviderMapping`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsProviderGoogleWorkspacePartialUpdateError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// GoogleWorkspaceProviderMapping Viewset
pub async fn propertymappings_provider_google_workspace_retrieve(
    configuration: &configuration::Configuration,
    pm_uuid: &str,
) -> Result<models::GoogleWorkspaceProviderMapping, Error<PropertymappingsProviderGoogleWorkspaceRetrieveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_pm_uuid = pm_uuid;

    let uri_str = format!(
        "{}/propertymappings/provider/google_workspace/{pm_uuid}/",
        configuration.base_path,
        pm_uuid = crate::apis::urlencode(p_pm_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GoogleWorkspaceProviderMapping`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GoogleWorkspaceProviderMapping`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsProviderGoogleWorkspaceRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// GoogleWorkspaceProviderMapping Viewset
pub async fn propertymappings_provider_google_workspace_update(
    configuration: &configuration::Configuration,
    pm_uuid: &str,
    google_workspace_provider_mapping_request: models::GoogleWorkspaceProviderMappingRequest,
) -> Result<models::GoogleWorkspaceProviderMapping, Error<PropertymappingsProviderGoogleWorkspaceUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_pm_uuid = pm_uuid;
    let p_google_workspace_provider_mapping_request = google_workspace_provider_mapping_request;

    let uri_str = format!(
        "{}/propertymappings/provider/google_workspace/{pm_uuid}/",
        configuration.base_path,
        pm_uuid = crate::apis::urlencode(p_pm_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_google_workspace_provider_mapping_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GoogleWorkspaceProviderMapping`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GoogleWorkspaceProviderMapping`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsProviderGoogleWorkspaceUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get a list of all objects that use this object
pub async fn propertymappings_provider_google_workspace_used_by_list(
    configuration: &configuration::Configuration,
    pm_uuid: &str,
) -> Result<Vec<models::UsedBy>, Error<PropertymappingsProviderGoogleWorkspaceUsedByListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_pm_uuid = pm_uuid;

    let uri_str = format!(
        "{}/propertymappings/provider/google_workspace/{pm_uuid}/used_by/",
        configuration.base_path,
        pm_uuid = crate::apis::urlencode(p_pm_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsProviderGoogleWorkspaceUsedByListError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// MicrosoftEntraProviderMapping Viewset
pub async fn propertymappings_provider_microsoft_entra_create(
    configuration: &configuration::Configuration,
    microsoft_entra_provider_mapping_request: models::MicrosoftEntraProviderMappingRequest,
) -> Result<models::MicrosoftEntraProviderMapping, Error<PropertymappingsProviderMicrosoftEntraCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_microsoft_entra_provider_mapping_request = microsoft_entra_provider_mapping_request;

    let uri_str = format!("{}/propertymappings/provider/microsoft_entra/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_microsoft_entra_provider_mapping_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MicrosoftEntraProviderMapping`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MicrosoftEntraProviderMapping`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsProviderMicrosoftEntraCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// MicrosoftEntraProviderMapping Viewset
pub async fn propertymappings_provider_microsoft_entra_destroy(
    configuration: &configuration::Configuration,
    pm_uuid: &str,
) -> Result<(), Error<PropertymappingsProviderMicrosoftEntraDestroyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_pm_uuid = pm_uuid;

    let uri_str = format!(
        "{}/propertymappings/provider/microsoft_entra/{pm_uuid}/",
        configuration.base_path,
        pm_uuid = crate::apis::urlencode(p_pm_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsProviderMicrosoftEntraDestroyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// MicrosoftEntraProviderMapping Viewset
pub async fn propertymappings_provider_microsoft_entra_list(
    configuration: &configuration::Configuration,
    expression: Option<&str>,
    managed: Option<Vec<String>>,
    name: Option<&str>,
    ordering: Option<&str>,
    page: Option<i32>,
    page_size: Option<i32>,
    pm_uuid: Option<&str>,
    search: Option<&str>,
) -> Result<models::PaginatedMicrosoftEntraProviderMappingList, Error<PropertymappingsProviderMicrosoftEntraListError>>
{
    // add a prefix to parameters to efficiently prevent name collisions
    let p_expression = expression;
    let p_managed = managed;
    let p_name = name;
    let p_ordering = ordering;
    let p_page = page;
    let p_page_size = page_size;
    let p_pm_uuid = pm_uuid;
    let p_search = search;

    let uri_str = format!("{}/propertymappings/provider/microsoft_entra/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_expression {
        req_builder = req_builder.query(&[("expression", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_managed {
        req_builder = match "multi" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("managed".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "managed",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = p_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_ordering {
        req_builder = req_builder.query(&[("ordering", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page_size {
        req_builder = req_builder.query(&[("page_size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_pm_uuid {
        req_builder = req_builder.query(&[("pm_uuid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_search {
        req_builder = req_builder.query(&[("search", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginatedMicrosoftEntraProviderMappingList`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginatedMicrosoftEntraProviderMappingList`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsProviderMicrosoftEntraListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// MicrosoftEntraProviderMapping Viewset
pub async fn propertymappings_provider_microsoft_entra_partial_update(
    configuration: &configuration::Configuration,
    pm_uuid: &str,
    patched_microsoft_entra_provider_mapping_request: Option<models::PatchedMicrosoftEntraProviderMappingRequest>,
) -> Result<models::MicrosoftEntraProviderMapping, Error<PropertymappingsProviderMicrosoftEntraPartialUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_pm_uuid = pm_uuid;
    let p_patched_microsoft_entra_provider_mapping_request = patched_microsoft_entra_provider_mapping_request;

    let uri_str = format!(
        "{}/propertymappings/provider/microsoft_entra/{pm_uuid}/",
        configuration.base_path,
        pm_uuid = crate::apis::urlencode(p_pm_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_patched_microsoft_entra_provider_mapping_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MicrosoftEntraProviderMapping`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MicrosoftEntraProviderMapping`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsProviderMicrosoftEntraPartialUpdateError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// MicrosoftEntraProviderMapping Viewset
pub async fn propertymappings_provider_microsoft_entra_retrieve(
    configuration: &configuration::Configuration,
    pm_uuid: &str,
) -> Result<models::MicrosoftEntraProviderMapping, Error<PropertymappingsProviderMicrosoftEntraRetrieveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_pm_uuid = pm_uuid;

    let uri_str = format!(
        "{}/propertymappings/provider/microsoft_entra/{pm_uuid}/",
        configuration.base_path,
        pm_uuid = crate::apis::urlencode(p_pm_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MicrosoftEntraProviderMapping`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MicrosoftEntraProviderMapping`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsProviderMicrosoftEntraRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// MicrosoftEntraProviderMapping Viewset
pub async fn propertymappings_provider_microsoft_entra_update(
    configuration: &configuration::Configuration,
    pm_uuid: &str,
    microsoft_entra_provider_mapping_request: models::MicrosoftEntraProviderMappingRequest,
) -> Result<models::MicrosoftEntraProviderMapping, Error<PropertymappingsProviderMicrosoftEntraUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_pm_uuid = pm_uuid;
    let p_microsoft_entra_provider_mapping_request = microsoft_entra_provider_mapping_request;

    let uri_str = format!(
        "{}/propertymappings/provider/microsoft_entra/{pm_uuid}/",
        configuration.base_path,
        pm_uuid = crate::apis::urlencode(p_pm_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_microsoft_entra_provider_mapping_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::MicrosoftEntraProviderMapping`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::MicrosoftEntraProviderMapping`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsProviderMicrosoftEntraUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get a list of all objects that use this object
pub async fn propertymappings_provider_microsoft_entra_used_by_list(
    configuration: &configuration::Configuration,
    pm_uuid: &str,
) -> Result<Vec<models::UsedBy>, Error<PropertymappingsProviderMicrosoftEntraUsedByListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_pm_uuid = pm_uuid;

    let uri_str = format!(
        "{}/propertymappings/provider/microsoft_entra/{pm_uuid}/used_by/",
        configuration.base_path,
        pm_uuid = crate::apis::urlencode(p_pm_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsProviderMicrosoftEntraUsedByListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// RACPropertyMapping Viewset
pub async fn propertymappings_provider_rac_create(
    configuration: &configuration::Configuration,
    rac_property_mapping_request: models::RacPropertyMappingRequest,
) -> Result<models::RacPropertyMapping, Error<PropertymappingsProviderRacCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_rac_property_mapping_request = rac_property_mapping_request;

    let uri_str = format!("{}/propertymappings/provider/rac/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_rac_property_mapping_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RacPropertyMapping`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RacPropertyMapping`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsProviderRacCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// RACPropertyMapping Viewset
pub async fn propertymappings_provider_rac_destroy(
    configuration: &configuration::Configuration,
    pm_uuid: &str,
) -> Result<(), Error<PropertymappingsProviderRacDestroyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_pm_uuid = pm_uuid;

    let uri_str = format!(
        "{}/propertymappings/provider/rac/{pm_uuid}/",
        configuration.base_path,
        pm_uuid = crate::apis::urlencode(p_pm_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsProviderRacDestroyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// RACPropertyMapping Viewset
pub async fn propertymappings_provider_rac_list(
    configuration: &configuration::Configuration,
    managed: Option<Vec<String>>,
    name: Option<&str>,
    ordering: Option<&str>,
    page: Option<i32>,
    page_size: Option<i32>,
    search: Option<&str>,
) -> Result<models::PaginatedRacPropertyMappingList, Error<PropertymappingsProviderRacListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_managed = managed;
    let p_name = name;
    let p_ordering = ordering;
    let p_page = page;
    let p_page_size = page_size;
    let p_search = search;

    let uri_str = format!("{}/propertymappings/provider/rac/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_managed {
        req_builder = match "multi" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("managed".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "managed",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = p_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_ordering {
        req_builder = req_builder.query(&[("ordering", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page_size {
        req_builder = req_builder.query(&[("page_size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_search {
        req_builder = req_builder.query(&[("search", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginatedRacPropertyMappingList`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginatedRacPropertyMappingList`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsProviderRacListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// RACPropertyMapping Viewset
pub async fn propertymappings_provider_rac_partial_update(
    configuration: &configuration::Configuration,
    pm_uuid: &str,
    patched_rac_property_mapping_request: Option<models::PatchedRacPropertyMappingRequest>,
) -> Result<models::RacPropertyMapping, Error<PropertymappingsProviderRacPartialUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_pm_uuid = pm_uuid;
    let p_patched_rac_property_mapping_request = patched_rac_property_mapping_request;

    let uri_str = format!(
        "{}/propertymappings/provider/rac/{pm_uuid}/",
        configuration.base_path,
        pm_uuid = crate::apis::urlencode(p_pm_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_patched_rac_property_mapping_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RacPropertyMapping`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RacPropertyMapping`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsProviderRacPartialUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// RACPropertyMapping Viewset
pub async fn propertymappings_provider_rac_retrieve(
    configuration: &configuration::Configuration,
    pm_uuid: &str,
) -> Result<models::RacPropertyMapping, Error<PropertymappingsProviderRacRetrieveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_pm_uuid = pm_uuid;

    let uri_str = format!(
        "{}/propertymappings/provider/rac/{pm_uuid}/",
        configuration.base_path,
        pm_uuid = crate::apis::urlencode(p_pm_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RacPropertyMapping`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RacPropertyMapping`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsProviderRacRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// RACPropertyMapping Viewset
pub async fn propertymappings_provider_rac_update(
    configuration: &configuration::Configuration,
    pm_uuid: &str,
    rac_property_mapping_request: models::RacPropertyMappingRequest,
) -> Result<models::RacPropertyMapping, Error<PropertymappingsProviderRacUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_pm_uuid = pm_uuid;
    let p_rac_property_mapping_request = rac_property_mapping_request;

    let uri_str = format!(
        "{}/propertymappings/provider/rac/{pm_uuid}/",
        configuration.base_path,
        pm_uuid = crate::apis::urlencode(p_pm_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_rac_property_mapping_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RacPropertyMapping`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RacPropertyMapping`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsProviderRacUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get a list of all objects that use this object
pub async fn propertymappings_provider_rac_used_by_list(
    configuration: &configuration::Configuration,
    pm_uuid: &str,
) -> Result<Vec<models::UsedBy>, Error<PropertymappingsProviderRacUsedByListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_pm_uuid = pm_uuid;

    let uri_str = format!(
        "{}/propertymappings/provider/rac/{pm_uuid}/used_by/",
        configuration.base_path,
        pm_uuid = crate::apis::urlencode(p_pm_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsProviderRacUsedByListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// RadiusProviderPropertyMapping Viewset
pub async fn propertymappings_provider_radius_create(
    configuration: &configuration::Configuration,
    radius_provider_property_mapping_request: models::RadiusProviderPropertyMappingRequest,
) -> Result<models::RadiusProviderPropertyMapping, Error<PropertymappingsProviderRadiusCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_radius_provider_property_mapping_request = radius_provider_property_mapping_request;

    let uri_str = format!("{}/propertymappings/provider/radius/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_radius_provider_property_mapping_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RadiusProviderPropertyMapping`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RadiusProviderPropertyMapping`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsProviderRadiusCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// RadiusProviderPropertyMapping Viewset
pub async fn propertymappings_provider_radius_destroy(
    configuration: &configuration::Configuration,
    pm_uuid: &str,
) -> Result<(), Error<PropertymappingsProviderRadiusDestroyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_pm_uuid = pm_uuid;

    let uri_str = format!(
        "{}/propertymappings/provider/radius/{pm_uuid}/",
        configuration.base_path,
        pm_uuid = crate::apis::urlencode(p_pm_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsProviderRadiusDestroyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// RadiusProviderPropertyMapping Viewset
pub async fn propertymappings_provider_radius_list(
    configuration: &configuration::Configuration,
    managed: Option<Vec<String>>,
    managed__isnull: Option<bool>,
    name: Option<&str>,
    ordering: Option<&str>,
    page: Option<i32>,
    page_size: Option<i32>,
    search: Option<&str>,
) -> Result<models::PaginatedRadiusProviderPropertyMappingList, Error<PropertymappingsProviderRadiusListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_managed = managed;
    let p_managed__isnull = managed__isnull;
    let p_name = name;
    let p_ordering = ordering;
    let p_page = page;
    let p_page_size = page_size;
    let p_search = search;

    let uri_str = format!("{}/propertymappings/provider/radius/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_managed {
        req_builder = match "multi" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("managed".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "managed",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = p_managed__isnull {
        req_builder = req_builder.query(&[("managed__isnull", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_ordering {
        req_builder = req_builder.query(&[("ordering", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page_size {
        req_builder = req_builder.query(&[("page_size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_search {
        req_builder = req_builder.query(&[("search", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginatedRadiusProviderPropertyMappingList`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginatedRadiusProviderPropertyMappingList`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsProviderRadiusListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// RadiusProviderPropertyMapping Viewset
pub async fn propertymappings_provider_radius_partial_update(
    configuration: &configuration::Configuration,
    pm_uuid: &str,
    patched_radius_provider_property_mapping_request: Option<models::PatchedRadiusProviderPropertyMappingRequest>,
) -> Result<models::RadiusProviderPropertyMapping, Error<PropertymappingsProviderRadiusPartialUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_pm_uuid = pm_uuid;
    let p_patched_radius_provider_property_mapping_request = patched_radius_provider_property_mapping_request;

    let uri_str = format!(
        "{}/propertymappings/provider/radius/{pm_uuid}/",
        configuration.base_path,
        pm_uuid = crate::apis::urlencode(p_pm_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_patched_radius_provider_property_mapping_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RadiusProviderPropertyMapping`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RadiusProviderPropertyMapping`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsProviderRadiusPartialUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// RadiusProviderPropertyMapping Viewset
pub async fn propertymappings_provider_radius_retrieve(
    configuration: &configuration::Configuration,
    pm_uuid: &str,
) -> Result<models::RadiusProviderPropertyMapping, Error<PropertymappingsProviderRadiusRetrieveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_pm_uuid = pm_uuid;

    let uri_str = format!(
        "{}/propertymappings/provider/radius/{pm_uuid}/",
        configuration.base_path,
        pm_uuid = crate::apis::urlencode(p_pm_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RadiusProviderPropertyMapping`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RadiusProviderPropertyMapping`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsProviderRadiusRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// RadiusProviderPropertyMapping Viewset
pub async fn propertymappings_provider_radius_update(
    configuration: &configuration::Configuration,
    pm_uuid: &str,
    radius_provider_property_mapping_request: models::RadiusProviderPropertyMappingRequest,
) -> Result<models::RadiusProviderPropertyMapping, Error<PropertymappingsProviderRadiusUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_pm_uuid = pm_uuid;
    let p_radius_provider_property_mapping_request = radius_provider_property_mapping_request;

    let uri_str = format!(
        "{}/propertymappings/provider/radius/{pm_uuid}/",
        configuration.base_path,
        pm_uuid = crate::apis::urlencode(p_pm_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_radius_provider_property_mapping_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RadiusProviderPropertyMapping`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RadiusProviderPropertyMapping`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsProviderRadiusUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get a list of all objects that use this object
pub async fn propertymappings_provider_radius_used_by_list(
    configuration: &configuration::Configuration,
    pm_uuid: &str,
) -> Result<Vec<models::UsedBy>, Error<PropertymappingsProviderRadiusUsedByListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_pm_uuid = pm_uuid;

    let uri_str = format!(
        "{}/propertymappings/provider/radius/{pm_uuid}/used_by/",
        configuration.base_path,
        pm_uuid = crate::apis::urlencode(p_pm_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsProviderRadiusUsedByListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// SAMLPropertyMapping Viewset
pub async fn propertymappings_provider_saml_create(
    configuration: &configuration::Configuration,
    saml_property_mapping_request: models::SamlPropertyMappingRequest,
) -> Result<models::SamlPropertyMapping, Error<PropertymappingsProviderSamlCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_saml_property_mapping_request = saml_property_mapping_request;

    let uri_str = format!("{}/propertymappings/provider/saml/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_saml_property_mapping_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SamlPropertyMapping`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SamlPropertyMapping`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsProviderSamlCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// SAMLPropertyMapping Viewset
pub async fn propertymappings_provider_saml_destroy(
    configuration: &configuration::Configuration,
    pm_uuid: &str,
) -> Result<(), Error<PropertymappingsProviderSamlDestroyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_pm_uuid = pm_uuid;

    let uri_str = format!(
        "{}/propertymappings/provider/saml/{pm_uuid}/",
        configuration.base_path,
        pm_uuid = crate::apis::urlencode(p_pm_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsProviderSamlDestroyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// SAMLPropertyMapping Viewset
pub async fn propertymappings_provider_saml_list(
    configuration: &configuration::Configuration,
    friendly_name: Option<&str>,
    managed: Option<Vec<String>>,
    managed__isnull: Option<bool>,
    name: Option<&str>,
    ordering: Option<&str>,
    page: Option<i32>,
    page_size: Option<i32>,
    saml_name: Option<&str>,
    search: Option<&str>,
) -> Result<models::PaginatedSamlPropertyMappingList, Error<PropertymappingsProviderSamlListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_friendly_name = friendly_name;
    let p_managed = managed;
    let p_managed__isnull = managed__isnull;
    let p_name = name;
    let p_ordering = ordering;
    let p_page = page;
    let p_page_size = page_size;
    let p_saml_name = saml_name;
    let p_search = search;

    let uri_str = format!("{}/propertymappings/provider/saml/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_friendly_name {
        req_builder = req_builder.query(&[("friendly_name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_managed {
        req_builder = match "multi" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("managed".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "managed",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = p_managed__isnull {
        req_builder = req_builder.query(&[("managed__isnull", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_ordering {
        req_builder = req_builder.query(&[("ordering", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page_size {
        req_builder = req_builder.query(&[("page_size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_saml_name {
        req_builder = req_builder.query(&[("saml_name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_search {
        req_builder = req_builder.query(&[("search", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginatedSamlPropertyMappingList`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginatedSamlPropertyMappingList`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsProviderSamlListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// SAMLPropertyMapping Viewset
pub async fn propertymappings_provider_saml_partial_update(
    configuration: &configuration::Configuration,
    pm_uuid: &str,
    patched_saml_property_mapping_request: Option<models::PatchedSamlPropertyMappingRequest>,
) -> Result<models::SamlPropertyMapping, Error<PropertymappingsProviderSamlPartialUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_pm_uuid = pm_uuid;
    let p_patched_saml_property_mapping_request = patched_saml_property_mapping_request;

    let uri_str = format!(
        "{}/propertymappings/provider/saml/{pm_uuid}/",
        configuration.base_path,
        pm_uuid = crate::apis::urlencode(p_pm_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_patched_saml_property_mapping_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SamlPropertyMapping`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SamlPropertyMapping`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsProviderSamlPartialUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// SAMLPropertyMapping Viewset
pub async fn propertymappings_provider_saml_retrieve(
    configuration: &configuration::Configuration,
    pm_uuid: &str,
) -> Result<models::SamlPropertyMapping, Error<PropertymappingsProviderSamlRetrieveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_pm_uuid = pm_uuid;

    let uri_str = format!(
        "{}/propertymappings/provider/saml/{pm_uuid}/",
        configuration.base_path,
        pm_uuid = crate::apis::urlencode(p_pm_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SamlPropertyMapping`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SamlPropertyMapping`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsProviderSamlRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// SAMLPropertyMapping Viewset
pub async fn propertymappings_provider_saml_update(
    configuration: &configuration::Configuration,
    pm_uuid: &str,
    saml_property_mapping_request: models::SamlPropertyMappingRequest,
) -> Result<models::SamlPropertyMapping, Error<PropertymappingsProviderSamlUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_pm_uuid = pm_uuid;
    let p_saml_property_mapping_request = saml_property_mapping_request;

    let uri_str = format!(
        "{}/propertymappings/provider/saml/{pm_uuid}/",
        configuration.base_path,
        pm_uuid = crate::apis::urlencode(p_pm_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_saml_property_mapping_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SamlPropertyMapping`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SamlPropertyMapping`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsProviderSamlUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get a list of all objects that use this object
pub async fn propertymappings_provider_saml_used_by_list(
    configuration: &configuration::Configuration,
    pm_uuid: &str,
) -> Result<Vec<models::UsedBy>, Error<PropertymappingsProviderSamlUsedByListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_pm_uuid = pm_uuid;

    let uri_str = format!(
        "{}/propertymappings/provider/saml/{pm_uuid}/used_by/",
        configuration.base_path,
        pm_uuid = crate::apis::urlencode(p_pm_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsProviderSamlUsedByListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// SCIMMapping Viewset
pub async fn propertymappings_provider_scim_create(
    configuration: &configuration::Configuration,
    scim_mapping_request: models::ScimMappingRequest,
) -> Result<models::ScimMapping, Error<PropertymappingsProviderScimCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_scim_mapping_request = scim_mapping_request;

    let uri_str = format!("{}/propertymappings/provider/scim/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_scim_mapping_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::ScimMapping`",
                )))
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::ScimMapping`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsProviderScimCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// SCIMMapping Viewset
pub async fn propertymappings_provider_scim_destroy(
    configuration: &configuration::Configuration,
    pm_uuid: &str,
) -> Result<(), Error<PropertymappingsProviderScimDestroyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_pm_uuid = pm_uuid;

    let uri_str = format!(
        "{}/propertymappings/provider/scim/{pm_uuid}/",
        configuration.base_path,
        pm_uuid = crate::apis::urlencode(p_pm_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsProviderScimDestroyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// SCIMMapping Viewset
pub async fn propertymappings_provider_scim_list(
    configuration: &configuration::Configuration,
    managed: Option<Vec<String>>,
    managed__isnull: Option<bool>,
    name: Option<&str>,
    ordering: Option<&str>,
    page: Option<i32>,
    page_size: Option<i32>,
    search: Option<&str>,
) -> Result<models::PaginatedScimMappingList, Error<PropertymappingsProviderScimListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_managed = managed;
    let p_managed__isnull = managed__isnull;
    let p_name = name;
    let p_ordering = ordering;
    let p_page = page;
    let p_page_size = page_size;
    let p_search = search;

    let uri_str = format!("{}/propertymappings/provider/scim/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_managed {
        req_builder = match "multi" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("managed".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "managed",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = p_managed__isnull {
        req_builder = req_builder.query(&[("managed__isnull", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_ordering {
        req_builder = req_builder.query(&[("ordering", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page_size {
        req_builder = req_builder.query(&[("page_size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_search {
        req_builder = req_builder.query(&[("search", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginatedScimMappingList`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginatedScimMappingList`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsProviderScimListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// SCIMMapping Viewset
pub async fn propertymappings_provider_scim_partial_update(
    configuration: &configuration::Configuration,
    pm_uuid: &str,
    patched_scim_mapping_request: Option<models::PatchedScimMappingRequest>,
) -> Result<models::ScimMapping, Error<PropertymappingsProviderScimPartialUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_pm_uuid = pm_uuid;
    let p_patched_scim_mapping_request = patched_scim_mapping_request;

    let uri_str = format!(
        "{}/propertymappings/provider/scim/{pm_uuid}/",
        configuration.base_path,
        pm_uuid = crate::apis::urlencode(p_pm_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_patched_scim_mapping_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::ScimMapping`",
                )))
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::ScimMapping`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsProviderScimPartialUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// SCIMMapping Viewset
pub async fn propertymappings_provider_scim_retrieve(
    configuration: &configuration::Configuration,
    pm_uuid: &str,
) -> Result<models::ScimMapping, Error<PropertymappingsProviderScimRetrieveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_pm_uuid = pm_uuid;

    let uri_str = format!(
        "{}/propertymappings/provider/scim/{pm_uuid}/",
        configuration.base_path,
        pm_uuid = crate::apis::urlencode(p_pm_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::ScimMapping`",
                )))
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::ScimMapping`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsProviderScimRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// SCIMMapping Viewset
pub async fn propertymappings_provider_scim_update(
    configuration: &configuration::Configuration,
    pm_uuid: &str,
    scim_mapping_request: models::ScimMappingRequest,
) -> Result<models::ScimMapping, Error<PropertymappingsProviderScimUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_pm_uuid = pm_uuid;
    let p_scim_mapping_request = scim_mapping_request;

    let uri_str = format!(
        "{}/propertymappings/provider/scim/{pm_uuid}/",
        configuration.base_path,
        pm_uuid = crate::apis::urlencode(p_pm_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_scim_mapping_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::ScimMapping`",
                )))
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::ScimMapping`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsProviderScimUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get a list of all objects that use this object
pub async fn propertymappings_provider_scim_used_by_list(
    configuration: &configuration::Configuration,
    pm_uuid: &str,
) -> Result<Vec<models::UsedBy>, Error<PropertymappingsProviderScimUsedByListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_pm_uuid = pm_uuid;

    let uri_str = format!(
        "{}/propertymappings/provider/scim/{pm_uuid}/used_by/",
        configuration.base_path,
        pm_uuid = crate::apis::urlencode(p_pm_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsProviderScimUsedByListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// ScopeMapping Viewset
pub async fn propertymappings_provider_scope_create(
    configuration: &configuration::Configuration,
    scope_mapping_request: models::ScopeMappingRequest,
) -> Result<models::ScopeMapping, Error<PropertymappingsProviderScopeCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_scope_mapping_request = scope_mapping_request;

    let uri_str = format!("{}/propertymappings/provider/scope/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_scope_mapping_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::ScopeMapping`",
                )))
            }
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!(
                "Received `{unknown_type}` content type response that cannot be converted to `models::ScopeMapping`"
            )))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsProviderScopeCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// ScopeMapping Viewset
pub async fn propertymappings_provider_scope_destroy(
    configuration: &configuration::Configuration,
    pm_uuid: &str,
) -> Result<(), Error<PropertymappingsProviderScopeDestroyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_pm_uuid = pm_uuid;

    let uri_str = format!(
        "{}/propertymappings/provider/scope/{pm_uuid}/",
        configuration.base_path,
        pm_uuid = crate::apis::urlencode(p_pm_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsProviderScopeDestroyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// ScopeMapping Viewset
pub async fn propertymappings_provider_scope_list(
    configuration: &configuration::Configuration,
    managed: Option<Vec<String>>,
    managed__isnull: Option<bool>,
    name: Option<&str>,
    ordering: Option<&str>,
    page: Option<i32>,
    page_size: Option<i32>,
    scope_name: Option<&str>,
    search: Option<&str>,
) -> Result<models::PaginatedScopeMappingList, Error<PropertymappingsProviderScopeListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_managed = managed;
    let p_managed__isnull = managed__isnull;
    let p_name = name;
    let p_ordering = ordering;
    let p_page = page;
    let p_page_size = page_size;
    let p_scope_name = scope_name;
    let p_search = search;

    let uri_str = format!("{}/propertymappings/provider/scope/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_managed {
        req_builder = match "multi" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("managed".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "managed",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = p_managed__isnull {
        req_builder = req_builder.query(&[("managed__isnull", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_ordering {
        req_builder = req_builder.query(&[("ordering", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page_size {
        req_builder = req_builder.query(&[("page_size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_scope_name {
        req_builder = req_builder.query(&[("scope_name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_search {
        req_builder = req_builder.query(&[("search", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginatedScopeMappingList`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginatedScopeMappingList`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsProviderScopeListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// ScopeMapping Viewset
pub async fn propertymappings_provider_scope_partial_update(
    configuration: &configuration::Configuration,
    pm_uuid: &str,
    patched_scope_mapping_request: Option<models::PatchedScopeMappingRequest>,
) -> Result<models::ScopeMapping, Error<PropertymappingsProviderScopePartialUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_pm_uuid = pm_uuid;
    let p_patched_scope_mapping_request = patched_scope_mapping_request;

    let uri_str = format!(
        "{}/propertymappings/provider/scope/{pm_uuid}/",
        configuration.base_path,
        pm_uuid = crate::apis::urlencode(p_pm_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_patched_scope_mapping_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::ScopeMapping`",
                )))
            }
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!(
                "Received `{unknown_type}` content type response that cannot be converted to `models::ScopeMapping`"
            )))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsProviderScopePartialUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// ScopeMapping Viewset
pub async fn propertymappings_provider_scope_retrieve(
    configuration: &configuration::Configuration,
    pm_uuid: &str,
) -> Result<models::ScopeMapping, Error<PropertymappingsProviderScopeRetrieveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_pm_uuid = pm_uuid;

    let uri_str = format!(
        "{}/propertymappings/provider/scope/{pm_uuid}/",
        configuration.base_path,
        pm_uuid = crate::apis::urlencode(p_pm_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::ScopeMapping`",
                )))
            }
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!(
                "Received `{unknown_type}` content type response that cannot be converted to `models::ScopeMapping`"
            )))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsProviderScopeRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// ScopeMapping Viewset
pub async fn propertymappings_provider_scope_update(
    configuration: &configuration::Configuration,
    pm_uuid: &str,
    scope_mapping_request: models::ScopeMappingRequest,
) -> Result<models::ScopeMapping, Error<PropertymappingsProviderScopeUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_pm_uuid = pm_uuid;
    let p_scope_mapping_request = scope_mapping_request;

    let uri_str = format!(
        "{}/propertymappings/provider/scope/{pm_uuid}/",
        configuration.base_path,
        pm_uuid = crate::apis::urlencode(p_pm_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_scope_mapping_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::ScopeMapping`",
                )))
            }
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!(
                "Received `{unknown_type}` content type response that cannot be converted to `models::ScopeMapping`"
            )))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsProviderScopeUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get a list of all objects that use this object
pub async fn propertymappings_provider_scope_used_by_list(
    configuration: &configuration::Configuration,
    pm_uuid: &str,
) -> Result<Vec<models::UsedBy>, Error<PropertymappingsProviderScopeUsedByListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_pm_uuid = pm_uuid;

    let uri_str = format!(
        "{}/propertymappings/provider/scope/{pm_uuid}/used_by/",
        configuration.base_path,
        pm_uuid = crate::apis::urlencode(p_pm_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsProviderScopeUsedByListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// KerberosSource PropertyMapping Viewset
pub async fn propertymappings_source_kerberos_create(
    configuration: &configuration::Configuration,
    kerberos_source_property_mapping_request: models::KerberosSourcePropertyMappingRequest,
) -> Result<models::KerberosSourcePropertyMapping, Error<PropertymappingsSourceKerberosCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_kerberos_source_property_mapping_request = kerberos_source_property_mapping_request;

    let uri_str = format!("{}/propertymappings/source/kerberos/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_kerberos_source_property_mapping_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::KerberosSourcePropertyMapping`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::KerberosSourcePropertyMapping`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsSourceKerberosCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// KerberosSource PropertyMapping Viewset
pub async fn propertymappings_source_kerberos_destroy(
    configuration: &configuration::Configuration,
    pm_uuid: &str,
) -> Result<(), Error<PropertymappingsSourceKerberosDestroyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_pm_uuid = pm_uuid;

    let uri_str = format!(
        "{}/propertymappings/source/kerberos/{pm_uuid}/",
        configuration.base_path,
        pm_uuid = crate::apis::urlencode(p_pm_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsSourceKerberosDestroyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// KerberosSource PropertyMapping Viewset
pub async fn propertymappings_source_kerberos_list(
    configuration: &configuration::Configuration,
    managed: Option<Vec<String>>,
    managed__isnull: Option<bool>,
    name: Option<&str>,
    ordering: Option<&str>,
    page: Option<i32>,
    page_size: Option<i32>,
    search: Option<&str>,
) -> Result<models::PaginatedKerberosSourcePropertyMappingList, Error<PropertymappingsSourceKerberosListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_managed = managed;
    let p_managed__isnull = managed__isnull;
    let p_name = name;
    let p_ordering = ordering;
    let p_page = page;
    let p_page_size = page_size;
    let p_search = search;

    let uri_str = format!("{}/propertymappings/source/kerberos/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_managed {
        req_builder = match "multi" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("managed".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "managed",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = p_managed__isnull {
        req_builder = req_builder.query(&[("managed__isnull", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_ordering {
        req_builder = req_builder.query(&[("ordering", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page_size {
        req_builder = req_builder.query(&[("page_size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_search {
        req_builder = req_builder.query(&[("search", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginatedKerberosSourcePropertyMappingList`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginatedKerberosSourcePropertyMappingList`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsSourceKerberosListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// KerberosSource PropertyMapping Viewset
pub async fn propertymappings_source_kerberos_partial_update(
    configuration: &configuration::Configuration,
    pm_uuid: &str,
    patched_kerberos_source_property_mapping_request: Option<models::PatchedKerberosSourcePropertyMappingRequest>,
) -> Result<models::KerberosSourcePropertyMapping, Error<PropertymappingsSourceKerberosPartialUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_pm_uuid = pm_uuid;
    let p_patched_kerberos_source_property_mapping_request = patched_kerberos_source_property_mapping_request;

    let uri_str = format!(
        "{}/propertymappings/source/kerberos/{pm_uuid}/",
        configuration.base_path,
        pm_uuid = crate::apis::urlencode(p_pm_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_patched_kerberos_source_property_mapping_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::KerberosSourcePropertyMapping`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::KerberosSourcePropertyMapping`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsSourceKerberosPartialUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// KerberosSource PropertyMapping Viewset
pub async fn propertymappings_source_kerberos_retrieve(
    configuration: &configuration::Configuration,
    pm_uuid: &str,
) -> Result<models::KerberosSourcePropertyMapping, Error<PropertymappingsSourceKerberosRetrieveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_pm_uuid = pm_uuid;

    let uri_str = format!(
        "{}/propertymappings/source/kerberos/{pm_uuid}/",
        configuration.base_path,
        pm_uuid = crate::apis::urlencode(p_pm_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::KerberosSourcePropertyMapping`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::KerberosSourcePropertyMapping`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsSourceKerberosRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// KerberosSource PropertyMapping Viewset
pub async fn propertymappings_source_kerberos_update(
    configuration: &configuration::Configuration,
    pm_uuid: &str,
    kerberos_source_property_mapping_request: models::KerberosSourcePropertyMappingRequest,
) -> Result<models::KerberosSourcePropertyMapping, Error<PropertymappingsSourceKerberosUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_pm_uuid = pm_uuid;
    let p_kerberos_source_property_mapping_request = kerberos_source_property_mapping_request;

    let uri_str = format!(
        "{}/propertymappings/source/kerberos/{pm_uuid}/",
        configuration.base_path,
        pm_uuid = crate::apis::urlencode(p_pm_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_kerberos_source_property_mapping_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::KerberosSourcePropertyMapping`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::KerberosSourcePropertyMapping`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsSourceKerberosUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get a list of all objects that use this object
pub async fn propertymappings_source_kerberos_used_by_list(
    configuration: &configuration::Configuration,
    pm_uuid: &str,
) -> Result<Vec<models::UsedBy>, Error<PropertymappingsSourceKerberosUsedByListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_pm_uuid = pm_uuid;

    let uri_str = format!(
        "{}/propertymappings/source/kerberos/{pm_uuid}/used_by/",
        configuration.base_path,
        pm_uuid = crate::apis::urlencode(p_pm_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsSourceKerberosUsedByListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// LDAP PropertyMapping Viewset
pub async fn propertymappings_source_ldap_create(
    configuration: &configuration::Configuration,
    ldap_source_property_mapping_request: models::LdapSourcePropertyMappingRequest,
) -> Result<models::LdapSourcePropertyMapping, Error<PropertymappingsSourceLdapCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_ldap_source_property_mapping_request = ldap_source_property_mapping_request;

    let uri_str = format!("{}/propertymappings/source/ldap/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_ldap_source_property_mapping_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::LdapSourcePropertyMapping`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::LdapSourcePropertyMapping`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsSourceLdapCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// LDAP PropertyMapping Viewset
pub async fn propertymappings_source_ldap_destroy(
    configuration: &configuration::Configuration,
    pm_uuid: &str,
) -> Result<(), Error<PropertymappingsSourceLdapDestroyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_pm_uuid = pm_uuid;

    let uri_str = format!(
        "{}/propertymappings/source/ldap/{pm_uuid}/",
        configuration.base_path,
        pm_uuid = crate::apis::urlencode(p_pm_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsSourceLdapDestroyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// LDAP PropertyMapping Viewset
pub async fn propertymappings_source_ldap_list(
    configuration: &configuration::Configuration,
    managed: Option<Vec<String>>,
    managed__isnull: Option<bool>,
    name: Option<&str>,
    ordering: Option<&str>,
    page: Option<i32>,
    page_size: Option<i32>,
    search: Option<&str>,
) -> Result<models::PaginatedLdapSourcePropertyMappingList, Error<PropertymappingsSourceLdapListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_managed = managed;
    let p_managed__isnull = managed__isnull;
    let p_name = name;
    let p_ordering = ordering;
    let p_page = page;
    let p_page_size = page_size;
    let p_search = search;

    let uri_str = format!("{}/propertymappings/source/ldap/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_managed {
        req_builder = match "multi" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("managed".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "managed",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = p_managed__isnull {
        req_builder = req_builder.query(&[("managed__isnull", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_ordering {
        req_builder = req_builder.query(&[("ordering", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page_size {
        req_builder = req_builder.query(&[("page_size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_search {
        req_builder = req_builder.query(&[("search", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginatedLdapSourcePropertyMappingList`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginatedLdapSourcePropertyMappingList`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsSourceLdapListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// LDAP PropertyMapping Viewset
pub async fn propertymappings_source_ldap_partial_update(
    configuration: &configuration::Configuration,
    pm_uuid: &str,
    patched_ldap_source_property_mapping_request: Option<models::PatchedLdapSourcePropertyMappingRequest>,
) -> Result<models::LdapSourcePropertyMapping, Error<PropertymappingsSourceLdapPartialUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_pm_uuid = pm_uuid;
    let p_patched_ldap_source_property_mapping_request = patched_ldap_source_property_mapping_request;

    let uri_str = format!(
        "{}/propertymappings/source/ldap/{pm_uuid}/",
        configuration.base_path,
        pm_uuid = crate::apis::urlencode(p_pm_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_patched_ldap_source_property_mapping_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::LdapSourcePropertyMapping`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::LdapSourcePropertyMapping`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsSourceLdapPartialUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// LDAP PropertyMapping Viewset
pub async fn propertymappings_source_ldap_retrieve(
    configuration: &configuration::Configuration,
    pm_uuid: &str,
) -> Result<models::LdapSourcePropertyMapping, Error<PropertymappingsSourceLdapRetrieveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_pm_uuid = pm_uuid;

    let uri_str = format!(
        "{}/propertymappings/source/ldap/{pm_uuid}/",
        configuration.base_path,
        pm_uuid = crate::apis::urlencode(p_pm_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::LdapSourcePropertyMapping`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::LdapSourcePropertyMapping`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsSourceLdapRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// LDAP PropertyMapping Viewset
pub async fn propertymappings_source_ldap_update(
    configuration: &configuration::Configuration,
    pm_uuid: &str,
    ldap_source_property_mapping_request: models::LdapSourcePropertyMappingRequest,
) -> Result<models::LdapSourcePropertyMapping, Error<PropertymappingsSourceLdapUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_pm_uuid = pm_uuid;
    let p_ldap_source_property_mapping_request = ldap_source_property_mapping_request;

    let uri_str = format!(
        "{}/propertymappings/source/ldap/{pm_uuid}/",
        configuration.base_path,
        pm_uuid = crate::apis::urlencode(p_pm_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_ldap_source_property_mapping_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::LdapSourcePropertyMapping`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::LdapSourcePropertyMapping`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsSourceLdapUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get a list of all objects that use this object
pub async fn propertymappings_source_ldap_used_by_list(
    configuration: &configuration::Configuration,
    pm_uuid: &str,
) -> Result<Vec<models::UsedBy>, Error<PropertymappingsSourceLdapUsedByListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_pm_uuid = pm_uuid;

    let uri_str = format!(
        "{}/propertymappings/source/ldap/{pm_uuid}/used_by/",
        configuration.base_path,
        pm_uuid = crate::apis::urlencode(p_pm_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsSourceLdapUsedByListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// OAuthSourcePropertyMapping Viewset
pub async fn propertymappings_source_oauth_create(
    configuration: &configuration::Configuration,
    o_auth_source_property_mapping_request: models::OAuthSourcePropertyMappingRequest,
) -> Result<models::OAuthSourcePropertyMapping, Error<PropertymappingsSourceOauthCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_o_auth_source_property_mapping_request = o_auth_source_property_mapping_request;

    let uri_str = format!("{}/propertymappings/source/oauth/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_o_auth_source_property_mapping_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OAuthSourcePropertyMapping`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OAuthSourcePropertyMapping`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsSourceOauthCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// OAuthSourcePropertyMapping Viewset
pub async fn propertymappings_source_oauth_destroy(
    configuration: &configuration::Configuration,
    pm_uuid: &str,
) -> Result<(), Error<PropertymappingsSourceOauthDestroyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_pm_uuid = pm_uuid;

    let uri_str = format!(
        "{}/propertymappings/source/oauth/{pm_uuid}/",
        configuration.base_path,
        pm_uuid = crate::apis::urlencode(p_pm_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsSourceOauthDestroyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// OAuthSourcePropertyMapping Viewset
pub async fn propertymappings_source_oauth_list(
    configuration: &configuration::Configuration,
    managed: Option<Vec<String>>,
    managed__isnull: Option<bool>,
    name: Option<&str>,
    ordering: Option<&str>,
    page: Option<i32>,
    page_size: Option<i32>,
    search: Option<&str>,
) -> Result<models::PaginatedOAuthSourcePropertyMappingList, Error<PropertymappingsSourceOauthListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_managed = managed;
    let p_managed__isnull = managed__isnull;
    let p_name = name;
    let p_ordering = ordering;
    let p_page = page;
    let p_page_size = page_size;
    let p_search = search;

    let uri_str = format!("{}/propertymappings/source/oauth/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_managed {
        req_builder = match "multi" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("managed".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "managed",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = p_managed__isnull {
        req_builder = req_builder.query(&[("managed__isnull", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_ordering {
        req_builder = req_builder.query(&[("ordering", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page_size {
        req_builder = req_builder.query(&[("page_size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_search {
        req_builder = req_builder.query(&[("search", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginatedOAuthSourcePropertyMappingList`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginatedOAuthSourcePropertyMappingList`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsSourceOauthListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// OAuthSourcePropertyMapping Viewset
pub async fn propertymappings_source_oauth_partial_update(
    configuration: &configuration::Configuration,
    pm_uuid: &str,
    patched_o_auth_source_property_mapping_request: Option<models::PatchedOAuthSourcePropertyMappingRequest>,
) -> Result<models::OAuthSourcePropertyMapping, Error<PropertymappingsSourceOauthPartialUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_pm_uuid = pm_uuid;
    let p_patched_o_auth_source_property_mapping_request = patched_o_auth_source_property_mapping_request;

    let uri_str = format!(
        "{}/propertymappings/source/oauth/{pm_uuid}/",
        configuration.base_path,
        pm_uuid = crate::apis::urlencode(p_pm_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_patched_o_auth_source_property_mapping_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OAuthSourcePropertyMapping`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OAuthSourcePropertyMapping`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsSourceOauthPartialUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// OAuthSourcePropertyMapping Viewset
pub async fn propertymappings_source_oauth_retrieve(
    configuration: &configuration::Configuration,
    pm_uuid: &str,
) -> Result<models::OAuthSourcePropertyMapping, Error<PropertymappingsSourceOauthRetrieveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_pm_uuid = pm_uuid;

    let uri_str = format!(
        "{}/propertymappings/source/oauth/{pm_uuid}/",
        configuration.base_path,
        pm_uuid = crate::apis::urlencode(p_pm_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OAuthSourcePropertyMapping`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OAuthSourcePropertyMapping`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsSourceOauthRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// OAuthSourcePropertyMapping Viewset
pub async fn propertymappings_source_oauth_update(
    configuration: &configuration::Configuration,
    pm_uuid: &str,
    o_auth_source_property_mapping_request: models::OAuthSourcePropertyMappingRequest,
) -> Result<models::OAuthSourcePropertyMapping, Error<PropertymappingsSourceOauthUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_pm_uuid = pm_uuid;
    let p_o_auth_source_property_mapping_request = o_auth_source_property_mapping_request;

    let uri_str = format!(
        "{}/propertymappings/source/oauth/{pm_uuid}/",
        configuration.base_path,
        pm_uuid = crate::apis::urlencode(p_pm_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_o_auth_source_property_mapping_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OAuthSourcePropertyMapping`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OAuthSourcePropertyMapping`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsSourceOauthUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get a list of all objects that use this object
pub async fn propertymappings_source_oauth_used_by_list(
    configuration: &configuration::Configuration,
    pm_uuid: &str,
) -> Result<Vec<models::UsedBy>, Error<PropertymappingsSourceOauthUsedByListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_pm_uuid = pm_uuid;

    let uri_str = format!(
        "{}/propertymappings/source/oauth/{pm_uuid}/used_by/",
        configuration.base_path,
        pm_uuid = crate::apis::urlencode(p_pm_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsSourceOauthUsedByListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// PlexSourcePropertyMapping Viewset
pub async fn propertymappings_source_plex_create(
    configuration: &configuration::Configuration,
    plex_source_property_mapping_request: models::PlexSourcePropertyMappingRequest,
) -> Result<models::PlexSourcePropertyMapping, Error<PropertymappingsSourcePlexCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_plex_source_property_mapping_request = plex_source_property_mapping_request;

    let uri_str = format!("{}/propertymappings/source/plex/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_plex_source_property_mapping_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PlexSourcePropertyMapping`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PlexSourcePropertyMapping`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsSourcePlexCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// PlexSourcePropertyMapping Viewset
pub async fn propertymappings_source_plex_destroy(
    configuration: &configuration::Configuration,
    pm_uuid: &str,
) -> Result<(), Error<PropertymappingsSourcePlexDestroyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_pm_uuid = pm_uuid;

    let uri_str = format!(
        "{}/propertymappings/source/plex/{pm_uuid}/",
        configuration.base_path,
        pm_uuid = crate::apis::urlencode(p_pm_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsSourcePlexDestroyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// PlexSourcePropertyMapping Viewset
pub async fn propertymappings_source_plex_list(
    configuration: &configuration::Configuration,
    managed: Option<Vec<String>>,
    managed__isnull: Option<bool>,
    name: Option<&str>,
    ordering: Option<&str>,
    page: Option<i32>,
    page_size: Option<i32>,
    search: Option<&str>,
) -> Result<models::PaginatedPlexSourcePropertyMappingList, Error<PropertymappingsSourcePlexListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_managed = managed;
    let p_managed__isnull = managed__isnull;
    let p_name = name;
    let p_ordering = ordering;
    let p_page = page;
    let p_page_size = page_size;
    let p_search = search;

    let uri_str = format!("{}/propertymappings/source/plex/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_managed {
        req_builder = match "multi" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("managed".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "managed",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = p_managed__isnull {
        req_builder = req_builder.query(&[("managed__isnull", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_ordering {
        req_builder = req_builder.query(&[("ordering", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page_size {
        req_builder = req_builder.query(&[("page_size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_search {
        req_builder = req_builder.query(&[("search", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginatedPlexSourcePropertyMappingList`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginatedPlexSourcePropertyMappingList`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsSourcePlexListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// PlexSourcePropertyMapping Viewset
pub async fn propertymappings_source_plex_partial_update(
    configuration: &configuration::Configuration,
    pm_uuid: &str,
    patched_plex_source_property_mapping_request: Option<models::PatchedPlexSourcePropertyMappingRequest>,
) -> Result<models::PlexSourcePropertyMapping, Error<PropertymappingsSourcePlexPartialUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_pm_uuid = pm_uuid;
    let p_patched_plex_source_property_mapping_request = patched_plex_source_property_mapping_request;

    let uri_str = format!(
        "{}/propertymappings/source/plex/{pm_uuid}/",
        configuration.base_path,
        pm_uuid = crate::apis::urlencode(p_pm_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_patched_plex_source_property_mapping_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PlexSourcePropertyMapping`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PlexSourcePropertyMapping`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsSourcePlexPartialUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// PlexSourcePropertyMapping Viewset
pub async fn propertymappings_source_plex_retrieve(
    configuration: &configuration::Configuration,
    pm_uuid: &str,
) -> Result<models::PlexSourcePropertyMapping, Error<PropertymappingsSourcePlexRetrieveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_pm_uuid = pm_uuid;

    let uri_str = format!(
        "{}/propertymappings/source/plex/{pm_uuid}/",
        configuration.base_path,
        pm_uuid = crate::apis::urlencode(p_pm_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PlexSourcePropertyMapping`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PlexSourcePropertyMapping`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsSourcePlexRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// PlexSourcePropertyMapping Viewset
pub async fn propertymappings_source_plex_update(
    configuration: &configuration::Configuration,
    pm_uuid: &str,
    plex_source_property_mapping_request: models::PlexSourcePropertyMappingRequest,
) -> Result<models::PlexSourcePropertyMapping, Error<PropertymappingsSourcePlexUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_pm_uuid = pm_uuid;
    let p_plex_source_property_mapping_request = plex_source_property_mapping_request;

    let uri_str = format!(
        "{}/propertymappings/source/plex/{pm_uuid}/",
        configuration.base_path,
        pm_uuid = crate::apis::urlencode(p_pm_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_plex_source_property_mapping_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PlexSourcePropertyMapping`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PlexSourcePropertyMapping`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsSourcePlexUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get a list of all objects that use this object
pub async fn propertymappings_source_plex_used_by_list(
    configuration: &configuration::Configuration,
    pm_uuid: &str,
) -> Result<Vec<models::UsedBy>, Error<PropertymappingsSourcePlexUsedByListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_pm_uuid = pm_uuid;

    let uri_str = format!(
        "{}/propertymappings/source/plex/{pm_uuid}/used_by/",
        configuration.base_path,
        pm_uuid = crate::apis::urlencode(p_pm_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsSourcePlexUsedByListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// SAMLSourcePropertyMapping Viewset
pub async fn propertymappings_source_saml_create(
    configuration: &configuration::Configuration,
    saml_source_property_mapping_request: models::SamlSourcePropertyMappingRequest,
) -> Result<models::SamlSourcePropertyMapping, Error<PropertymappingsSourceSamlCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_saml_source_property_mapping_request = saml_source_property_mapping_request;

    let uri_str = format!("{}/propertymappings/source/saml/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_saml_source_property_mapping_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SamlSourcePropertyMapping`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SamlSourcePropertyMapping`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsSourceSamlCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// SAMLSourcePropertyMapping Viewset
pub async fn propertymappings_source_saml_destroy(
    configuration: &configuration::Configuration,
    pm_uuid: &str,
) -> Result<(), Error<PropertymappingsSourceSamlDestroyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_pm_uuid = pm_uuid;

    let uri_str = format!(
        "{}/propertymappings/source/saml/{pm_uuid}/",
        configuration.base_path,
        pm_uuid = crate::apis::urlencode(p_pm_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsSourceSamlDestroyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// SAMLSourcePropertyMapping Viewset
pub async fn propertymappings_source_saml_list(
    configuration: &configuration::Configuration,
    managed: Option<Vec<String>>,
    managed__isnull: Option<bool>,
    name: Option<&str>,
    ordering: Option<&str>,
    page: Option<i32>,
    page_size: Option<i32>,
    search: Option<&str>,
) -> Result<models::PaginatedSamlSourcePropertyMappingList, Error<PropertymappingsSourceSamlListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_managed = managed;
    let p_managed__isnull = managed__isnull;
    let p_name = name;
    let p_ordering = ordering;
    let p_page = page;
    let p_page_size = page_size;
    let p_search = search;

    let uri_str = format!("{}/propertymappings/source/saml/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_managed {
        req_builder = match "multi" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("managed".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "managed",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = p_managed__isnull {
        req_builder = req_builder.query(&[("managed__isnull", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_ordering {
        req_builder = req_builder.query(&[("ordering", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page_size {
        req_builder = req_builder.query(&[("page_size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_search {
        req_builder = req_builder.query(&[("search", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginatedSamlSourcePropertyMappingList`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginatedSamlSourcePropertyMappingList`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsSourceSamlListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// SAMLSourcePropertyMapping Viewset
pub async fn propertymappings_source_saml_partial_update(
    configuration: &configuration::Configuration,
    pm_uuid: &str,
    patched_saml_source_property_mapping_request: Option<models::PatchedSamlSourcePropertyMappingRequest>,
) -> Result<models::SamlSourcePropertyMapping, Error<PropertymappingsSourceSamlPartialUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_pm_uuid = pm_uuid;
    let p_patched_saml_source_property_mapping_request = patched_saml_source_property_mapping_request;

    let uri_str = format!(
        "{}/propertymappings/source/saml/{pm_uuid}/",
        configuration.base_path,
        pm_uuid = crate::apis::urlencode(p_pm_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_patched_saml_source_property_mapping_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SamlSourcePropertyMapping`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SamlSourcePropertyMapping`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsSourceSamlPartialUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// SAMLSourcePropertyMapping Viewset
pub async fn propertymappings_source_saml_retrieve(
    configuration: &configuration::Configuration,
    pm_uuid: &str,
) -> Result<models::SamlSourcePropertyMapping, Error<PropertymappingsSourceSamlRetrieveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_pm_uuid = pm_uuid;

    let uri_str = format!(
        "{}/propertymappings/source/saml/{pm_uuid}/",
        configuration.base_path,
        pm_uuid = crate::apis::urlencode(p_pm_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SamlSourcePropertyMapping`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SamlSourcePropertyMapping`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsSourceSamlRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// SAMLSourcePropertyMapping Viewset
pub async fn propertymappings_source_saml_update(
    configuration: &configuration::Configuration,
    pm_uuid: &str,
    saml_source_property_mapping_request: models::SamlSourcePropertyMappingRequest,
) -> Result<models::SamlSourcePropertyMapping, Error<PropertymappingsSourceSamlUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_pm_uuid = pm_uuid;
    let p_saml_source_property_mapping_request = saml_source_property_mapping_request;

    let uri_str = format!(
        "{}/propertymappings/source/saml/{pm_uuid}/",
        configuration.base_path,
        pm_uuid = crate::apis::urlencode(p_pm_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_saml_source_property_mapping_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::SamlSourcePropertyMapping`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::SamlSourcePropertyMapping`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsSourceSamlUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get a list of all objects that use this object
pub async fn propertymappings_source_saml_used_by_list(
    configuration: &configuration::Configuration,
    pm_uuid: &str,
) -> Result<Vec<models::UsedBy>, Error<PropertymappingsSourceSamlUsedByListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_pm_uuid = pm_uuid;

    let uri_str = format!(
        "{}/propertymappings/source/saml/{pm_uuid}/used_by/",
        configuration.base_path,
        pm_uuid = crate::apis::urlencode(p_pm_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsSourceSamlUsedByListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// SCIMSourcePropertyMapping Viewset
pub async fn propertymappings_source_scim_create(
    configuration: &configuration::Configuration,
    scim_source_property_mapping_request: models::ScimSourcePropertyMappingRequest,
) -> Result<models::ScimSourcePropertyMapping, Error<PropertymappingsSourceScimCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_scim_source_property_mapping_request = scim_source_property_mapping_request;

    let uri_str = format!("{}/propertymappings/source/scim/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_scim_source_property_mapping_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ScimSourcePropertyMapping`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ScimSourcePropertyMapping`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsSourceScimCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// SCIMSourcePropertyMapping Viewset
pub async fn propertymappings_source_scim_destroy(
    configuration: &configuration::Configuration,
    pm_uuid: &str,
) -> Result<(), Error<PropertymappingsSourceScimDestroyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_pm_uuid = pm_uuid;

    let uri_str = format!(
        "{}/propertymappings/source/scim/{pm_uuid}/",
        configuration.base_path,
        pm_uuid = crate::apis::urlencode(p_pm_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsSourceScimDestroyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// SCIMSourcePropertyMapping Viewset
pub async fn propertymappings_source_scim_list(
    configuration: &configuration::Configuration,
    managed: Option<Vec<String>>,
    managed__isnull: Option<bool>,
    name: Option<&str>,
    ordering: Option<&str>,
    page: Option<i32>,
    page_size: Option<i32>,
    search: Option<&str>,
) -> Result<models::PaginatedScimSourcePropertyMappingList, Error<PropertymappingsSourceScimListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_managed = managed;
    let p_managed__isnull = managed__isnull;
    let p_name = name;
    let p_ordering = ordering;
    let p_page = page;
    let p_page_size = page_size;
    let p_search = search;

    let uri_str = format!("{}/propertymappings/source/scim/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_managed {
        req_builder = match "multi" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("managed".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "managed",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = p_managed__isnull {
        req_builder = req_builder.query(&[("managed__isnull", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_ordering {
        req_builder = req_builder.query(&[("ordering", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page_size {
        req_builder = req_builder.query(&[("page_size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_search {
        req_builder = req_builder.query(&[("search", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginatedScimSourcePropertyMappingList`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginatedScimSourcePropertyMappingList`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsSourceScimListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// SCIMSourcePropertyMapping Viewset
pub async fn propertymappings_source_scim_partial_update(
    configuration: &configuration::Configuration,
    pm_uuid: &str,
    patched_scim_source_property_mapping_request: Option<models::PatchedScimSourcePropertyMappingRequest>,
) -> Result<models::ScimSourcePropertyMapping, Error<PropertymappingsSourceScimPartialUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_pm_uuid = pm_uuid;
    let p_patched_scim_source_property_mapping_request = patched_scim_source_property_mapping_request;

    let uri_str = format!(
        "{}/propertymappings/source/scim/{pm_uuid}/",
        configuration.base_path,
        pm_uuid = crate::apis::urlencode(p_pm_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_patched_scim_source_property_mapping_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ScimSourcePropertyMapping`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ScimSourcePropertyMapping`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsSourceScimPartialUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// SCIMSourcePropertyMapping Viewset
pub async fn propertymappings_source_scim_retrieve(
    configuration: &configuration::Configuration,
    pm_uuid: &str,
) -> Result<models::ScimSourcePropertyMapping, Error<PropertymappingsSourceScimRetrieveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_pm_uuid = pm_uuid;

    let uri_str = format!(
        "{}/propertymappings/source/scim/{pm_uuid}/",
        configuration.base_path,
        pm_uuid = crate::apis::urlencode(p_pm_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ScimSourcePropertyMapping`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ScimSourcePropertyMapping`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsSourceScimRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// SCIMSourcePropertyMapping Viewset
pub async fn propertymappings_source_scim_update(
    configuration: &configuration::Configuration,
    pm_uuid: &str,
    scim_source_property_mapping_request: models::ScimSourcePropertyMappingRequest,
) -> Result<models::ScimSourcePropertyMapping, Error<PropertymappingsSourceScimUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_pm_uuid = pm_uuid;
    let p_scim_source_property_mapping_request = scim_source_property_mapping_request;

    let uri_str = format!(
        "{}/propertymappings/source/scim/{pm_uuid}/",
        configuration.base_path,
        pm_uuid = crate::apis::urlencode(p_pm_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_scim_source_property_mapping_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ScimSourcePropertyMapping`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ScimSourcePropertyMapping`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsSourceScimUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get a list of all objects that use this object
pub async fn propertymappings_source_scim_used_by_list(
    configuration: &configuration::Configuration,
    pm_uuid: &str,
) -> Result<Vec<models::UsedBy>, Error<PropertymappingsSourceScimUsedByListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_pm_uuid = pm_uuid;

    let uri_str = format!(
        "{}/propertymappings/source/scim/{pm_uuid}/used_by/",
        configuration.base_path,
        pm_uuid = crate::apis::urlencode(p_pm_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PropertymappingsSourceScimUsedByListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
