/*
 * authentik
 *
 * Making authentication simple.
 *
 * The version of the OpenAPI document: 2025.12.3
 * Contact: hello@goauthentik.io
 * Generated by: https://openapi-generator.tech
 */

use super::{configuration, ContentType, Error};
use crate::{apis::ResponseContent, models};
use reqwest;
use serde::{de::Error as _, Deserialize, Serialize};

/// struct for typed errors of method [`events_events_actions_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EventsEventsActionsListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`events_events_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EventsEventsCreateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`events_events_destroy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EventsEventsDestroyError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`events_events_export_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EventsEventsExportCreateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`events_events_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EventsEventsListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`events_events_partial_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EventsEventsPartialUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`events_events_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EventsEventsRetrieveError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`events_events_top_per_user_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EventsEventsTopPerUserListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`events_events_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EventsEventsUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`events_events_volume_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EventsEventsVolumeListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`events_notifications_destroy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EventsNotificationsDestroyError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`events_notifications_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EventsNotificationsListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`events_notifications_mark_all_seen_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EventsNotificationsMarkAllSeenCreateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`events_notifications_partial_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EventsNotificationsPartialUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`events_notifications_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EventsNotificationsRetrieveError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`events_notifications_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EventsNotificationsUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`events_notifications_used_by_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EventsNotificationsUsedByListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`events_rules_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EventsRulesCreateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`events_rules_destroy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EventsRulesDestroyError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`events_rules_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EventsRulesListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`events_rules_partial_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EventsRulesPartialUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`events_rules_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EventsRulesRetrieveError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`events_rules_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EventsRulesUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`events_rules_used_by_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EventsRulesUsedByListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`events_transports_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EventsTransportsCreateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`events_transports_destroy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EventsTransportsDestroyError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`events_transports_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EventsTransportsListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`events_transports_partial_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EventsTransportsPartialUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`events_transports_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EventsTransportsRetrieveError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`events_transports_test_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EventsTransportsTestCreateError {
    Status500(),
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`events_transports_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EventsTransportsUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`events_transports_used_by_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EventsTransportsUsedByListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// Get all actions
pub async fn events_events_actions_list(
    configuration: &configuration::Configuration,
) -> Result<Vec<models::TypeCreate>, Error<EventsEventsActionsListError>> {
    let uri_str = format!("{}/events/events/actions/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::TypeCreate&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::TypeCreate&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EventsEventsActionsListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Event Read-Only Viewset
pub async fn events_events_create(
    configuration: &configuration::Configuration,
    event_request: models::EventRequest,
) -> Result<models::Event, Error<EventsEventsCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_event_request = event_request;

    let uri_str = format!("{}/events/events/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_event_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::Event`",
                )))
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::Event`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EventsEventsCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Event Read-Only Viewset
pub async fn events_events_destroy(
    configuration: &configuration::Configuration,
    event_uuid: &str,
) -> Result<(), Error<EventsEventsDestroyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_event_uuid = event_uuid;

    let uri_str = format!(
        "{}/events/events/{event_uuid}/",
        configuration.base_path,
        event_uuid = crate::apis::urlencode(p_path_event_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<EventsEventsDestroyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Create a data export for this data type. Note that the export is generated asynchronously: this method returns a `DataExport` object that will initially have `completed=false` as well as the permanent URL to that object in the `Location` header. You can poll that URL until `completed=true`, at which point the `file_url` property will contain a URL to download
pub async fn events_events_export_create(
    configuration: &configuration::Configuration,
    action: Option<&str>,
    actions: Option<Vec<String>>,
    brand_name: Option<&str>,
    client_ip: Option<&str>,
    context_authorized_app: Option<&str>,
    context_model_app: Option<&str>,
    context_model_name: Option<&str>,
    context_model_pk: Option<&str>,
    ordering: Option<&str>,
    search: Option<&str>,
    username: Option<&str>,
) -> Result<models::DataExport, Error<EventsEventsExportCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_action = action;
    let p_query_actions = actions;
    let p_query_brand_name = brand_name;
    let p_query_client_ip = client_ip;
    let p_query_context_authorized_app = context_authorized_app;
    let p_query_context_model_app = context_model_app;
    let p_query_context_model_name = context_model_name;
    let p_query_context_model_pk = context_model_pk;
    let p_query_ordering = ordering;
    let p_query_search = search;
    let p_query_username = username;

    let uri_str = format!("{}/events/events/export/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref param_value) = p_query_action {
        req_builder = req_builder.query(&[("action", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_actions {
        req_builder = match "multi" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("actions".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "actions",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = p_query_brand_name {
        req_builder = req_builder.query(&[("brand_name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_client_ip {
        req_builder = req_builder.query(&[("client_ip", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_context_authorized_app {
        req_builder = req_builder.query(&[("context_authorized_app", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_context_model_app {
        req_builder = req_builder.query(&[("context_model_app", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_context_model_name {
        req_builder = req_builder.query(&[("context_model_name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_context_model_pk {
        req_builder = req_builder.query(&[("context_model_pk", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ordering {
        req_builder = req_builder.query(&[("ordering", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_search {
        req_builder = req_builder.query(&[("search", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_username {
        req_builder = req_builder.query(&[("username", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::DataExport`",
                )))
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::DataExport`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EventsEventsExportCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Event Read-Only Viewset
pub async fn events_events_list(
    configuration: &configuration::Configuration,
    action: Option<&str>,
    actions: Option<Vec<String>>,
    brand_name: Option<&str>,
    client_ip: Option<&str>,
    context_authorized_app: Option<&str>,
    context_model_app: Option<&str>,
    context_model_name: Option<&str>,
    context_model_pk: Option<&str>,
    ordering: Option<&str>,
    page: Option<i32>,
    page_size: Option<i32>,
    search: Option<&str>,
    username: Option<&str>,
) -> Result<models::PaginatedEventList, Error<EventsEventsListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_action = action;
    let p_query_actions = actions;
    let p_query_brand_name = brand_name;
    let p_query_client_ip = client_ip;
    let p_query_context_authorized_app = context_authorized_app;
    let p_query_context_model_app = context_model_app;
    let p_query_context_model_name = context_model_name;
    let p_query_context_model_pk = context_model_pk;
    let p_query_ordering = ordering;
    let p_query_page = page;
    let p_query_page_size = page_size;
    let p_query_search = search;
    let p_query_username = username;

    let uri_str = format!("{}/events/events/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_action {
        req_builder = req_builder.query(&[("action", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_actions {
        req_builder = match "multi" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("actions".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "actions",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = p_query_brand_name {
        req_builder = req_builder.query(&[("brand_name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_client_ip {
        req_builder = req_builder.query(&[("client_ip", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_context_authorized_app {
        req_builder = req_builder.query(&[("context_authorized_app", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_context_model_app {
        req_builder = req_builder.query(&[("context_model_app", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_context_model_name {
        req_builder = req_builder.query(&[("context_model_name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_context_model_pk {
        req_builder = req_builder.query(&[("context_model_pk", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ordering {
        req_builder = req_builder.query(&[("ordering", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page_size {
        req_builder = req_builder.query(&[("page_size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_search {
        req_builder = req_builder.query(&[("search", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_username {
        req_builder = req_builder.query(&[("username", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginatedEventList`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginatedEventList`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EventsEventsListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Event Read-Only Viewset
pub async fn events_events_partial_update(
    configuration: &configuration::Configuration,
    event_uuid: &str,
    patched_event_request: Option<models::PatchedEventRequest>,
) -> Result<models::Event, Error<EventsEventsPartialUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_event_uuid = event_uuid;
    let p_body_patched_event_request = patched_event_request;

    let uri_str = format!(
        "{}/events/events/{event_uuid}/",
        configuration.base_path,
        event_uuid = crate::apis::urlencode(p_path_event_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_patched_event_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::Event`",
                )))
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::Event`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EventsEventsPartialUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Event Read-Only Viewset
pub async fn events_events_retrieve(
    configuration: &configuration::Configuration,
    event_uuid: &str,
) -> Result<models::Event, Error<EventsEventsRetrieveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_event_uuid = event_uuid;

    let uri_str = format!(
        "{}/events/events/{event_uuid}/",
        configuration.base_path,
        event_uuid = crate::apis::urlencode(p_path_event_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::Event`",
                )))
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::Event`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EventsEventsRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get the top_n events grouped by user count
pub async fn events_events_top_per_user_list(
    configuration: &configuration::Configuration,
    action: Option<&str>,
    top_n: Option<i32>,
) -> Result<Vec<models::EventTopPerUser>, Error<EventsEventsTopPerUserListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_action = action;
    let p_query_top_n = top_n;

    let uri_str = format!("{}/events/events/top_per_user/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_action {
        req_builder = req_builder.query(&[("action", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_top_n {
        req_builder = req_builder.query(&[("top_n", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::EventTopPerUser&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::EventTopPerUser&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EventsEventsTopPerUserListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Event Read-Only Viewset
pub async fn events_events_update(
    configuration: &configuration::Configuration,
    event_uuid: &str,
    event_request: models::EventRequest,
) -> Result<models::Event, Error<EventsEventsUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_event_uuid = event_uuid;
    let p_body_event_request = event_request;

    let uri_str = format!(
        "{}/events/events/{event_uuid}/",
        configuration.base_path,
        event_uuid = crate::apis::urlencode(p_path_event_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_event_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::Event`",
                )))
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::Event`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EventsEventsUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get event volume for specified filters and timeframe
pub async fn events_events_volume_list(
    configuration: &configuration::Configuration,
    action: Option<&str>,
    actions: Option<Vec<String>>,
    brand_name: Option<&str>,
    client_ip: Option<&str>,
    context_authorized_app: Option<&str>,
    context_model_app: Option<&str>,
    context_model_name: Option<&str>,
    context_model_pk: Option<&str>,
    history_days: Option<f64>,
    ordering: Option<&str>,
    search: Option<&str>,
    username: Option<&str>,
) -> Result<Vec<models::EventVolume>, Error<EventsEventsVolumeListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_action = action;
    let p_query_actions = actions;
    let p_query_brand_name = brand_name;
    let p_query_client_ip = client_ip;
    let p_query_context_authorized_app = context_authorized_app;
    let p_query_context_model_app = context_model_app;
    let p_query_context_model_name = context_model_name;
    let p_query_context_model_pk = context_model_pk;
    let p_query_history_days = history_days;
    let p_query_ordering = ordering;
    let p_query_search = search;
    let p_query_username = username;

    let uri_str = format!("{}/events/events/volume/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_action {
        req_builder = req_builder.query(&[("action", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_actions {
        req_builder = match "multi" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("actions".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "actions",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = p_query_brand_name {
        req_builder = req_builder.query(&[("brand_name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_client_ip {
        req_builder = req_builder.query(&[("client_ip", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_context_authorized_app {
        req_builder = req_builder.query(&[("context_authorized_app", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_context_model_app {
        req_builder = req_builder.query(&[("context_model_app", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_context_model_name {
        req_builder = req_builder.query(&[("context_model_name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_context_model_pk {
        req_builder = req_builder.query(&[("context_model_pk", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_history_days {
        req_builder = req_builder.query(&[("history_days", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ordering {
        req_builder = req_builder.query(&[("ordering", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_search {
        req_builder = req_builder.query(&[("search", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_username {
        req_builder = req_builder.query(&[("username", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::EventVolume&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::EventVolume&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EventsEventsVolumeListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Notification Viewset
pub async fn events_notifications_destroy(
    configuration: &configuration::Configuration,
    uuid: &str,
) -> Result<(), Error<EventsNotificationsDestroyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_uuid = uuid;

    let uri_str = format!(
        "{}/events/notifications/{uuid}/",
        configuration.base_path,
        uuid = crate::apis::urlencode(p_path_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<EventsNotificationsDestroyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Notification Viewset
pub async fn events_notifications_list(
    configuration: &configuration::Configuration,
    body: Option<&str>,
    created: Option<String>,
    event: Option<&str>,
    ordering: Option<&str>,
    page: Option<i32>,
    page_size: Option<i32>,
    search: Option<&str>,
    seen: Option<bool>,
    severity: Option<&str>,
    user: Option<i32>,
) -> Result<models::PaginatedNotificationList, Error<EventsNotificationsListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_body = body;
    let p_query_created = created;
    let p_query_event = event;
    let p_query_ordering = ordering;
    let p_query_page = page;
    let p_query_page_size = page_size;
    let p_query_search = search;
    let p_query_seen = seen;
    let p_query_severity = severity;
    let p_query_user = user;

    let uri_str = format!("{}/events/notifications/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_body {
        req_builder = req_builder.query(&[("body", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_created {
        req_builder = req_builder.query(&[("created", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_event {
        req_builder = req_builder.query(&[("event", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ordering {
        req_builder = req_builder.query(&[("ordering", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page_size {
        req_builder = req_builder.query(&[("page_size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_search {
        req_builder = req_builder.query(&[("search", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_seen {
        req_builder = req_builder.query(&[("seen", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_severity {
        req_builder = req_builder.query(&[("severity", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_user {
        req_builder = req_builder.query(&[("user", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginatedNotificationList`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginatedNotificationList`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EventsNotificationsListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Mark all the user's notifications as seen
pub async fn events_notifications_mark_all_seen_create(
    configuration: &configuration::Configuration,
) -> Result<(), Error<EventsNotificationsMarkAllSeenCreateError>> {
    let uri_str = format!("{}/events/notifications/mark_all_seen/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<EventsNotificationsMarkAllSeenCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Notification Viewset
pub async fn events_notifications_partial_update(
    configuration: &configuration::Configuration,
    uuid: &str,
    patched_notification_request: Option<models::PatchedNotificationRequest>,
) -> Result<models::Notification, Error<EventsNotificationsPartialUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_uuid = uuid;
    let p_body_patched_notification_request = patched_notification_request;

    let uri_str = format!(
        "{}/events/notifications/{uuid}/",
        configuration.base_path,
        uuid = crate::apis::urlencode(p_path_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_patched_notification_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::Notification`",
                )))
            }
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!(
                "Received `{unknown_type}` content type response that cannot be converted to `models::Notification`"
            )))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EventsNotificationsPartialUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Notification Viewset
pub async fn events_notifications_retrieve(
    configuration: &configuration::Configuration,
    uuid: &str,
) -> Result<models::Notification, Error<EventsNotificationsRetrieveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_uuid = uuid;

    let uri_str = format!(
        "{}/events/notifications/{uuid}/",
        configuration.base_path,
        uuid = crate::apis::urlencode(p_path_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::Notification`",
                )))
            }
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!(
                "Received `{unknown_type}` content type response that cannot be converted to `models::Notification`"
            )))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EventsNotificationsRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Notification Viewset
pub async fn events_notifications_update(
    configuration: &configuration::Configuration,
    uuid: &str,
    notification_request: Option<models::NotificationRequest>,
) -> Result<models::Notification, Error<EventsNotificationsUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_uuid = uuid;
    let p_body_notification_request = notification_request;

    let uri_str = format!(
        "{}/events/notifications/{uuid}/",
        configuration.base_path,
        uuid = crate::apis::urlencode(p_path_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_notification_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::Notification`",
                )))
            }
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!(
                "Received `{unknown_type}` content type response that cannot be converted to `models::Notification`"
            )))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EventsNotificationsUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get a list of all objects that use this object
pub async fn events_notifications_used_by_list(
    configuration: &configuration::Configuration,
    uuid: &str,
) -> Result<Vec<models::UsedBy>, Error<EventsNotificationsUsedByListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_uuid = uuid;

    let uri_str = format!(
        "{}/events/notifications/{uuid}/used_by/",
        configuration.base_path,
        uuid = crate::apis::urlencode(p_path_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EventsNotificationsUsedByListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// NotificationRule Viewset
pub async fn events_rules_create(
    configuration: &configuration::Configuration,
    notification_rule_request: models::NotificationRuleRequest,
) -> Result<models::NotificationRule, Error<EventsRulesCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_notification_rule_request = notification_rule_request;

    let uri_str = format!("{}/events/rules/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_notification_rule_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::NotificationRule`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::NotificationRule`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EventsRulesCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// NotificationRule Viewset
pub async fn events_rules_destroy(
    configuration: &configuration::Configuration,
    pbm_uuid: &str,
) -> Result<(), Error<EventsRulesDestroyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_pbm_uuid = pbm_uuid;

    let uri_str = format!(
        "{}/events/rules/{pbm_uuid}/",
        configuration.base_path,
        pbm_uuid = crate::apis::urlencode(p_path_pbm_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<EventsRulesDestroyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// NotificationRule Viewset
pub async fn events_rules_list(
    configuration: &configuration::Configuration,
    destination_group__name: Option<&str>,
    name: Option<&str>,
    ordering: Option<&str>,
    page: Option<i32>,
    page_size: Option<i32>,
    search: Option<&str>,
    severity: Option<&str>,
) -> Result<models::PaginatedNotificationRuleList, Error<EventsRulesListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_destination_group__name = destination_group__name;
    let p_query_name = name;
    let p_query_ordering = ordering;
    let p_query_page = page;
    let p_query_page_size = page_size;
    let p_query_search = search;
    let p_query_severity = severity;

    let uri_str = format!("{}/events/rules/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_destination_group__name {
        req_builder = req_builder.query(&[("destination_group__name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ordering {
        req_builder = req_builder.query(&[("ordering", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page_size {
        req_builder = req_builder.query(&[("page_size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_search {
        req_builder = req_builder.query(&[("search", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_severity {
        req_builder = req_builder.query(&[("severity", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginatedNotificationRuleList`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginatedNotificationRuleList`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EventsRulesListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// NotificationRule Viewset
pub async fn events_rules_partial_update(
    configuration: &configuration::Configuration,
    pbm_uuid: &str,
    patched_notification_rule_request: Option<models::PatchedNotificationRuleRequest>,
) -> Result<models::NotificationRule, Error<EventsRulesPartialUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_pbm_uuid = pbm_uuid;
    let p_body_patched_notification_rule_request = patched_notification_rule_request;

    let uri_str = format!(
        "{}/events/rules/{pbm_uuid}/",
        configuration.base_path,
        pbm_uuid = crate::apis::urlencode(p_path_pbm_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_patched_notification_rule_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::NotificationRule`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::NotificationRule`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EventsRulesPartialUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// NotificationRule Viewset
pub async fn events_rules_retrieve(
    configuration: &configuration::Configuration,
    pbm_uuid: &str,
) -> Result<models::NotificationRule, Error<EventsRulesRetrieveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_pbm_uuid = pbm_uuid;

    let uri_str = format!(
        "{}/events/rules/{pbm_uuid}/",
        configuration.base_path,
        pbm_uuid = crate::apis::urlencode(p_path_pbm_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::NotificationRule`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::NotificationRule`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EventsRulesRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// NotificationRule Viewset
pub async fn events_rules_update(
    configuration: &configuration::Configuration,
    pbm_uuid: &str,
    notification_rule_request: models::NotificationRuleRequest,
) -> Result<models::NotificationRule, Error<EventsRulesUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_pbm_uuid = pbm_uuid;
    let p_body_notification_rule_request = notification_rule_request;

    let uri_str = format!(
        "{}/events/rules/{pbm_uuid}/",
        configuration.base_path,
        pbm_uuid = crate::apis::urlencode(p_path_pbm_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_notification_rule_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::NotificationRule`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::NotificationRule`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EventsRulesUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get a list of all objects that use this object
pub async fn events_rules_used_by_list(
    configuration: &configuration::Configuration,
    pbm_uuid: &str,
) -> Result<Vec<models::UsedBy>, Error<EventsRulesUsedByListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_pbm_uuid = pbm_uuid;

    let uri_str = format!(
        "{}/events/rules/{pbm_uuid}/used_by/",
        configuration.base_path,
        pbm_uuid = crate::apis::urlencode(p_path_pbm_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EventsRulesUsedByListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// NotificationTransport Viewset
pub async fn events_transports_create(
    configuration: &configuration::Configuration,
    notification_transport_request: models::NotificationTransportRequest,
) -> Result<models::NotificationTransport, Error<EventsTransportsCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_notification_transport_request = notification_transport_request;

    let uri_str = format!("{}/events/transports/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_notification_transport_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::NotificationTransport`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::NotificationTransport`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EventsTransportsCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// NotificationTransport Viewset
pub async fn events_transports_destroy(
    configuration: &configuration::Configuration,
    uuid: &str,
) -> Result<(), Error<EventsTransportsDestroyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_uuid = uuid;

    let uri_str = format!(
        "{}/events/transports/{uuid}/",
        configuration.base_path,
        uuid = crate::apis::urlencode(p_path_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<EventsTransportsDestroyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// NotificationTransport Viewset
pub async fn events_transports_list(
    configuration: &configuration::Configuration,
    mode: Option<&str>,
    name: Option<&str>,
    ordering: Option<&str>,
    page: Option<i32>,
    page_size: Option<i32>,
    search: Option<&str>,
    send_once: Option<bool>,
    webhook_url: Option<&str>,
) -> Result<models::PaginatedNotificationTransportList, Error<EventsTransportsListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_mode = mode;
    let p_query_name = name;
    let p_query_ordering = ordering;
    let p_query_page = page;
    let p_query_page_size = page_size;
    let p_query_search = search;
    let p_query_send_once = send_once;
    let p_query_webhook_url = webhook_url;

    let uri_str = format!("{}/events/transports/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_mode {
        req_builder = req_builder.query(&[("mode", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ordering {
        req_builder = req_builder.query(&[("ordering", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page_size {
        req_builder = req_builder.query(&[("page_size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_search {
        req_builder = req_builder.query(&[("search", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_send_once {
        req_builder = req_builder.query(&[("send_once", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_webhook_url {
        req_builder = req_builder.query(&[("webhook_url", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginatedNotificationTransportList`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginatedNotificationTransportList`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EventsTransportsListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// NotificationTransport Viewset
pub async fn events_transports_partial_update(
    configuration: &configuration::Configuration,
    uuid: &str,
    patched_notification_transport_request: Option<models::PatchedNotificationTransportRequest>,
) -> Result<models::NotificationTransport, Error<EventsTransportsPartialUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_uuid = uuid;
    let p_body_patched_notification_transport_request = patched_notification_transport_request;

    let uri_str = format!(
        "{}/events/transports/{uuid}/",
        configuration.base_path,
        uuid = crate::apis::urlencode(p_path_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_patched_notification_transport_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::NotificationTransport`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::NotificationTransport`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EventsTransportsPartialUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// NotificationTransport Viewset
pub async fn events_transports_retrieve(
    configuration: &configuration::Configuration,
    uuid: &str,
) -> Result<models::NotificationTransport, Error<EventsTransportsRetrieveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_uuid = uuid;

    let uri_str = format!(
        "{}/events/transports/{uuid}/",
        configuration.base_path,
        uuid = crate::apis::urlencode(p_path_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::NotificationTransport`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::NotificationTransport`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EventsTransportsRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Send example notification using selected transport. Requires Modify permissions.
pub async fn events_transports_test_create(
    configuration: &configuration::Configuration,
    uuid: &str,
) -> Result<models::NotificationTransportTest, Error<EventsTransportsTestCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_uuid = uuid;

    let uri_str = format!(
        "{}/events/transports/{uuid}/test/",
        configuration.base_path,
        uuid = crate::apis::urlencode(p_path_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::NotificationTransportTest`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::NotificationTransportTest`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EventsTransportsTestCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// NotificationTransport Viewset
pub async fn events_transports_update(
    configuration: &configuration::Configuration,
    uuid: &str,
    notification_transport_request: models::NotificationTransportRequest,
) -> Result<models::NotificationTransport, Error<EventsTransportsUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_uuid = uuid;
    let p_body_notification_transport_request = notification_transport_request;

    let uri_str = format!(
        "{}/events/transports/{uuid}/",
        configuration.base_path,
        uuid = crate::apis::urlencode(p_path_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_notification_transport_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::NotificationTransport`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::NotificationTransport`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EventsTransportsUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get a list of all objects that use this object
pub async fn events_transports_used_by_list(
    configuration: &configuration::Configuration,
    uuid: &str,
) -> Result<Vec<models::UsedBy>, Error<EventsTransportsUsedByListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_uuid = uuid;

    let uri_str = format!(
        "{}/events/transports/{uuid}/used_by/",
        configuration.base_path,
        uuid = crate::apis::urlencode(p_path_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<EventsTransportsUsedByListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
