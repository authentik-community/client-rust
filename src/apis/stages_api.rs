/*
 * authentik
 *
 * Making authentication simple.
 *
 * The version of the OpenAPI document: 2025.6.4
 * Contact: hello@goauthentik.io
 * Generated by: https://openapi-generator.tech
 */

use super::{configuration, ContentType, Error};
use crate::{apis::ResponseContent, models};
use reqwest;
use serde::{de::Error as _, Deserialize, Serialize};

/// struct for typed errors of method [`stages_all_destroy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesAllDestroyError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_all_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesAllListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_all_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesAllRetrieveError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_all_types_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesAllTypesListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_all_used_by_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesAllUsedByListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_all_user_settings_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesAllUserSettingsListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_authenticator_duo_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesAuthenticatorDuoCreateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_authenticator_duo_destroy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesAuthenticatorDuoDestroyError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_authenticator_duo_enrollment_status_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesAuthenticatorDuoEnrollmentStatusCreateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_authenticator_duo_import_device_manual_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesAuthenticatorDuoImportDeviceManualCreateError {
    Status400(),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_authenticator_duo_import_devices_automatic_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesAuthenticatorDuoImportDevicesAutomaticCreateError {
    Status400(),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_authenticator_duo_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesAuthenticatorDuoListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_authenticator_duo_partial_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesAuthenticatorDuoPartialUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_authenticator_duo_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesAuthenticatorDuoRetrieveError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_authenticator_duo_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesAuthenticatorDuoUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_authenticator_duo_used_by_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesAuthenticatorDuoUsedByListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_authenticator_email_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesAuthenticatorEmailCreateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_authenticator_email_destroy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesAuthenticatorEmailDestroyError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_authenticator_email_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesAuthenticatorEmailListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_authenticator_email_partial_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesAuthenticatorEmailPartialUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_authenticator_email_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesAuthenticatorEmailRetrieveError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_authenticator_email_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesAuthenticatorEmailUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_authenticator_email_used_by_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesAuthenticatorEmailUsedByListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_authenticator_endpoint_gdtc_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesAuthenticatorEndpointGdtcCreateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_authenticator_endpoint_gdtc_destroy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesAuthenticatorEndpointGdtcDestroyError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_authenticator_endpoint_gdtc_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesAuthenticatorEndpointGdtcListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_authenticator_endpoint_gdtc_partial_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesAuthenticatorEndpointGdtcPartialUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_authenticator_endpoint_gdtc_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesAuthenticatorEndpointGdtcRetrieveError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_authenticator_endpoint_gdtc_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesAuthenticatorEndpointGdtcUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_authenticator_endpoint_gdtc_used_by_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesAuthenticatorEndpointGdtcUsedByListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_authenticator_sms_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesAuthenticatorSmsCreateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_authenticator_sms_destroy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesAuthenticatorSmsDestroyError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_authenticator_sms_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesAuthenticatorSmsListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_authenticator_sms_partial_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesAuthenticatorSmsPartialUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_authenticator_sms_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesAuthenticatorSmsRetrieveError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_authenticator_sms_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesAuthenticatorSmsUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_authenticator_sms_used_by_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesAuthenticatorSmsUsedByListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_authenticator_static_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesAuthenticatorStaticCreateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_authenticator_static_destroy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesAuthenticatorStaticDestroyError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_authenticator_static_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesAuthenticatorStaticListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_authenticator_static_partial_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesAuthenticatorStaticPartialUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_authenticator_static_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesAuthenticatorStaticRetrieveError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_authenticator_static_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesAuthenticatorStaticUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_authenticator_static_used_by_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesAuthenticatorStaticUsedByListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_authenticator_totp_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesAuthenticatorTotpCreateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_authenticator_totp_destroy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesAuthenticatorTotpDestroyError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_authenticator_totp_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesAuthenticatorTotpListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_authenticator_totp_partial_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesAuthenticatorTotpPartialUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_authenticator_totp_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesAuthenticatorTotpRetrieveError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_authenticator_totp_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesAuthenticatorTotpUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_authenticator_totp_used_by_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesAuthenticatorTotpUsedByListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_authenticator_validate_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesAuthenticatorValidateCreateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_authenticator_validate_destroy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesAuthenticatorValidateDestroyError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_authenticator_validate_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesAuthenticatorValidateListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_authenticator_validate_partial_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesAuthenticatorValidatePartialUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_authenticator_validate_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesAuthenticatorValidateRetrieveError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_authenticator_validate_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesAuthenticatorValidateUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_authenticator_validate_used_by_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesAuthenticatorValidateUsedByListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_authenticator_webauthn_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesAuthenticatorWebauthnCreateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_authenticator_webauthn_destroy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesAuthenticatorWebauthnDestroyError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_authenticator_webauthn_device_types_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesAuthenticatorWebauthnDeviceTypesListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_authenticator_webauthn_device_types_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesAuthenticatorWebauthnDeviceTypesRetrieveError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_authenticator_webauthn_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesAuthenticatorWebauthnListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_authenticator_webauthn_partial_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesAuthenticatorWebauthnPartialUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_authenticator_webauthn_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesAuthenticatorWebauthnRetrieveError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_authenticator_webauthn_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesAuthenticatorWebauthnUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_authenticator_webauthn_used_by_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesAuthenticatorWebauthnUsedByListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_captcha_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesCaptchaCreateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_captcha_destroy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesCaptchaDestroyError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_captcha_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesCaptchaListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_captcha_partial_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesCaptchaPartialUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_captcha_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesCaptchaRetrieveError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_captcha_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesCaptchaUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_captcha_used_by_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesCaptchaUsedByListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_consent_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesConsentCreateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_consent_destroy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesConsentDestroyError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_consent_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesConsentListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_consent_partial_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesConsentPartialUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_consent_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesConsentRetrieveError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_consent_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesConsentUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_consent_used_by_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesConsentUsedByListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_deny_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesDenyCreateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_deny_destroy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesDenyDestroyError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_deny_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesDenyListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_deny_partial_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesDenyPartialUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_deny_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesDenyRetrieveError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_deny_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesDenyUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_deny_used_by_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesDenyUsedByListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_dummy_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesDummyCreateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_dummy_destroy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesDummyDestroyError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_dummy_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesDummyListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_dummy_partial_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesDummyPartialUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_dummy_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesDummyRetrieveError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_dummy_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesDummyUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_dummy_used_by_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesDummyUsedByListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_email_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesEmailCreateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_email_destroy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesEmailDestroyError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_email_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesEmailListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_email_partial_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesEmailPartialUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_email_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesEmailRetrieveError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_email_templates_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesEmailTemplatesListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_email_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesEmailUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_email_used_by_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesEmailUsedByListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_identification_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesIdentificationCreateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_identification_destroy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesIdentificationDestroyError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_identification_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesIdentificationListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_identification_partial_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesIdentificationPartialUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_identification_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesIdentificationRetrieveError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_identification_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesIdentificationUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_identification_used_by_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesIdentificationUsedByListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_invitation_invitations_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesInvitationInvitationsCreateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_invitation_invitations_destroy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesInvitationInvitationsDestroyError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_invitation_invitations_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesInvitationInvitationsListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_invitation_invitations_partial_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesInvitationInvitationsPartialUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_invitation_invitations_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesInvitationInvitationsRetrieveError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_invitation_invitations_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesInvitationInvitationsUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_invitation_invitations_used_by_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesInvitationInvitationsUsedByListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_invitation_stages_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesInvitationStagesCreateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_invitation_stages_destroy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesInvitationStagesDestroyError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_invitation_stages_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesInvitationStagesListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_invitation_stages_partial_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesInvitationStagesPartialUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_invitation_stages_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesInvitationStagesRetrieveError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_invitation_stages_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesInvitationStagesUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_invitation_stages_used_by_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesInvitationStagesUsedByListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_mtls_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesMtlsCreateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_mtls_destroy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesMtlsDestroyError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_mtls_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesMtlsListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_mtls_partial_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesMtlsPartialUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_mtls_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesMtlsRetrieveError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_mtls_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesMtlsUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_mtls_used_by_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesMtlsUsedByListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_password_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesPasswordCreateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_password_destroy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesPasswordDestroyError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_password_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesPasswordListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_password_partial_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesPasswordPartialUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_password_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesPasswordRetrieveError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_password_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesPasswordUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_password_used_by_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesPasswordUsedByListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_prompt_prompts_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesPromptPromptsCreateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_prompt_prompts_destroy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesPromptPromptsDestroyError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_prompt_prompts_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesPromptPromptsListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_prompt_prompts_partial_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesPromptPromptsPartialUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_prompt_prompts_preview_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesPromptPromptsPreviewCreateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_prompt_prompts_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesPromptPromptsRetrieveError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_prompt_prompts_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesPromptPromptsUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_prompt_prompts_used_by_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesPromptPromptsUsedByListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_prompt_stages_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesPromptStagesCreateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_prompt_stages_destroy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesPromptStagesDestroyError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_prompt_stages_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesPromptStagesListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_prompt_stages_partial_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesPromptStagesPartialUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_prompt_stages_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesPromptStagesRetrieveError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_prompt_stages_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesPromptStagesUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_prompt_stages_used_by_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesPromptStagesUsedByListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_redirect_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesRedirectCreateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_redirect_destroy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesRedirectDestroyError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_redirect_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesRedirectListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_redirect_partial_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesRedirectPartialUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_redirect_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesRedirectRetrieveError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_redirect_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesRedirectUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_redirect_used_by_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesRedirectUsedByListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_source_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesSourceCreateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_source_destroy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesSourceDestroyError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_source_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesSourceListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_source_partial_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesSourcePartialUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_source_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesSourceRetrieveError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_source_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesSourceUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_source_used_by_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesSourceUsedByListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_user_delete_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesUserDeleteCreateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_user_delete_destroy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesUserDeleteDestroyError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_user_delete_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesUserDeleteListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_user_delete_partial_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesUserDeletePartialUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_user_delete_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesUserDeleteRetrieveError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_user_delete_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesUserDeleteUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_user_delete_used_by_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesUserDeleteUsedByListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_user_login_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesUserLoginCreateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_user_login_destroy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesUserLoginDestroyError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_user_login_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesUserLoginListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_user_login_partial_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesUserLoginPartialUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_user_login_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesUserLoginRetrieveError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_user_login_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesUserLoginUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_user_login_used_by_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesUserLoginUsedByListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_user_logout_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesUserLogoutCreateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_user_logout_destroy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesUserLogoutDestroyError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_user_logout_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesUserLogoutListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_user_logout_partial_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesUserLogoutPartialUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_user_logout_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesUserLogoutRetrieveError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_user_logout_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesUserLogoutUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_user_logout_used_by_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesUserLogoutUsedByListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_user_write_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesUserWriteCreateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_user_write_destroy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesUserWriteDestroyError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_user_write_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesUserWriteListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_user_write_partial_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesUserWritePartialUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_user_write_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesUserWriteRetrieveError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_user_write_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesUserWriteUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stages_user_write_used_by_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StagesUserWriteUsedByListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// Stage Viewset
pub async fn stages_all_destroy(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
) -> Result<(), Error<StagesAllDestroyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;

    let uri_str = format!(
        "{}/stages/all/{stage_uuid}/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesAllDestroyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Stage Viewset
pub async fn stages_all_list(
    configuration: &configuration::Configuration,
    name: Option<&str>,
    ordering: Option<&str>,
    page: Option<i32>,
    page_size: Option<i32>,
    search: Option<&str>,
) -> Result<models::PaginatedStageList, Error<StagesAllListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_name = name;
    let p_query_ordering = ordering;
    let p_query_page = page;
    let p_query_page_size = page_size;
    let p_query_search = search;

    let uri_str = format!("{}/stages/all/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ordering {
        req_builder = req_builder.query(&[("ordering", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page_size {
        req_builder = req_builder.query(&[("page_size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_search {
        req_builder = req_builder.query(&[("search", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginatedStageList`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginatedStageList`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesAllListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Stage Viewset
pub async fn stages_all_retrieve(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
) -> Result<models::Stage, Error<StagesAllRetrieveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;

    let uri_str = format!(
        "{}/stages/all/{stage_uuid}/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::Stage`",
                )))
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::Stage`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesAllRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get all creatable types
pub async fn stages_all_types_list(
    configuration: &configuration::Configuration,
) -> Result<Vec<models::TypeCreate>, Error<StagesAllTypesListError>> {
    let uri_str = format!("{}/stages/all/types/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::TypeCreate&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::TypeCreate&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesAllTypesListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get a list of all objects that use this object
pub async fn stages_all_used_by_list(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
) -> Result<Vec<models::UsedBy>, Error<StagesAllUsedByListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;

    let uri_str = format!(
        "{}/stages/all/{stage_uuid}/used_by/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesAllUsedByListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get all stages the user can configure
pub async fn stages_all_user_settings_list(
    configuration: &configuration::Configuration,
) -> Result<Vec<models::UserSetting>, Error<StagesAllUserSettingsListError>> {
    let uri_str = format!("{}/stages/all/user_settings/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::UserSetting&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::UserSetting&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesAllUserSettingsListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// AuthenticatorDuoStage Viewset
pub async fn stages_authenticator_duo_create(
    configuration: &configuration::Configuration,
    authenticator_duo_stage_request: models::AuthenticatorDuoStageRequest,
) -> Result<models::AuthenticatorDuoStage, Error<StagesAuthenticatorDuoCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_authenticator_duo_stage_request = authenticator_duo_stage_request;

    let uri_str = format!("{}/stages/authenticator/duo/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_authenticator_duo_stage_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AuthenticatorDuoStage`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AuthenticatorDuoStage`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesAuthenticatorDuoCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// AuthenticatorDuoStage Viewset
pub async fn stages_authenticator_duo_destroy(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
) -> Result<(), Error<StagesAuthenticatorDuoDestroyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;

    let uri_str = format!(
        "{}/stages/authenticator/duo/{stage_uuid}/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesAuthenticatorDuoDestroyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Check enrollment status of user details in current session
pub async fn stages_authenticator_duo_enrollment_status_create(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
) -> Result<models::DuoDeviceEnrollmentStatus, Error<StagesAuthenticatorDuoEnrollmentStatusCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;

    let uri_str = format!(
        "{}/stages/authenticator/duo/{stage_uuid}/enrollment_status/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DuoDeviceEnrollmentStatus`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DuoDeviceEnrollmentStatus`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesAuthenticatorDuoEnrollmentStatusCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Import duo devices into authentik
pub async fn stages_authenticator_duo_import_device_manual_create(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
    authenticator_duo_stage_manual_device_import_request: models::AuthenticatorDuoStageManualDeviceImportRequest,
) -> Result<(), Error<StagesAuthenticatorDuoImportDeviceManualCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;
    let p_body_authenticator_duo_stage_manual_device_import_request =
        authenticator_duo_stage_manual_device_import_request;

    let uri_str = format!(
        "{}/stages/authenticator/duo/{stage_uuid}/import_device_manual/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_authenticator_duo_stage_manual_device_import_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesAuthenticatorDuoImportDeviceManualCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Import duo devices into authentik
pub async fn stages_authenticator_duo_import_devices_automatic_create(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
) -> Result<
    models::AuthenticatorDuoStageDeviceImportResponse,
    Error<StagesAuthenticatorDuoImportDevicesAutomaticCreateError>,
> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;

    let uri_str = format!(
        "{}/stages/authenticator/duo/{stage_uuid}/import_devices_automatic/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AuthenticatorDuoStageDeviceImportResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AuthenticatorDuoStageDeviceImportResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesAuthenticatorDuoImportDevicesAutomaticCreateError> =
            serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// AuthenticatorDuoStage Viewset
pub async fn stages_authenticator_duo_list(
    configuration: &configuration::Configuration,
    api_hostname: Option<&str>,
    client_id: Option<&str>,
    configure_flow: Option<&str>,
    name: Option<&str>,
    ordering: Option<&str>,
    page: Option<i32>,
    page_size: Option<i32>,
    search: Option<&str>,
) -> Result<models::PaginatedAuthenticatorDuoStageList, Error<StagesAuthenticatorDuoListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_api_hostname = api_hostname;
    let p_query_client_id = client_id;
    let p_query_configure_flow = configure_flow;
    let p_query_name = name;
    let p_query_ordering = ordering;
    let p_query_page = page;
    let p_query_page_size = page_size;
    let p_query_search = search;

    let uri_str = format!("{}/stages/authenticator/duo/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_api_hostname {
        req_builder = req_builder.query(&[("api_hostname", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_client_id {
        req_builder = req_builder.query(&[("client_id", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_configure_flow {
        req_builder = req_builder.query(&[("configure_flow", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ordering {
        req_builder = req_builder.query(&[("ordering", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page_size {
        req_builder = req_builder.query(&[("page_size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_search {
        req_builder = req_builder.query(&[("search", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginatedAuthenticatorDuoStageList`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginatedAuthenticatorDuoStageList`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesAuthenticatorDuoListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// AuthenticatorDuoStage Viewset
pub async fn stages_authenticator_duo_partial_update(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
    patched_authenticator_duo_stage_request: Option<models::PatchedAuthenticatorDuoStageRequest>,
) -> Result<models::AuthenticatorDuoStage, Error<StagesAuthenticatorDuoPartialUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;
    let p_body_patched_authenticator_duo_stage_request = patched_authenticator_duo_stage_request;

    let uri_str = format!(
        "{}/stages/authenticator/duo/{stage_uuid}/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_patched_authenticator_duo_stage_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AuthenticatorDuoStage`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AuthenticatorDuoStage`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesAuthenticatorDuoPartialUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// AuthenticatorDuoStage Viewset
pub async fn stages_authenticator_duo_retrieve(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
) -> Result<models::AuthenticatorDuoStage, Error<StagesAuthenticatorDuoRetrieveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;

    let uri_str = format!(
        "{}/stages/authenticator/duo/{stage_uuid}/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AuthenticatorDuoStage`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AuthenticatorDuoStage`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesAuthenticatorDuoRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// AuthenticatorDuoStage Viewset
pub async fn stages_authenticator_duo_update(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
    authenticator_duo_stage_request: models::AuthenticatorDuoStageRequest,
) -> Result<models::AuthenticatorDuoStage, Error<StagesAuthenticatorDuoUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;
    let p_body_authenticator_duo_stage_request = authenticator_duo_stage_request;

    let uri_str = format!(
        "{}/stages/authenticator/duo/{stage_uuid}/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_authenticator_duo_stage_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AuthenticatorDuoStage`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AuthenticatorDuoStage`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesAuthenticatorDuoUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get a list of all objects that use this object
pub async fn stages_authenticator_duo_used_by_list(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
) -> Result<Vec<models::UsedBy>, Error<StagesAuthenticatorDuoUsedByListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;

    let uri_str = format!(
        "{}/stages/authenticator/duo/{stage_uuid}/used_by/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesAuthenticatorDuoUsedByListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// AuthenticatorEmailStage Viewset
pub async fn stages_authenticator_email_create(
    configuration: &configuration::Configuration,
    authenticator_email_stage_request: models::AuthenticatorEmailStageRequest,
) -> Result<models::AuthenticatorEmailStage, Error<StagesAuthenticatorEmailCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_authenticator_email_stage_request = authenticator_email_stage_request;

    let uri_str = format!("{}/stages/authenticator/email/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_authenticator_email_stage_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AuthenticatorEmailStage`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AuthenticatorEmailStage`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesAuthenticatorEmailCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// AuthenticatorEmailStage Viewset
pub async fn stages_authenticator_email_destroy(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
) -> Result<(), Error<StagesAuthenticatorEmailDestroyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;

    let uri_str = format!(
        "{}/stages/authenticator/email/{stage_uuid}/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesAuthenticatorEmailDestroyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// AuthenticatorEmailStage Viewset
pub async fn stages_authenticator_email_list(
    configuration: &configuration::Configuration,
    configure_flow: Option<&str>,
    friendly_name: Option<&str>,
    from_address: Option<&str>,
    host: Option<&str>,
    name: Option<&str>,
    ordering: Option<&str>,
    page: Option<i32>,
    page_size: Option<i32>,
    password: Option<&str>,
    port: Option<i32>,
    search: Option<&str>,
    stage_uuid: Option<&str>,
    subject: Option<&str>,
    template: Option<&str>,
    timeout: Option<i32>,
    token_expiry: Option<&str>,
    use_global_settings: Option<bool>,
    use_ssl: Option<bool>,
    use_tls: Option<bool>,
    username: Option<&str>,
) -> Result<models::PaginatedAuthenticatorEmailStageList, Error<StagesAuthenticatorEmailListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_configure_flow = configure_flow;
    let p_query_friendly_name = friendly_name;
    let p_query_from_address = from_address;
    let p_query_host = host;
    let p_query_name = name;
    let p_query_ordering = ordering;
    let p_query_page = page;
    let p_query_page_size = page_size;
    let p_query_password = password;
    let p_query_port = port;
    let p_query_search = search;
    let p_query_stage_uuid = stage_uuid;
    let p_query_subject = subject;
    let p_query_template = template;
    let p_query_timeout = timeout;
    let p_query_token_expiry = token_expiry;
    let p_query_use_global_settings = use_global_settings;
    let p_query_use_ssl = use_ssl;
    let p_query_use_tls = use_tls;
    let p_query_username = username;

    let uri_str = format!("{}/stages/authenticator/email/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_configure_flow {
        req_builder = req_builder.query(&[("configure_flow", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_friendly_name {
        req_builder = req_builder.query(&[("friendly_name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_from_address {
        req_builder = req_builder.query(&[("from_address", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_host {
        req_builder = req_builder.query(&[("host", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ordering {
        req_builder = req_builder.query(&[("ordering", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page_size {
        req_builder = req_builder.query(&[("page_size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_password {
        req_builder = req_builder.query(&[("password", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_port {
        req_builder = req_builder.query(&[("port", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_search {
        req_builder = req_builder.query(&[("search", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_stage_uuid {
        req_builder = req_builder.query(&[("stage_uuid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_subject {
        req_builder = req_builder.query(&[("subject", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_template {
        req_builder = req_builder.query(&[("template", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_timeout {
        req_builder = req_builder.query(&[("timeout", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_token_expiry {
        req_builder = req_builder.query(&[("token_expiry", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_use_global_settings {
        req_builder = req_builder.query(&[("use_global_settings", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_use_ssl {
        req_builder = req_builder.query(&[("use_ssl", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_use_tls {
        req_builder = req_builder.query(&[("use_tls", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_username {
        req_builder = req_builder.query(&[("username", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginatedAuthenticatorEmailStageList`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginatedAuthenticatorEmailStageList`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesAuthenticatorEmailListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// AuthenticatorEmailStage Viewset
pub async fn stages_authenticator_email_partial_update(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
    patched_authenticator_email_stage_request: Option<models::PatchedAuthenticatorEmailStageRequest>,
) -> Result<models::AuthenticatorEmailStage, Error<StagesAuthenticatorEmailPartialUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;
    let p_body_patched_authenticator_email_stage_request = patched_authenticator_email_stage_request;

    let uri_str = format!(
        "{}/stages/authenticator/email/{stage_uuid}/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_patched_authenticator_email_stage_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AuthenticatorEmailStage`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AuthenticatorEmailStage`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesAuthenticatorEmailPartialUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// AuthenticatorEmailStage Viewset
pub async fn stages_authenticator_email_retrieve(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
) -> Result<models::AuthenticatorEmailStage, Error<StagesAuthenticatorEmailRetrieveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;

    let uri_str = format!(
        "{}/stages/authenticator/email/{stage_uuid}/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AuthenticatorEmailStage`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AuthenticatorEmailStage`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesAuthenticatorEmailRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// AuthenticatorEmailStage Viewset
pub async fn stages_authenticator_email_update(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
    authenticator_email_stage_request: models::AuthenticatorEmailStageRequest,
) -> Result<models::AuthenticatorEmailStage, Error<StagesAuthenticatorEmailUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;
    let p_body_authenticator_email_stage_request = authenticator_email_stage_request;

    let uri_str = format!(
        "{}/stages/authenticator/email/{stage_uuid}/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_authenticator_email_stage_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AuthenticatorEmailStage`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AuthenticatorEmailStage`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesAuthenticatorEmailUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get a list of all objects that use this object
pub async fn stages_authenticator_email_used_by_list(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
) -> Result<Vec<models::UsedBy>, Error<StagesAuthenticatorEmailUsedByListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;

    let uri_str = format!(
        "{}/stages/authenticator/email/{stage_uuid}/used_by/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesAuthenticatorEmailUsedByListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// AuthenticatorEndpointGDTCStage Viewset
pub async fn stages_authenticator_endpoint_gdtc_create(
    configuration: &configuration::Configuration,
    authenticator_endpoint_gdtc_stage_request: models::AuthenticatorEndpointGdtcStageRequest,
) -> Result<models::AuthenticatorEndpointGdtcStage, Error<StagesAuthenticatorEndpointGdtcCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_authenticator_endpoint_gdtc_stage_request = authenticator_endpoint_gdtc_stage_request;

    let uri_str = format!("{}/stages/authenticator/endpoint_gdtc/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_authenticator_endpoint_gdtc_stage_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AuthenticatorEndpointGdtcStage`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AuthenticatorEndpointGdtcStage`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesAuthenticatorEndpointGdtcCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// AuthenticatorEndpointGDTCStage Viewset
pub async fn stages_authenticator_endpoint_gdtc_destroy(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
) -> Result<(), Error<StagesAuthenticatorEndpointGdtcDestroyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;

    let uri_str = format!(
        "{}/stages/authenticator/endpoint_gdtc/{stage_uuid}/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesAuthenticatorEndpointGdtcDestroyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// AuthenticatorEndpointGDTCStage Viewset
pub async fn stages_authenticator_endpoint_gdtc_list(
    configuration: &configuration::Configuration,
    configure_flow: Option<&str>,
    name: Option<&str>,
    ordering: Option<&str>,
    page: Option<i32>,
    page_size: Option<i32>,
    search: Option<&str>,
) -> Result<models::PaginatedAuthenticatorEndpointGdtcStageList, Error<StagesAuthenticatorEndpointGdtcListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_configure_flow = configure_flow;
    let p_query_name = name;
    let p_query_ordering = ordering;
    let p_query_page = page;
    let p_query_page_size = page_size;
    let p_query_search = search;

    let uri_str = format!("{}/stages/authenticator/endpoint_gdtc/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_configure_flow {
        req_builder = req_builder.query(&[("configure_flow", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ordering {
        req_builder = req_builder.query(&[("ordering", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page_size {
        req_builder = req_builder.query(&[("page_size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_search {
        req_builder = req_builder.query(&[("search", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginatedAuthenticatorEndpointGdtcStageList`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginatedAuthenticatorEndpointGdtcStageList`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesAuthenticatorEndpointGdtcListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// AuthenticatorEndpointGDTCStage Viewset
pub async fn stages_authenticator_endpoint_gdtc_partial_update(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
    patched_authenticator_endpoint_gdtc_stage_request: Option<models::PatchedAuthenticatorEndpointGdtcStageRequest>,
) -> Result<models::AuthenticatorEndpointGdtcStage, Error<StagesAuthenticatorEndpointGdtcPartialUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;
    let p_body_patched_authenticator_endpoint_gdtc_stage_request = patched_authenticator_endpoint_gdtc_stage_request;

    let uri_str = format!(
        "{}/stages/authenticator/endpoint_gdtc/{stage_uuid}/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_patched_authenticator_endpoint_gdtc_stage_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AuthenticatorEndpointGdtcStage`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AuthenticatorEndpointGdtcStage`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesAuthenticatorEndpointGdtcPartialUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// AuthenticatorEndpointGDTCStage Viewset
pub async fn stages_authenticator_endpoint_gdtc_retrieve(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
) -> Result<models::AuthenticatorEndpointGdtcStage, Error<StagesAuthenticatorEndpointGdtcRetrieveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;

    let uri_str = format!(
        "{}/stages/authenticator/endpoint_gdtc/{stage_uuid}/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AuthenticatorEndpointGdtcStage`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AuthenticatorEndpointGdtcStage`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesAuthenticatorEndpointGdtcRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// AuthenticatorEndpointGDTCStage Viewset
pub async fn stages_authenticator_endpoint_gdtc_update(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
    authenticator_endpoint_gdtc_stage_request: models::AuthenticatorEndpointGdtcStageRequest,
) -> Result<models::AuthenticatorEndpointGdtcStage, Error<StagesAuthenticatorEndpointGdtcUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;
    let p_body_authenticator_endpoint_gdtc_stage_request = authenticator_endpoint_gdtc_stage_request;

    let uri_str = format!(
        "{}/stages/authenticator/endpoint_gdtc/{stage_uuid}/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_authenticator_endpoint_gdtc_stage_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AuthenticatorEndpointGdtcStage`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AuthenticatorEndpointGdtcStage`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesAuthenticatorEndpointGdtcUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get a list of all objects that use this object
pub async fn stages_authenticator_endpoint_gdtc_used_by_list(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
) -> Result<Vec<models::UsedBy>, Error<StagesAuthenticatorEndpointGdtcUsedByListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;

    let uri_str = format!(
        "{}/stages/authenticator/endpoint_gdtc/{stage_uuid}/used_by/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesAuthenticatorEndpointGdtcUsedByListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// AuthenticatorSMSStage Viewset
pub async fn stages_authenticator_sms_create(
    configuration: &configuration::Configuration,
    authenticator_sms_stage_request: models::AuthenticatorSmsStageRequest,
) -> Result<models::AuthenticatorSmsStage, Error<StagesAuthenticatorSmsCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_authenticator_sms_stage_request = authenticator_sms_stage_request;

    let uri_str = format!("{}/stages/authenticator/sms/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_authenticator_sms_stage_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AuthenticatorSmsStage`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AuthenticatorSmsStage`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesAuthenticatorSmsCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// AuthenticatorSMSStage Viewset
pub async fn stages_authenticator_sms_destroy(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
) -> Result<(), Error<StagesAuthenticatorSmsDestroyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;

    let uri_str = format!(
        "{}/stages/authenticator/sms/{stage_uuid}/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesAuthenticatorSmsDestroyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// AuthenticatorSMSStage Viewset
pub async fn stages_authenticator_sms_list(
    configuration: &configuration::Configuration,
    account_sid: Option<&str>,
    auth: Option<&str>,
    auth_password: Option<&str>,
    auth_type: Option<&str>,
    configure_flow: Option<&str>,
    friendly_name: Option<&str>,
    from_number: Option<&str>,
    mapping: Option<&str>,
    name: Option<&str>,
    ordering: Option<&str>,
    page: Option<i32>,
    page_size: Option<i32>,
    provider: Option<&str>,
    search: Option<&str>,
    stage_uuid: Option<&str>,
    verify_only: Option<bool>,
) -> Result<models::PaginatedAuthenticatorSmsStageList, Error<StagesAuthenticatorSmsListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_account_sid = account_sid;
    let p_query_auth = auth;
    let p_query_auth_password = auth_password;
    let p_query_auth_type = auth_type;
    let p_query_configure_flow = configure_flow;
    let p_query_friendly_name = friendly_name;
    let p_query_from_number = from_number;
    let p_query_mapping = mapping;
    let p_query_name = name;
    let p_query_ordering = ordering;
    let p_query_page = page;
    let p_query_page_size = page_size;
    let p_query_provider = provider;
    let p_query_search = search;
    let p_query_stage_uuid = stage_uuid;
    let p_query_verify_only = verify_only;

    let uri_str = format!("{}/stages/authenticator/sms/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_account_sid {
        req_builder = req_builder.query(&[("account_sid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_auth {
        req_builder = req_builder.query(&[("auth", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_auth_password {
        req_builder = req_builder.query(&[("auth_password", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_auth_type {
        req_builder = req_builder.query(&[("auth_type", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_configure_flow {
        req_builder = req_builder.query(&[("configure_flow", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_friendly_name {
        req_builder = req_builder.query(&[("friendly_name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_from_number {
        req_builder = req_builder.query(&[("from_number", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mapping {
        req_builder = req_builder.query(&[("mapping", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ordering {
        req_builder = req_builder.query(&[("ordering", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page_size {
        req_builder = req_builder.query(&[("page_size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_provider {
        req_builder = req_builder.query(&[("provider", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_search {
        req_builder = req_builder.query(&[("search", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_stage_uuid {
        req_builder = req_builder.query(&[("stage_uuid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_verify_only {
        req_builder = req_builder.query(&[("verify_only", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginatedAuthenticatorSmsStageList`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginatedAuthenticatorSmsStageList`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesAuthenticatorSmsListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// AuthenticatorSMSStage Viewset
pub async fn stages_authenticator_sms_partial_update(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
    patched_authenticator_sms_stage_request: Option<models::PatchedAuthenticatorSmsStageRequest>,
) -> Result<models::AuthenticatorSmsStage, Error<StagesAuthenticatorSmsPartialUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;
    let p_body_patched_authenticator_sms_stage_request = patched_authenticator_sms_stage_request;

    let uri_str = format!(
        "{}/stages/authenticator/sms/{stage_uuid}/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_patched_authenticator_sms_stage_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AuthenticatorSmsStage`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AuthenticatorSmsStage`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesAuthenticatorSmsPartialUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// AuthenticatorSMSStage Viewset
pub async fn stages_authenticator_sms_retrieve(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
) -> Result<models::AuthenticatorSmsStage, Error<StagesAuthenticatorSmsRetrieveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;

    let uri_str = format!(
        "{}/stages/authenticator/sms/{stage_uuid}/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AuthenticatorSmsStage`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AuthenticatorSmsStage`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesAuthenticatorSmsRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// AuthenticatorSMSStage Viewset
pub async fn stages_authenticator_sms_update(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
    authenticator_sms_stage_request: models::AuthenticatorSmsStageRequest,
) -> Result<models::AuthenticatorSmsStage, Error<StagesAuthenticatorSmsUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;
    let p_body_authenticator_sms_stage_request = authenticator_sms_stage_request;

    let uri_str = format!(
        "{}/stages/authenticator/sms/{stage_uuid}/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_authenticator_sms_stage_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AuthenticatorSmsStage`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AuthenticatorSmsStage`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesAuthenticatorSmsUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get a list of all objects that use this object
pub async fn stages_authenticator_sms_used_by_list(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
) -> Result<Vec<models::UsedBy>, Error<StagesAuthenticatorSmsUsedByListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;

    let uri_str = format!(
        "{}/stages/authenticator/sms/{stage_uuid}/used_by/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesAuthenticatorSmsUsedByListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// AuthenticatorStaticStage Viewset
pub async fn stages_authenticator_static_create(
    configuration: &configuration::Configuration,
    authenticator_static_stage_request: models::AuthenticatorStaticStageRequest,
) -> Result<models::AuthenticatorStaticStage, Error<StagesAuthenticatorStaticCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_authenticator_static_stage_request = authenticator_static_stage_request;

    let uri_str = format!("{}/stages/authenticator/static/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_authenticator_static_stage_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AuthenticatorStaticStage`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AuthenticatorStaticStage`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesAuthenticatorStaticCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// AuthenticatorStaticStage Viewset
pub async fn stages_authenticator_static_destroy(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
) -> Result<(), Error<StagesAuthenticatorStaticDestroyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;

    let uri_str = format!(
        "{}/stages/authenticator/static/{stage_uuid}/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesAuthenticatorStaticDestroyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// AuthenticatorStaticStage Viewset
pub async fn stages_authenticator_static_list(
    configuration: &configuration::Configuration,
    configure_flow: Option<&str>,
    friendly_name: Option<&str>,
    name: Option<&str>,
    ordering: Option<&str>,
    page: Option<i32>,
    page_size: Option<i32>,
    search: Option<&str>,
    stage_uuid: Option<&str>,
    token_count: Option<i32>,
    token_length: Option<i32>,
) -> Result<models::PaginatedAuthenticatorStaticStageList, Error<StagesAuthenticatorStaticListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_configure_flow = configure_flow;
    let p_query_friendly_name = friendly_name;
    let p_query_name = name;
    let p_query_ordering = ordering;
    let p_query_page = page;
    let p_query_page_size = page_size;
    let p_query_search = search;
    let p_query_stage_uuid = stage_uuid;
    let p_query_token_count = token_count;
    let p_query_token_length = token_length;

    let uri_str = format!("{}/stages/authenticator/static/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_configure_flow {
        req_builder = req_builder.query(&[("configure_flow", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_friendly_name {
        req_builder = req_builder.query(&[("friendly_name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ordering {
        req_builder = req_builder.query(&[("ordering", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page_size {
        req_builder = req_builder.query(&[("page_size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_search {
        req_builder = req_builder.query(&[("search", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_stage_uuid {
        req_builder = req_builder.query(&[("stage_uuid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_token_count {
        req_builder = req_builder.query(&[("token_count", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_token_length {
        req_builder = req_builder.query(&[("token_length", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginatedAuthenticatorStaticStageList`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginatedAuthenticatorStaticStageList`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesAuthenticatorStaticListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// AuthenticatorStaticStage Viewset
pub async fn stages_authenticator_static_partial_update(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
    patched_authenticator_static_stage_request: Option<models::PatchedAuthenticatorStaticStageRequest>,
) -> Result<models::AuthenticatorStaticStage, Error<StagesAuthenticatorStaticPartialUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;
    let p_body_patched_authenticator_static_stage_request = patched_authenticator_static_stage_request;

    let uri_str = format!(
        "{}/stages/authenticator/static/{stage_uuid}/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_patched_authenticator_static_stage_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AuthenticatorStaticStage`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AuthenticatorStaticStage`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesAuthenticatorStaticPartialUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// AuthenticatorStaticStage Viewset
pub async fn stages_authenticator_static_retrieve(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
) -> Result<models::AuthenticatorStaticStage, Error<StagesAuthenticatorStaticRetrieveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;

    let uri_str = format!(
        "{}/stages/authenticator/static/{stage_uuid}/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AuthenticatorStaticStage`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AuthenticatorStaticStage`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesAuthenticatorStaticRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// AuthenticatorStaticStage Viewset
pub async fn stages_authenticator_static_update(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
    authenticator_static_stage_request: models::AuthenticatorStaticStageRequest,
) -> Result<models::AuthenticatorStaticStage, Error<StagesAuthenticatorStaticUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;
    let p_body_authenticator_static_stage_request = authenticator_static_stage_request;

    let uri_str = format!(
        "{}/stages/authenticator/static/{stage_uuid}/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_authenticator_static_stage_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AuthenticatorStaticStage`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AuthenticatorStaticStage`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesAuthenticatorStaticUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get a list of all objects that use this object
pub async fn stages_authenticator_static_used_by_list(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
) -> Result<Vec<models::UsedBy>, Error<StagesAuthenticatorStaticUsedByListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;

    let uri_str = format!(
        "{}/stages/authenticator/static/{stage_uuid}/used_by/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesAuthenticatorStaticUsedByListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// AuthenticatorTOTPStage Viewset
pub async fn stages_authenticator_totp_create(
    configuration: &configuration::Configuration,
    authenticator_totp_stage_request: models::AuthenticatorTotpStageRequest,
) -> Result<models::AuthenticatorTotpStage, Error<StagesAuthenticatorTotpCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_authenticator_totp_stage_request = authenticator_totp_stage_request;

    let uri_str = format!("{}/stages/authenticator/totp/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_authenticator_totp_stage_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AuthenticatorTotpStage`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AuthenticatorTotpStage`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesAuthenticatorTotpCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// AuthenticatorTOTPStage Viewset
pub async fn stages_authenticator_totp_destroy(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
) -> Result<(), Error<StagesAuthenticatorTotpDestroyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;

    let uri_str = format!(
        "{}/stages/authenticator/totp/{stage_uuid}/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesAuthenticatorTotpDestroyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// AuthenticatorTOTPStage Viewset
pub async fn stages_authenticator_totp_list(
    configuration: &configuration::Configuration,
    configure_flow: Option<&str>,
    digits: Option<&str>,
    friendly_name: Option<&str>,
    name: Option<&str>,
    ordering: Option<&str>,
    page: Option<i32>,
    page_size: Option<i32>,
    search: Option<&str>,
    stage_uuid: Option<&str>,
) -> Result<models::PaginatedAuthenticatorTotpStageList, Error<StagesAuthenticatorTotpListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_configure_flow = configure_flow;
    let p_query_digits = digits;
    let p_query_friendly_name = friendly_name;
    let p_query_name = name;
    let p_query_ordering = ordering;
    let p_query_page = page;
    let p_query_page_size = page_size;
    let p_query_search = search;
    let p_query_stage_uuid = stage_uuid;

    let uri_str = format!("{}/stages/authenticator/totp/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_configure_flow {
        req_builder = req_builder.query(&[("configure_flow", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_digits {
        req_builder = req_builder.query(&[("digits", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_friendly_name {
        req_builder = req_builder.query(&[("friendly_name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ordering {
        req_builder = req_builder.query(&[("ordering", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page_size {
        req_builder = req_builder.query(&[("page_size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_search {
        req_builder = req_builder.query(&[("search", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_stage_uuid {
        req_builder = req_builder.query(&[("stage_uuid", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginatedAuthenticatorTotpStageList`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginatedAuthenticatorTotpStageList`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesAuthenticatorTotpListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// AuthenticatorTOTPStage Viewset
pub async fn stages_authenticator_totp_partial_update(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
    patched_authenticator_totp_stage_request: Option<models::PatchedAuthenticatorTotpStageRequest>,
) -> Result<models::AuthenticatorTotpStage, Error<StagesAuthenticatorTotpPartialUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;
    let p_body_patched_authenticator_totp_stage_request = patched_authenticator_totp_stage_request;

    let uri_str = format!(
        "{}/stages/authenticator/totp/{stage_uuid}/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_patched_authenticator_totp_stage_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AuthenticatorTotpStage`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AuthenticatorTotpStage`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesAuthenticatorTotpPartialUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// AuthenticatorTOTPStage Viewset
pub async fn stages_authenticator_totp_retrieve(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
) -> Result<models::AuthenticatorTotpStage, Error<StagesAuthenticatorTotpRetrieveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;

    let uri_str = format!(
        "{}/stages/authenticator/totp/{stage_uuid}/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AuthenticatorTotpStage`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AuthenticatorTotpStage`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesAuthenticatorTotpRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// AuthenticatorTOTPStage Viewset
pub async fn stages_authenticator_totp_update(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
    authenticator_totp_stage_request: models::AuthenticatorTotpStageRequest,
) -> Result<models::AuthenticatorTotpStage, Error<StagesAuthenticatorTotpUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;
    let p_body_authenticator_totp_stage_request = authenticator_totp_stage_request;

    let uri_str = format!(
        "{}/stages/authenticator/totp/{stage_uuid}/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_authenticator_totp_stage_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AuthenticatorTotpStage`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AuthenticatorTotpStage`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesAuthenticatorTotpUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get a list of all objects that use this object
pub async fn stages_authenticator_totp_used_by_list(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
) -> Result<Vec<models::UsedBy>, Error<StagesAuthenticatorTotpUsedByListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;

    let uri_str = format!(
        "{}/stages/authenticator/totp/{stage_uuid}/used_by/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesAuthenticatorTotpUsedByListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// AuthenticatorValidateStage Viewset
pub async fn stages_authenticator_validate_create(
    configuration: &configuration::Configuration,
    authenticator_validate_stage_request: models::AuthenticatorValidateStageRequest,
) -> Result<models::AuthenticatorValidateStage, Error<StagesAuthenticatorValidateCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_authenticator_validate_stage_request = authenticator_validate_stage_request;

    let uri_str = format!("{}/stages/authenticator/validate/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_authenticator_validate_stage_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AuthenticatorValidateStage`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AuthenticatorValidateStage`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesAuthenticatorValidateCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// AuthenticatorValidateStage Viewset
pub async fn stages_authenticator_validate_destroy(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
) -> Result<(), Error<StagesAuthenticatorValidateDestroyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;

    let uri_str = format!(
        "{}/stages/authenticator/validate/{stage_uuid}/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesAuthenticatorValidateDestroyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// AuthenticatorValidateStage Viewset
pub async fn stages_authenticator_validate_list(
    configuration: &configuration::Configuration,
    configuration_stages: Option<Vec<uuid::Uuid>>,
    name: Option<&str>,
    not_configured_action: Option<&str>,
    ordering: Option<&str>,
    page: Option<i32>,
    page_size: Option<i32>,
    search: Option<&str>,
) -> Result<models::PaginatedAuthenticatorValidateStageList, Error<StagesAuthenticatorValidateListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_configuration_stages = configuration_stages;
    let p_query_name = name;
    let p_query_not_configured_action = not_configured_action;
    let p_query_ordering = ordering;
    let p_query_page = page;
    let p_query_page_size = page_size;
    let p_query_search = search;

    let uri_str = format!("{}/stages/authenticator/validate/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_configuration_stages {
        req_builder = match "multi" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("configuration_stages".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "configuration_stages",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = p_query_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_not_configured_action {
        req_builder = req_builder.query(&[("not_configured_action", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ordering {
        req_builder = req_builder.query(&[("ordering", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page_size {
        req_builder = req_builder.query(&[("page_size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_search {
        req_builder = req_builder.query(&[("search", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginatedAuthenticatorValidateStageList`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginatedAuthenticatorValidateStageList`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesAuthenticatorValidateListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// AuthenticatorValidateStage Viewset
pub async fn stages_authenticator_validate_partial_update(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
    patched_authenticator_validate_stage_request: Option<models::PatchedAuthenticatorValidateStageRequest>,
) -> Result<models::AuthenticatorValidateStage, Error<StagesAuthenticatorValidatePartialUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;
    let p_body_patched_authenticator_validate_stage_request = patched_authenticator_validate_stage_request;

    let uri_str = format!(
        "{}/stages/authenticator/validate/{stage_uuid}/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_patched_authenticator_validate_stage_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AuthenticatorValidateStage`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AuthenticatorValidateStage`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesAuthenticatorValidatePartialUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// AuthenticatorValidateStage Viewset
pub async fn stages_authenticator_validate_retrieve(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
) -> Result<models::AuthenticatorValidateStage, Error<StagesAuthenticatorValidateRetrieveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;

    let uri_str = format!(
        "{}/stages/authenticator/validate/{stage_uuid}/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AuthenticatorValidateStage`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AuthenticatorValidateStage`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesAuthenticatorValidateRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// AuthenticatorValidateStage Viewset
pub async fn stages_authenticator_validate_update(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
    authenticator_validate_stage_request: models::AuthenticatorValidateStageRequest,
) -> Result<models::AuthenticatorValidateStage, Error<StagesAuthenticatorValidateUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;
    let p_body_authenticator_validate_stage_request = authenticator_validate_stage_request;

    let uri_str = format!(
        "{}/stages/authenticator/validate/{stage_uuid}/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_authenticator_validate_stage_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AuthenticatorValidateStage`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AuthenticatorValidateStage`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesAuthenticatorValidateUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get a list of all objects that use this object
pub async fn stages_authenticator_validate_used_by_list(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
) -> Result<Vec<models::UsedBy>, Error<StagesAuthenticatorValidateUsedByListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;

    let uri_str = format!(
        "{}/stages/authenticator/validate/{stage_uuid}/used_by/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesAuthenticatorValidateUsedByListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// AuthenticatorWebAuthnStage Viewset
pub async fn stages_authenticator_webauthn_create(
    configuration: &configuration::Configuration,
    authenticator_web_authn_stage_request: models::AuthenticatorWebAuthnStageRequest,
) -> Result<models::AuthenticatorWebAuthnStage, Error<StagesAuthenticatorWebauthnCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_authenticator_web_authn_stage_request = authenticator_web_authn_stage_request;

    let uri_str = format!("{}/stages/authenticator/webauthn/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_authenticator_web_authn_stage_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AuthenticatorWebAuthnStage`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AuthenticatorWebAuthnStage`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesAuthenticatorWebauthnCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// AuthenticatorWebAuthnStage Viewset
pub async fn stages_authenticator_webauthn_destroy(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
) -> Result<(), Error<StagesAuthenticatorWebauthnDestroyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;

    let uri_str = format!(
        "{}/stages/authenticator/webauthn/{stage_uuid}/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesAuthenticatorWebauthnDestroyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// WebAuthnDeviceType Viewset
pub async fn stages_authenticator_webauthn_device_types_list(
    configuration: &configuration::Configuration,
    aaguid: Option<&str>,
    description: Option<&str>,
    icon: Option<&str>,
    ordering: Option<&str>,
    page: Option<i32>,
    page_size: Option<i32>,
    search: Option<&str>,
) -> Result<models::PaginatedWebAuthnDeviceTypeList, Error<StagesAuthenticatorWebauthnDeviceTypesListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_aaguid = aaguid;
    let p_query_description = description;
    let p_query_icon = icon;
    let p_query_ordering = ordering;
    let p_query_page = page;
    let p_query_page_size = page_size;
    let p_query_search = search;

    let uri_str = format!(
        "{}/stages/authenticator/webauthn_device_types/",
        configuration.base_path
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_aaguid {
        req_builder = req_builder.query(&[("aaguid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_description {
        req_builder = req_builder.query(&[("description", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_icon {
        req_builder = req_builder.query(&[("icon", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ordering {
        req_builder = req_builder.query(&[("ordering", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page_size {
        req_builder = req_builder.query(&[("page_size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_search {
        req_builder = req_builder.query(&[("search", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginatedWebAuthnDeviceTypeList`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginatedWebAuthnDeviceTypeList`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesAuthenticatorWebauthnDeviceTypesListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// WebAuthnDeviceType Viewset
pub async fn stages_authenticator_webauthn_device_types_retrieve(
    configuration: &configuration::Configuration,
    aaguid: &str,
) -> Result<models::WebAuthnDeviceType, Error<StagesAuthenticatorWebauthnDeviceTypesRetrieveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_aaguid = aaguid;

    let uri_str = format!(
        "{}/stages/authenticator/webauthn_device_types/{aaguid}/",
        configuration.base_path,
        aaguid = crate::apis::urlencode(p_path_aaguid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::WebAuthnDeviceType`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::WebAuthnDeviceType`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesAuthenticatorWebauthnDeviceTypesRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// AuthenticatorWebAuthnStage Viewset
pub async fn stages_authenticator_webauthn_list(
    configuration: &configuration::Configuration,
    authenticator_attachment: Option<&str>,
    configure_flow: Option<&str>,
    device_type_restrictions: Option<Vec<uuid::Uuid>>,
    friendly_name: Option<&str>,
    name: Option<&str>,
    ordering: Option<&str>,
    page: Option<i32>,
    page_size: Option<i32>,
    resident_key_requirement: Option<&str>,
    search: Option<&str>,
    stage_uuid: Option<&str>,
    user_verification: Option<&str>,
) -> Result<models::PaginatedAuthenticatorWebAuthnStageList, Error<StagesAuthenticatorWebauthnListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_authenticator_attachment = authenticator_attachment;
    let p_query_configure_flow = configure_flow;
    let p_query_device_type_restrictions = device_type_restrictions;
    let p_query_friendly_name = friendly_name;
    let p_query_name = name;
    let p_query_ordering = ordering;
    let p_query_page = page;
    let p_query_page_size = page_size;
    let p_query_resident_key_requirement = resident_key_requirement;
    let p_query_search = search;
    let p_query_stage_uuid = stage_uuid;
    let p_query_user_verification = user_verification;

    let uri_str = format!("{}/stages/authenticator/webauthn/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_authenticator_attachment {
        req_builder = req_builder.query(&[("authenticator_attachment", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_configure_flow {
        req_builder = req_builder.query(&[("configure_flow", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_device_type_restrictions {
        req_builder = match "multi" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("device_type_restrictions".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "device_type_restrictions",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = p_query_friendly_name {
        req_builder = req_builder.query(&[("friendly_name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ordering {
        req_builder = req_builder.query(&[("ordering", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page_size {
        req_builder = req_builder.query(&[("page_size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_resident_key_requirement {
        req_builder = req_builder.query(&[("resident_key_requirement", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_search {
        req_builder = req_builder.query(&[("search", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_stage_uuid {
        req_builder = req_builder.query(&[("stage_uuid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_user_verification {
        req_builder = req_builder.query(&[("user_verification", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginatedAuthenticatorWebAuthnStageList`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginatedAuthenticatorWebAuthnStageList`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesAuthenticatorWebauthnListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// AuthenticatorWebAuthnStage Viewset
pub async fn stages_authenticator_webauthn_partial_update(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
    patched_authenticator_web_authn_stage_request: Option<models::PatchedAuthenticatorWebAuthnStageRequest>,
) -> Result<models::AuthenticatorWebAuthnStage, Error<StagesAuthenticatorWebauthnPartialUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;
    let p_body_patched_authenticator_web_authn_stage_request = patched_authenticator_web_authn_stage_request;

    let uri_str = format!(
        "{}/stages/authenticator/webauthn/{stage_uuid}/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_patched_authenticator_web_authn_stage_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AuthenticatorWebAuthnStage`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AuthenticatorWebAuthnStage`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesAuthenticatorWebauthnPartialUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// AuthenticatorWebAuthnStage Viewset
pub async fn stages_authenticator_webauthn_retrieve(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
) -> Result<models::AuthenticatorWebAuthnStage, Error<StagesAuthenticatorWebauthnRetrieveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;

    let uri_str = format!(
        "{}/stages/authenticator/webauthn/{stage_uuid}/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AuthenticatorWebAuthnStage`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AuthenticatorWebAuthnStage`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesAuthenticatorWebauthnRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// AuthenticatorWebAuthnStage Viewset
pub async fn stages_authenticator_webauthn_update(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
    authenticator_web_authn_stage_request: models::AuthenticatorWebAuthnStageRequest,
) -> Result<models::AuthenticatorWebAuthnStage, Error<StagesAuthenticatorWebauthnUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;
    let p_body_authenticator_web_authn_stage_request = authenticator_web_authn_stage_request;

    let uri_str = format!(
        "{}/stages/authenticator/webauthn/{stage_uuid}/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_authenticator_web_authn_stage_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AuthenticatorWebAuthnStage`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AuthenticatorWebAuthnStage`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesAuthenticatorWebauthnUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get a list of all objects that use this object
pub async fn stages_authenticator_webauthn_used_by_list(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
) -> Result<Vec<models::UsedBy>, Error<StagesAuthenticatorWebauthnUsedByListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;

    let uri_str = format!(
        "{}/stages/authenticator/webauthn/{stage_uuid}/used_by/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesAuthenticatorWebauthnUsedByListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// CaptchaStage Viewset
pub async fn stages_captcha_create(
    configuration: &configuration::Configuration,
    captcha_stage_request: models::CaptchaStageRequest,
) -> Result<models::CaptchaStage, Error<StagesCaptchaCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_captcha_stage_request = captcha_stage_request;

    let uri_str = format!("{}/stages/captcha/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_captcha_stage_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::CaptchaStage`",
                )))
            }
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!(
                "Received `{unknown_type}` content type response that cannot be converted to `models::CaptchaStage`"
            )))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesCaptchaCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// CaptchaStage Viewset
pub async fn stages_captcha_destroy(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
) -> Result<(), Error<StagesCaptchaDestroyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;

    let uri_str = format!(
        "{}/stages/captcha/{stage_uuid}/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesCaptchaDestroyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// CaptchaStage Viewset
pub async fn stages_captcha_list(
    configuration: &configuration::Configuration,
    name: Option<&str>,
    ordering: Option<&str>,
    page: Option<i32>,
    page_size: Option<i32>,
    public_key: Option<&str>,
    search: Option<&str>,
) -> Result<models::PaginatedCaptchaStageList, Error<StagesCaptchaListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_name = name;
    let p_query_ordering = ordering;
    let p_query_page = page;
    let p_query_page_size = page_size;
    let p_query_public_key = public_key;
    let p_query_search = search;

    let uri_str = format!("{}/stages/captcha/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ordering {
        req_builder = req_builder.query(&[("ordering", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page_size {
        req_builder = req_builder.query(&[("page_size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_public_key {
        req_builder = req_builder.query(&[("public_key", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_search {
        req_builder = req_builder.query(&[("search", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginatedCaptchaStageList`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginatedCaptchaStageList`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesCaptchaListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// CaptchaStage Viewset
pub async fn stages_captcha_partial_update(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
    patched_captcha_stage_request: Option<models::PatchedCaptchaStageRequest>,
) -> Result<models::CaptchaStage, Error<StagesCaptchaPartialUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;
    let p_body_patched_captcha_stage_request = patched_captcha_stage_request;

    let uri_str = format!(
        "{}/stages/captcha/{stage_uuid}/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_patched_captcha_stage_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::CaptchaStage`",
                )))
            }
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!(
                "Received `{unknown_type}` content type response that cannot be converted to `models::CaptchaStage`"
            )))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesCaptchaPartialUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// CaptchaStage Viewset
pub async fn stages_captcha_retrieve(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
) -> Result<models::CaptchaStage, Error<StagesCaptchaRetrieveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;

    let uri_str = format!(
        "{}/stages/captcha/{stage_uuid}/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::CaptchaStage`",
                )))
            }
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!(
                "Received `{unknown_type}` content type response that cannot be converted to `models::CaptchaStage`"
            )))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesCaptchaRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// CaptchaStage Viewset
pub async fn stages_captcha_update(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
    captcha_stage_request: models::CaptchaStageRequest,
) -> Result<models::CaptchaStage, Error<StagesCaptchaUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;
    let p_body_captcha_stage_request = captcha_stage_request;

    let uri_str = format!(
        "{}/stages/captcha/{stage_uuid}/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_captcha_stage_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::CaptchaStage`",
                )))
            }
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!(
                "Received `{unknown_type}` content type response that cannot be converted to `models::CaptchaStage`"
            )))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesCaptchaUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get a list of all objects that use this object
pub async fn stages_captcha_used_by_list(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
) -> Result<Vec<models::UsedBy>, Error<StagesCaptchaUsedByListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;

    let uri_str = format!(
        "{}/stages/captcha/{stage_uuid}/used_by/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesCaptchaUsedByListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// ConsentStage Viewset
pub async fn stages_consent_create(
    configuration: &configuration::Configuration,
    consent_stage_request: models::ConsentStageRequest,
) -> Result<models::ConsentStage, Error<StagesConsentCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_consent_stage_request = consent_stage_request;

    let uri_str = format!("{}/stages/consent/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_consent_stage_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::ConsentStage`",
                )))
            }
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!(
                "Received `{unknown_type}` content type response that cannot be converted to `models::ConsentStage`"
            )))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesConsentCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// ConsentStage Viewset
pub async fn stages_consent_destroy(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
) -> Result<(), Error<StagesConsentDestroyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;

    let uri_str = format!(
        "{}/stages/consent/{stage_uuid}/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesConsentDestroyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// ConsentStage Viewset
pub async fn stages_consent_list(
    configuration: &configuration::Configuration,
    consent_expire_in: Option<&str>,
    mode: Option<&str>,
    name: Option<&str>,
    ordering: Option<&str>,
    page: Option<i32>,
    page_size: Option<i32>,
    search: Option<&str>,
    stage_uuid: Option<&str>,
) -> Result<models::PaginatedConsentStageList, Error<StagesConsentListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_consent_expire_in = consent_expire_in;
    let p_query_mode = mode;
    let p_query_name = name;
    let p_query_ordering = ordering;
    let p_query_page = page;
    let p_query_page_size = page_size;
    let p_query_search = search;
    let p_query_stage_uuid = stage_uuid;

    let uri_str = format!("{}/stages/consent/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_consent_expire_in {
        req_builder = req_builder.query(&[("consent_expire_in", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_mode {
        req_builder = req_builder.query(&[("mode", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ordering {
        req_builder = req_builder.query(&[("ordering", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page_size {
        req_builder = req_builder.query(&[("page_size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_search {
        req_builder = req_builder.query(&[("search", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_stage_uuid {
        req_builder = req_builder.query(&[("stage_uuid", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginatedConsentStageList`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginatedConsentStageList`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesConsentListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// ConsentStage Viewset
pub async fn stages_consent_partial_update(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
    patched_consent_stage_request: Option<models::PatchedConsentStageRequest>,
) -> Result<models::ConsentStage, Error<StagesConsentPartialUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;
    let p_body_patched_consent_stage_request = patched_consent_stage_request;

    let uri_str = format!(
        "{}/stages/consent/{stage_uuid}/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_patched_consent_stage_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::ConsentStage`",
                )))
            }
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!(
                "Received `{unknown_type}` content type response that cannot be converted to `models::ConsentStage`"
            )))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesConsentPartialUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// ConsentStage Viewset
pub async fn stages_consent_retrieve(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
) -> Result<models::ConsentStage, Error<StagesConsentRetrieveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;

    let uri_str = format!(
        "{}/stages/consent/{stage_uuid}/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::ConsentStage`",
                )))
            }
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!(
                "Received `{unknown_type}` content type response that cannot be converted to `models::ConsentStage`"
            )))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesConsentRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// ConsentStage Viewset
pub async fn stages_consent_update(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
    consent_stage_request: models::ConsentStageRequest,
) -> Result<models::ConsentStage, Error<StagesConsentUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;
    let p_body_consent_stage_request = consent_stage_request;

    let uri_str = format!(
        "{}/stages/consent/{stage_uuid}/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_consent_stage_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::ConsentStage`",
                )))
            }
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!(
                "Received `{unknown_type}` content type response that cannot be converted to `models::ConsentStage`"
            )))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesConsentUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get a list of all objects that use this object
pub async fn stages_consent_used_by_list(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
) -> Result<Vec<models::UsedBy>, Error<StagesConsentUsedByListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;

    let uri_str = format!(
        "{}/stages/consent/{stage_uuid}/used_by/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesConsentUsedByListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// DenyStage Viewset
pub async fn stages_deny_create(
    configuration: &configuration::Configuration,
    deny_stage_request: models::DenyStageRequest,
) -> Result<models::DenyStage, Error<StagesDenyCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_deny_stage_request = deny_stage_request;

    let uri_str = format!("{}/stages/deny/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_deny_stage_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::DenyStage`",
                )))
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::DenyStage`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesDenyCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// DenyStage Viewset
pub async fn stages_deny_destroy(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
) -> Result<(), Error<StagesDenyDestroyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;

    let uri_str = format!(
        "{}/stages/deny/{stage_uuid}/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesDenyDestroyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// DenyStage Viewset
pub async fn stages_deny_list(
    configuration: &configuration::Configuration,
    deny_message: Option<&str>,
    name: Option<&str>,
    ordering: Option<&str>,
    page: Option<i32>,
    page_size: Option<i32>,
    search: Option<&str>,
    stage_uuid: Option<&str>,
) -> Result<models::PaginatedDenyStageList, Error<StagesDenyListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_deny_message = deny_message;
    let p_query_name = name;
    let p_query_ordering = ordering;
    let p_query_page = page;
    let p_query_page_size = page_size;
    let p_query_search = search;
    let p_query_stage_uuid = stage_uuid;

    let uri_str = format!("{}/stages/deny/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_deny_message {
        req_builder = req_builder.query(&[("deny_message", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ordering {
        req_builder = req_builder.query(&[("ordering", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page_size {
        req_builder = req_builder.query(&[("page_size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_search {
        req_builder = req_builder.query(&[("search", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_stage_uuid {
        req_builder = req_builder.query(&[("stage_uuid", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginatedDenyStageList`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginatedDenyStageList`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesDenyListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// DenyStage Viewset
pub async fn stages_deny_partial_update(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
    patched_deny_stage_request: Option<models::PatchedDenyStageRequest>,
) -> Result<models::DenyStage, Error<StagesDenyPartialUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;
    let p_body_patched_deny_stage_request = patched_deny_stage_request;

    let uri_str = format!(
        "{}/stages/deny/{stage_uuid}/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_patched_deny_stage_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::DenyStage`",
                )))
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::DenyStage`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesDenyPartialUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// DenyStage Viewset
pub async fn stages_deny_retrieve(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
) -> Result<models::DenyStage, Error<StagesDenyRetrieveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;

    let uri_str = format!(
        "{}/stages/deny/{stage_uuid}/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::DenyStage`",
                )))
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::DenyStage`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesDenyRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// DenyStage Viewset
pub async fn stages_deny_update(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
    deny_stage_request: models::DenyStageRequest,
) -> Result<models::DenyStage, Error<StagesDenyUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;
    let p_body_deny_stage_request = deny_stage_request;

    let uri_str = format!(
        "{}/stages/deny/{stage_uuid}/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_deny_stage_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::DenyStage`",
                )))
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::DenyStage`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesDenyUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get a list of all objects that use this object
pub async fn stages_deny_used_by_list(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
) -> Result<Vec<models::UsedBy>, Error<StagesDenyUsedByListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;

    let uri_str = format!(
        "{}/stages/deny/{stage_uuid}/used_by/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesDenyUsedByListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// DummyStage Viewset
pub async fn stages_dummy_create(
    configuration: &configuration::Configuration,
    dummy_stage_request: models::DummyStageRequest,
) -> Result<models::DummyStage, Error<StagesDummyCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_dummy_stage_request = dummy_stage_request;

    let uri_str = format!("{}/stages/dummy/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_dummy_stage_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::DummyStage`",
                )))
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::DummyStage`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesDummyCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// DummyStage Viewset
pub async fn stages_dummy_destroy(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
) -> Result<(), Error<StagesDummyDestroyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;

    let uri_str = format!(
        "{}/stages/dummy/{stage_uuid}/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesDummyDestroyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// DummyStage Viewset
pub async fn stages_dummy_list(
    configuration: &configuration::Configuration,
    name: Option<&str>,
    ordering: Option<&str>,
    page: Option<i32>,
    page_size: Option<i32>,
    search: Option<&str>,
    stage_uuid: Option<&str>,
    throw_error: Option<bool>,
) -> Result<models::PaginatedDummyStageList, Error<StagesDummyListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_name = name;
    let p_query_ordering = ordering;
    let p_query_page = page;
    let p_query_page_size = page_size;
    let p_query_search = search;
    let p_query_stage_uuid = stage_uuid;
    let p_query_throw_error = throw_error;

    let uri_str = format!("{}/stages/dummy/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ordering {
        req_builder = req_builder.query(&[("ordering", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page_size {
        req_builder = req_builder.query(&[("page_size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_search {
        req_builder = req_builder.query(&[("search", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_stage_uuid {
        req_builder = req_builder.query(&[("stage_uuid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_throw_error {
        req_builder = req_builder.query(&[("throw_error", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginatedDummyStageList`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginatedDummyStageList`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesDummyListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// DummyStage Viewset
pub async fn stages_dummy_partial_update(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
    patched_dummy_stage_request: Option<models::PatchedDummyStageRequest>,
) -> Result<models::DummyStage, Error<StagesDummyPartialUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;
    let p_body_patched_dummy_stage_request = patched_dummy_stage_request;

    let uri_str = format!(
        "{}/stages/dummy/{stage_uuid}/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_patched_dummy_stage_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::DummyStage`",
                )))
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::DummyStage`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesDummyPartialUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// DummyStage Viewset
pub async fn stages_dummy_retrieve(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
) -> Result<models::DummyStage, Error<StagesDummyRetrieveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;

    let uri_str = format!(
        "{}/stages/dummy/{stage_uuid}/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::DummyStage`",
                )))
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::DummyStage`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesDummyRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// DummyStage Viewset
pub async fn stages_dummy_update(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
    dummy_stage_request: models::DummyStageRequest,
) -> Result<models::DummyStage, Error<StagesDummyUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;
    let p_body_dummy_stage_request = dummy_stage_request;

    let uri_str = format!(
        "{}/stages/dummy/{stage_uuid}/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_dummy_stage_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::DummyStage`",
                )))
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::DummyStage`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesDummyUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get a list of all objects that use this object
pub async fn stages_dummy_used_by_list(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
) -> Result<Vec<models::UsedBy>, Error<StagesDummyUsedByListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;

    let uri_str = format!(
        "{}/stages/dummy/{stage_uuid}/used_by/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesDummyUsedByListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// EmailStage Viewset
pub async fn stages_email_create(
    configuration: &configuration::Configuration,
    email_stage_request: models::EmailStageRequest,
) -> Result<models::EmailStage, Error<StagesEmailCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_email_stage_request = email_stage_request;

    let uri_str = format!("{}/stages/email/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_email_stage_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::EmailStage`",
                )))
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::EmailStage`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesEmailCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// EmailStage Viewset
pub async fn stages_email_destroy(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
) -> Result<(), Error<StagesEmailDestroyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;

    let uri_str = format!(
        "{}/stages/email/{stage_uuid}/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesEmailDestroyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// EmailStage Viewset
pub async fn stages_email_list(
    configuration: &configuration::Configuration,
    activate_user_on_success: Option<bool>,
    from_address: Option<&str>,
    host: Option<&str>,
    name: Option<&str>,
    ordering: Option<&str>,
    page: Option<i32>,
    page_size: Option<i32>,
    port: Option<i32>,
    search: Option<&str>,
    subject: Option<&str>,
    template: Option<&str>,
    timeout: Option<i32>,
    token_expiry: Option<&str>,
    use_global_settings: Option<bool>,
    use_ssl: Option<bool>,
    use_tls: Option<bool>,
    username: Option<&str>,
) -> Result<models::PaginatedEmailStageList, Error<StagesEmailListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_activate_user_on_success = activate_user_on_success;
    let p_query_from_address = from_address;
    let p_query_host = host;
    let p_query_name = name;
    let p_query_ordering = ordering;
    let p_query_page = page;
    let p_query_page_size = page_size;
    let p_query_port = port;
    let p_query_search = search;
    let p_query_subject = subject;
    let p_query_template = template;
    let p_query_timeout = timeout;
    let p_query_token_expiry = token_expiry;
    let p_query_use_global_settings = use_global_settings;
    let p_query_use_ssl = use_ssl;
    let p_query_use_tls = use_tls;
    let p_query_username = username;

    let uri_str = format!("{}/stages/email/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_activate_user_on_success {
        req_builder = req_builder.query(&[("activate_user_on_success", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_from_address {
        req_builder = req_builder.query(&[("from_address", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_host {
        req_builder = req_builder.query(&[("host", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ordering {
        req_builder = req_builder.query(&[("ordering", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page_size {
        req_builder = req_builder.query(&[("page_size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_port {
        req_builder = req_builder.query(&[("port", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_search {
        req_builder = req_builder.query(&[("search", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_subject {
        req_builder = req_builder.query(&[("subject", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_template {
        req_builder = req_builder.query(&[("template", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_timeout {
        req_builder = req_builder.query(&[("timeout", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_token_expiry {
        req_builder = req_builder.query(&[("token_expiry", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_use_global_settings {
        req_builder = req_builder.query(&[("use_global_settings", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_use_ssl {
        req_builder = req_builder.query(&[("use_ssl", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_use_tls {
        req_builder = req_builder.query(&[("use_tls", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_username {
        req_builder = req_builder.query(&[("username", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginatedEmailStageList`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginatedEmailStageList`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesEmailListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// EmailStage Viewset
pub async fn stages_email_partial_update(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
    patched_email_stage_request: Option<models::PatchedEmailStageRequest>,
) -> Result<models::EmailStage, Error<StagesEmailPartialUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;
    let p_body_patched_email_stage_request = patched_email_stage_request;

    let uri_str = format!(
        "{}/stages/email/{stage_uuid}/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_patched_email_stage_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::EmailStage`",
                )))
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::EmailStage`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesEmailPartialUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// EmailStage Viewset
pub async fn stages_email_retrieve(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
) -> Result<models::EmailStage, Error<StagesEmailRetrieveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;

    let uri_str = format!(
        "{}/stages/email/{stage_uuid}/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::EmailStage`",
                )))
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::EmailStage`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesEmailRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get all available templates, including custom templates
pub async fn stages_email_templates_list(
    configuration: &configuration::Configuration,
) -> Result<Vec<models::TypeCreate>, Error<StagesEmailTemplatesListError>> {
    let uri_str = format!("{}/stages/email/templates/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::TypeCreate&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::TypeCreate&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesEmailTemplatesListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// EmailStage Viewset
pub async fn stages_email_update(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
    email_stage_request: models::EmailStageRequest,
) -> Result<models::EmailStage, Error<StagesEmailUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;
    let p_body_email_stage_request = email_stage_request;

    let uri_str = format!(
        "{}/stages/email/{stage_uuid}/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_email_stage_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::EmailStage`",
                )))
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::EmailStage`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesEmailUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get a list of all objects that use this object
pub async fn stages_email_used_by_list(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
) -> Result<Vec<models::UsedBy>, Error<StagesEmailUsedByListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;

    let uri_str = format!(
        "{}/stages/email/{stage_uuid}/used_by/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesEmailUsedByListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// IdentificationStage Viewset
pub async fn stages_identification_create(
    configuration: &configuration::Configuration,
    identification_stage_request: models::IdentificationStageRequest,
) -> Result<models::IdentificationStage, Error<StagesIdentificationCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_identification_stage_request = identification_stage_request;

    let uri_str = format!("{}/stages/identification/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_identification_stage_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::IdentificationStage`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::IdentificationStage`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesIdentificationCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// IdentificationStage Viewset
pub async fn stages_identification_destroy(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
) -> Result<(), Error<StagesIdentificationDestroyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;

    let uri_str = format!(
        "{}/stages/identification/{stage_uuid}/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesIdentificationDestroyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// IdentificationStage Viewset
pub async fn stages_identification_list(
    configuration: &configuration::Configuration,
    captcha_stage: Option<&str>,
    case_insensitive_matching: Option<bool>,
    enrollment_flow: Option<&str>,
    name: Option<&str>,
    ordering: Option<&str>,
    page: Option<i32>,
    page_size: Option<i32>,
    password_stage: Option<&str>,
    passwordless_flow: Option<&str>,
    recovery_flow: Option<&str>,
    search: Option<&str>,
    show_matched_user: Option<bool>,
    show_source_labels: Option<bool>,
) -> Result<models::PaginatedIdentificationStageList, Error<StagesIdentificationListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_captcha_stage = captcha_stage;
    let p_query_case_insensitive_matching = case_insensitive_matching;
    let p_query_enrollment_flow = enrollment_flow;
    let p_query_name = name;
    let p_query_ordering = ordering;
    let p_query_page = page;
    let p_query_page_size = page_size;
    let p_query_password_stage = password_stage;
    let p_query_passwordless_flow = passwordless_flow;
    let p_query_recovery_flow = recovery_flow;
    let p_query_search = search;
    let p_query_show_matched_user = show_matched_user;
    let p_query_show_source_labels = show_source_labels;

    let uri_str = format!("{}/stages/identification/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_captcha_stage {
        req_builder = req_builder.query(&[("captcha_stage", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_case_insensitive_matching {
        req_builder = req_builder.query(&[("case_insensitive_matching", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_enrollment_flow {
        req_builder = req_builder.query(&[("enrollment_flow", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ordering {
        req_builder = req_builder.query(&[("ordering", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page_size {
        req_builder = req_builder.query(&[("page_size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_password_stage {
        req_builder = req_builder.query(&[("password_stage", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_passwordless_flow {
        req_builder = req_builder.query(&[("passwordless_flow", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_recovery_flow {
        req_builder = req_builder.query(&[("recovery_flow", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_search {
        req_builder = req_builder.query(&[("search", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_show_matched_user {
        req_builder = req_builder.query(&[("show_matched_user", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_show_source_labels {
        req_builder = req_builder.query(&[("show_source_labels", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginatedIdentificationStageList`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginatedIdentificationStageList`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesIdentificationListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// IdentificationStage Viewset
pub async fn stages_identification_partial_update(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
    patched_identification_stage_request: Option<models::PatchedIdentificationStageRequest>,
) -> Result<models::IdentificationStage, Error<StagesIdentificationPartialUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;
    let p_body_patched_identification_stage_request = patched_identification_stage_request;

    let uri_str = format!(
        "{}/stages/identification/{stage_uuid}/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_patched_identification_stage_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::IdentificationStage`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::IdentificationStage`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesIdentificationPartialUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// IdentificationStage Viewset
pub async fn stages_identification_retrieve(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
) -> Result<models::IdentificationStage, Error<StagesIdentificationRetrieveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;

    let uri_str = format!(
        "{}/stages/identification/{stage_uuid}/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::IdentificationStage`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::IdentificationStage`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesIdentificationRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// IdentificationStage Viewset
pub async fn stages_identification_update(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
    identification_stage_request: models::IdentificationStageRequest,
) -> Result<models::IdentificationStage, Error<StagesIdentificationUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;
    let p_body_identification_stage_request = identification_stage_request;

    let uri_str = format!(
        "{}/stages/identification/{stage_uuid}/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_identification_stage_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::IdentificationStage`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::IdentificationStage`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesIdentificationUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get a list of all objects that use this object
pub async fn stages_identification_used_by_list(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
) -> Result<Vec<models::UsedBy>, Error<StagesIdentificationUsedByListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;

    let uri_str = format!(
        "{}/stages/identification/{stage_uuid}/used_by/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesIdentificationUsedByListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Invitation Viewset
pub async fn stages_invitation_invitations_create(
    configuration: &configuration::Configuration,
    invitation_request: models::InvitationRequest,
) -> Result<models::Invitation, Error<StagesInvitationInvitationsCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_invitation_request = invitation_request;

    let uri_str = format!("{}/stages/invitation/invitations/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_invitation_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::Invitation`",
                )))
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::Invitation`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesInvitationInvitationsCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Invitation Viewset
pub async fn stages_invitation_invitations_destroy(
    configuration: &configuration::Configuration,
    invite_uuid: &str,
) -> Result<(), Error<StagesInvitationInvitationsDestroyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_invite_uuid = invite_uuid;

    let uri_str = format!(
        "{}/stages/invitation/invitations/{invite_uuid}/",
        configuration.base_path,
        invite_uuid = crate::apis::urlencode(p_path_invite_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesInvitationInvitationsDestroyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Invitation Viewset
pub async fn stages_invitation_invitations_list(
    configuration: &configuration::Configuration,
    created_by__username: Option<&str>,
    expires: Option<String>,
    flow__slug: Option<&str>,
    name: Option<&str>,
    ordering: Option<&str>,
    page: Option<i32>,
    page_size: Option<i32>,
    search: Option<&str>,
) -> Result<models::PaginatedInvitationList, Error<StagesInvitationInvitationsListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_created_by__username = created_by__username;
    let p_query_expires = expires;
    let p_query_flow__slug = flow__slug;
    let p_query_name = name;
    let p_query_ordering = ordering;
    let p_query_page = page;
    let p_query_page_size = page_size;
    let p_query_search = search;

    let uri_str = format!("{}/stages/invitation/invitations/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_created_by__username {
        req_builder = req_builder.query(&[("created_by__username", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_expires {
        req_builder = req_builder.query(&[("expires", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_flow__slug {
        req_builder = req_builder.query(&[("flow__slug", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ordering {
        req_builder = req_builder.query(&[("ordering", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page_size {
        req_builder = req_builder.query(&[("page_size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_search {
        req_builder = req_builder.query(&[("search", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginatedInvitationList`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginatedInvitationList`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesInvitationInvitationsListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Invitation Viewset
pub async fn stages_invitation_invitations_partial_update(
    configuration: &configuration::Configuration,
    invite_uuid: &str,
    patched_invitation_request: Option<models::PatchedInvitationRequest>,
) -> Result<models::Invitation, Error<StagesInvitationInvitationsPartialUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_invite_uuid = invite_uuid;
    let p_body_patched_invitation_request = patched_invitation_request;

    let uri_str = format!(
        "{}/stages/invitation/invitations/{invite_uuid}/",
        configuration.base_path,
        invite_uuid = crate::apis::urlencode(p_path_invite_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_patched_invitation_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::Invitation`",
                )))
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::Invitation`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesInvitationInvitationsPartialUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Invitation Viewset
pub async fn stages_invitation_invitations_retrieve(
    configuration: &configuration::Configuration,
    invite_uuid: &str,
) -> Result<models::Invitation, Error<StagesInvitationInvitationsRetrieveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_invite_uuid = invite_uuid;

    let uri_str = format!(
        "{}/stages/invitation/invitations/{invite_uuid}/",
        configuration.base_path,
        invite_uuid = crate::apis::urlencode(p_path_invite_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::Invitation`",
                )))
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::Invitation`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesInvitationInvitationsRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Invitation Viewset
pub async fn stages_invitation_invitations_update(
    configuration: &configuration::Configuration,
    invite_uuid: &str,
    invitation_request: models::InvitationRequest,
) -> Result<models::Invitation, Error<StagesInvitationInvitationsUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_invite_uuid = invite_uuid;
    let p_body_invitation_request = invitation_request;

    let uri_str = format!(
        "{}/stages/invitation/invitations/{invite_uuid}/",
        configuration.base_path,
        invite_uuid = crate::apis::urlencode(p_path_invite_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_invitation_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::Invitation`",
                )))
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::Invitation`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesInvitationInvitationsUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get a list of all objects that use this object
pub async fn stages_invitation_invitations_used_by_list(
    configuration: &configuration::Configuration,
    invite_uuid: &str,
) -> Result<Vec<models::UsedBy>, Error<StagesInvitationInvitationsUsedByListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_invite_uuid = invite_uuid;

    let uri_str = format!(
        "{}/stages/invitation/invitations/{invite_uuid}/used_by/",
        configuration.base_path,
        invite_uuid = crate::apis::urlencode(p_path_invite_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesInvitationInvitationsUsedByListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// InvitationStage Viewset
pub async fn stages_invitation_stages_create(
    configuration: &configuration::Configuration,
    invitation_stage_request: models::InvitationStageRequest,
) -> Result<models::InvitationStage, Error<StagesInvitationStagesCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_invitation_stage_request = invitation_stage_request;

    let uri_str = format!("{}/stages/invitation/stages/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_invitation_stage_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::InvitationStage`",
                )))
            }
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!(
                "Received `{unknown_type}` content type response that cannot be converted to `models::InvitationStage`"
            )))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesInvitationStagesCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// InvitationStage Viewset
pub async fn stages_invitation_stages_destroy(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
) -> Result<(), Error<StagesInvitationStagesDestroyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;

    let uri_str = format!(
        "{}/stages/invitation/stages/{stage_uuid}/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesInvitationStagesDestroyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// InvitationStage Viewset
pub async fn stages_invitation_stages_list(
    configuration: &configuration::Configuration,
    continue_flow_without_invitation: Option<bool>,
    name: Option<&str>,
    no_flows: Option<bool>,
    ordering: Option<&str>,
    page: Option<i32>,
    page_size: Option<i32>,
    search: Option<&str>,
    stage_uuid: Option<&str>,
) -> Result<models::PaginatedInvitationStageList, Error<StagesInvitationStagesListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_continue_flow_without_invitation = continue_flow_without_invitation;
    let p_query_name = name;
    let p_query_no_flows = no_flows;
    let p_query_ordering = ordering;
    let p_query_page = page;
    let p_query_page_size = page_size;
    let p_query_search = search;
    let p_query_stage_uuid = stage_uuid;

    let uri_str = format!("{}/stages/invitation/stages/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_continue_flow_without_invitation {
        req_builder = req_builder.query(&[("continue_flow_without_invitation", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_no_flows {
        req_builder = req_builder.query(&[("no_flows", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ordering {
        req_builder = req_builder.query(&[("ordering", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page_size {
        req_builder = req_builder.query(&[("page_size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_search {
        req_builder = req_builder.query(&[("search", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_stage_uuid {
        req_builder = req_builder.query(&[("stage_uuid", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginatedInvitationStageList`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginatedInvitationStageList`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesInvitationStagesListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// InvitationStage Viewset
pub async fn stages_invitation_stages_partial_update(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
    patched_invitation_stage_request: Option<models::PatchedInvitationStageRequest>,
) -> Result<models::InvitationStage, Error<StagesInvitationStagesPartialUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;
    let p_body_patched_invitation_stage_request = patched_invitation_stage_request;

    let uri_str = format!(
        "{}/stages/invitation/stages/{stage_uuid}/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_patched_invitation_stage_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::InvitationStage`",
                )))
            }
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!(
                "Received `{unknown_type}` content type response that cannot be converted to `models::InvitationStage`"
            )))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesInvitationStagesPartialUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// InvitationStage Viewset
pub async fn stages_invitation_stages_retrieve(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
) -> Result<models::InvitationStage, Error<StagesInvitationStagesRetrieveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;

    let uri_str = format!(
        "{}/stages/invitation/stages/{stage_uuid}/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::InvitationStage`",
                )))
            }
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!(
                "Received `{unknown_type}` content type response that cannot be converted to `models::InvitationStage`"
            )))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesInvitationStagesRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// InvitationStage Viewset
pub async fn stages_invitation_stages_update(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
    invitation_stage_request: models::InvitationStageRequest,
) -> Result<models::InvitationStage, Error<StagesInvitationStagesUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;
    let p_body_invitation_stage_request = invitation_stage_request;

    let uri_str = format!(
        "{}/stages/invitation/stages/{stage_uuid}/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_invitation_stage_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::InvitationStage`",
                )))
            }
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!(
                "Received `{unknown_type}` content type response that cannot be converted to `models::InvitationStage`"
            )))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesInvitationStagesUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get a list of all objects that use this object
pub async fn stages_invitation_stages_used_by_list(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
) -> Result<Vec<models::UsedBy>, Error<StagesInvitationStagesUsedByListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;

    let uri_str = format!(
        "{}/stages/invitation/stages/{stage_uuid}/used_by/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesInvitationStagesUsedByListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// MutualTLSStage Viewset
pub async fn stages_mtls_create(
    configuration: &configuration::Configuration,
    mutual_tls_stage_request: models::MutualTlsStageRequest,
) -> Result<models::MutualTlsStage, Error<StagesMtlsCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_mutual_tls_stage_request = mutual_tls_stage_request;

    let uri_str = format!("{}/stages/mtls/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_mutual_tls_stage_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::MutualTlsStage`",
                )))
            }
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!(
                "Received `{unknown_type}` content type response that cannot be converted to `models::MutualTlsStage`"
            )))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesMtlsCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// MutualTLSStage Viewset
pub async fn stages_mtls_destroy(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
) -> Result<(), Error<StagesMtlsDestroyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;

    let uri_str = format!(
        "{}/stages/mtls/{stage_uuid}/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesMtlsDestroyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// MutualTLSStage Viewset
pub async fn stages_mtls_list(
    configuration: &configuration::Configuration,
    cert_attribute: Option<&str>,
    certificate_authorities: Option<Vec<uuid::Uuid>>,
    mode: Option<&str>,
    name: Option<&str>,
    ordering: Option<&str>,
    page: Option<i32>,
    page_size: Option<i32>,
    search: Option<&str>,
    stage_uuid: Option<&str>,
    user_attribute: Option<&str>,
) -> Result<models::PaginatedMutualTlsStageList, Error<StagesMtlsListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_cert_attribute = cert_attribute;
    let p_query_certificate_authorities = certificate_authorities;
    let p_query_mode = mode;
    let p_query_name = name;
    let p_query_ordering = ordering;
    let p_query_page = page;
    let p_query_page_size = page_size;
    let p_query_search = search;
    let p_query_stage_uuid = stage_uuid;
    let p_query_user_attribute = user_attribute;

    let uri_str = format!("{}/stages/mtls/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_cert_attribute {
        req_builder = req_builder.query(&[("cert_attribute", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_certificate_authorities {
        req_builder = match "multi" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("certificate_authorities".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "certificate_authorities",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = p_query_mode {
        req_builder = req_builder.query(&[("mode", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ordering {
        req_builder = req_builder.query(&[("ordering", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page_size {
        req_builder = req_builder.query(&[("page_size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_search {
        req_builder = req_builder.query(&[("search", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_stage_uuid {
        req_builder = req_builder.query(&[("stage_uuid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_user_attribute {
        req_builder = req_builder.query(&[("user_attribute", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginatedMutualTlsStageList`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginatedMutualTlsStageList`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesMtlsListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// MutualTLSStage Viewset
pub async fn stages_mtls_partial_update(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
    patched_mutual_tls_stage_request: Option<models::PatchedMutualTlsStageRequest>,
) -> Result<models::MutualTlsStage, Error<StagesMtlsPartialUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;
    let p_body_patched_mutual_tls_stage_request = patched_mutual_tls_stage_request;

    let uri_str = format!(
        "{}/stages/mtls/{stage_uuid}/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_patched_mutual_tls_stage_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::MutualTlsStage`",
                )))
            }
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!(
                "Received `{unknown_type}` content type response that cannot be converted to `models::MutualTlsStage`"
            )))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesMtlsPartialUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// MutualTLSStage Viewset
pub async fn stages_mtls_retrieve(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
) -> Result<models::MutualTlsStage, Error<StagesMtlsRetrieveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;

    let uri_str = format!(
        "{}/stages/mtls/{stage_uuid}/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::MutualTlsStage`",
                )))
            }
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!(
                "Received `{unknown_type}` content type response that cannot be converted to `models::MutualTlsStage`"
            )))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesMtlsRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// MutualTLSStage Viewset
pub async fn stages_mtls_update(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
    mutual_tls_stage_request: models::MutualTlsStageRequest,
) -> Result<models::MutualTlsStage, Error<StagesMtlsUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;
    let p_body_mutual_tls_stage_request = mutual_tls_stage_request;

    let uri_str = format!(
        "{}/stages/mtls/{stage_uuid}/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_mutual_tls_stage_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::MutualTlsStage`",
                )))
            }
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!(
                "Received `{unknown_type}` content type response that cannot be converted to `models::MutualTlsStage`"
            )))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesMtlsUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get a list of all objects that use this object
pub async fn stages_mtls_used_by_list(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
) -> Result<Vec<models::UsedBy>, Error<StagesMtlsUsedByListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;

    let uri_str = format!(
        "{}/stages/mtls/{stage_uuid}/used_by/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesMtlsUsedByListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// PasswordStage Viewset
pub async fn stages_password_create(
    configuration: &configuration::Configuration,
    password_stage_request: models::PasswordStageRequest,
) -> Result<models::PasswordStage, Error<StagesPasswordCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_password_stage_request = password_stage_request;

    let uri_str = format!("{}/stages/password/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_password_stage_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::PasswordStage`",
                )))
            }
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!(
                "Received `{unknown_type}` content type response that cannot be converted to `models::PasswordStage`"
            )))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesPasswordCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// PasswordStage Viewset
pub async fn stages_password_destroy(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
) -> Result<(), Error<StagesPasswordDestroyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;

    let uri_str = format!(
        "{}/stages/password/{stage_uuid}/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesPasswordDestroyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// PasswordStage Viewset
pub async fn stages_password_list(
    configuration: &configuration::Configuration,
    allow_show_password: Option<bool>,
    configure_flow: Option<&str>,
    failed_attempts_before_cancel: Option<i32>,
    name: Option<&str>,
    ordering: Option<&str>,
    page: Option<i32>,
    page_size: Option<i32>,
    search: Option<&str>,
) -> Result<models::PaginatedPasswordStageList, Error<StagesPasswordListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_allow_show_password = allow_show_password;
    let p_query_configure_flow = configure_flow;
    let p_query_failed_attempts_before_cancel = failed_attempts_before_cancel;
    let p_query_name = name;
    let p_query_ordering = ordering;
    let p_query_page = page;
    let p_query_page_size = page_size;
    let p_query_search = search;

    let uri_str = format!("{}/stages/password/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_allow_show_password {
        req_builder = req_builder.query(&[("allow_show_password", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_configure_flow {
        req_builder = req_builder.query(&[("configure_flow", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_failed_attempts_before_cancel {
        req_builder = req_builder.query(&[("failed_attempts_before_cancel", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ordering {
        req_builder = req_builder.query(&[("ordering", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page_size {
        req_builder = req_builder.query(&[("page_size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_search {
        req_builder = req_builder.query(&[("search", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginatedPasswordStageList`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginatedPasswordStageList`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesPasswordListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// PasswordStage Viewset
pub async fn stages_password_partial_update(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
    patched_password_stage_request: Option<models::PatchedPasswordStageRequest>,
) -> Result<models::PasswordStage, Error<StagesPasswordPartialUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;
    let p_body_patched_password_stage_request = patched_password_stage_request;

    let uri_str = format!(
        "{}/stages/password/{stage_uuid}/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_patched_password_stage_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::PasswordStage`",
                )))
            }
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!(
                "Received `{unknown_type}` content type response that cannot be converted to `models::PasswordStage`"
            )))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesPasswordPartialUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// PasswordStage Viewset
pub async fn stages_password_retrieve(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
) -> Result<models::PasswordStage, Error<StagesPasswordRetrieveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;

    let uri_str = format!(
        "{}/stages/password/{stage_uuid}/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::PasswordStage`",
                )))
            }
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!(
                "Received `{unknown_type}` content type response that cannot be converted to `models::PasswordStage`"
            )))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesPasswordRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// PasswordStage Viewset
pub async fn stages_password_update(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
    password_stage_request: models::PasswordStageRequest,
) -> Result<models::PasswordStage, Error<StagesPasswordUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;
    let p_body_password_stage_request = password_stage_request;

    let uri_str = format!(
        "{}/stages/password/{stage_uuid}/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_password_stage_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::PasswordStage`",
                )))
            }
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!(
                "Received `{unknown_type}` content type response that cannot be converted to `models::PasswordStage`"
            )))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesPasswordUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get a list of all objects that use this object
pub async fn stages_password_used_by_list(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
) -> Result<Vec<models::UsedBy>, Error<StagesPasswordUsedByListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;

    let uri_str = format!(
        "{}/stages/password/{stage_uuid}/used_by/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesPasswordUsedByListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Prompt Viewset
pub async fn stages_prompt_prompts_create(
    configuration: &configuration::Configuration,
    prompt_request: models::PromptRequest,
) -> Result<models::Prompt, Error<StagesPromptPromptsCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_prompt_request = prompt_request;

    let uri_str = format!("{}/stages/prompt/prompts/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_prompt_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::Prompt`",
                )))
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::Prompt`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesPromptPromptsCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Prompt Viewset
pub async fn stages_prompt_prompts_destroy(
    configuration: &configuration::Configuration,
    prompt_uuid: &str,
) -> Result<(), Error<StagesPromptPromptsDestroyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_prompt_uuid = prompt_uuid;

    let uri_str = format!(
        "{}/stages/prompt/prompts/{prompt_uuid}/",
        configuration.base_path,
        prompt_uuid = crate::apis::urlencode(p_path_prompt_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesPromptPromptsDestroyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Prompt Viewset
pub async fn stages_prompt_prompts_list(
    configuration: &configuration::Configuration,
    field_key: Option<&str>,
    label: Option<&str>,
    name: Option<&str>,
    ordering: Option<&str>,
    page: Option<i32>,
    page_size: Option<i32>,
    placeholder: Option<&str>,
    search: Option<&str>,
    r#type: Option<&str>,
) -> Result<models::PaginatedPromptList, Error<StagesPromptPromptsListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_field_key = field_key;
    let p_query_label = label;
    let p_query_name = name;
    let p_query_ordering = ordering;
    let p_query_page = page;
    let p_query_page_size = page_size;
    let p_query_placeholder = placeholder;
    let p_query_search = search;
    let p_query_type = r#type;

    let uri_str = format!("{}/stages/prompt/prompts/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_field_key {
        req_builder = req_builder.query(&[("field_key", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_label {
        req_builder = req_builder.query(&[("label", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ordering {
        req_builder = req_builder.query(&[("ordering", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page_size {
        req_builder = req_builder.query(&[("page_size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_placeholder {
        req_builder = req_builder.query(&[("placeholder", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_search {
        req_builder = req_builder.query(&[("search", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = req_builder.query(&[("type", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginatedPromptList`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginatedPromptList`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesPromptPromptsListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Prompt Viewset
pub async fn stages_prompt_prompts_partial_update(
    configuration: &configuration::Configuration,
    prompt_uuid: &str,
    patched_prompt_request: Option<models::PatchedPromptRequest>,
) -> Result<models::Prompt, Error<StagesPromptPromptsPartialUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_prompt_uuid = prompt_uuid;
    let p_body_patched_prompt_request = patched_prompt_request;

    let uri_str = format!(
        "{}/stages/prompt/prompts/{prompt_uuid}/",
        configuration.base_path,
        prompt_uuid = crate::apis::urlencode(p_path_prompt_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_patched_prompt_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::Prompt`",
                )))
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::Prompt`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesPromptPromptsPartialUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Preview a prompt as a challenge, just like a flow would receive
pub async fn stages_prompt_prompts_preview_create(
    configuration: &configuration::Configuration,
    prompt_request: models::PromptRequest,
) -> Result<models::PromptChallenge, Error<StagesPromptPromptsPreviewCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_prompt_request = prompt_request;

    let uri_str = format!("{}/stages/prompt/prompts/preview/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_prompt_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::PromptChallenge`",
                )))
            }
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!(
                "Received `{unknown_type}` content type response that cannot be converted to `models::PromptChallenge`"
            )))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesPromptPromptsPreviewCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Prompt Viewset
pub async fn stages_prompt_prompts_retrieve(
    configuration: &configuration::Configuration,
    prompt_uuid: &str,
) -> Result<models::Prompt, Error<StagesPromptPromptsRetrieveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_prompt_uuid = prompt_uuid;

    let uri_str = format!(
        "{}/stages/prompt/prompts/{prompt_uuid}/",
        configuration.base_path,
        prompt_uuid = crate::apis::urlencode(p_path_prompt_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::Prompt`",
                )))
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::Prompt`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesPromptPromptsRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Prompt Viewset
pub async fn stages_prompt_prompts_update(
    configuration: &configuration::Configuration,
    prompt_uuid: &str,
    prompt_request: models::PromptRequest,
) -> Result<models::Prompt, Error<StagesPromptPromptsUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_prompt_uuid = prompt_uuid;
    let p_body_prompt_request = prompt_request;

    let uri_str = format!(
        "{}/stages/prompt/prompts/{prompt_uuid}/",
        configuration.base_path,
        prompt_uuid = crate::apis::urlencode(p_path_prompt_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_prompt_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::Prompt`",
                )))
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::Prompt`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesPromptPromptsUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get a list of all objects that use this object
pub async fn stages_prompt_prompts_used_by_list(
    configuration: &configuration::Configuration,
    prompt_uuid: &str,
) -> Result<Vec<models::UsedBy>, Error<StagesPromptPromptsUsedByListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_prompt_uuid = prompt_uuid;

    let uri_str = format!(
        "{}/stages/prompt/prompts/{prompt_uuid}/used_by/",
        configuration.base_path,
        prompt_uuid = crate::apis::urlencode(p_path_prompt_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesPromptPromptsUsedByListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// PromptStage Viewset
pub async fn stages_prompt_stages_create(
    configuration: &configuration::Configuration,
    prompt_stage_request: models::PromptStageRequest,
) -> Result<models::PromptStage, Error<StagesPromptStagesCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_prompt_stage_request = prompt_stage_request;

    let uri_str = format!("{}/stages/prompt/stages/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_prompt_stage_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::PromptStage`",
                )))
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::PromptStage`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesPromptStagesCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// PromptStage Viewset
pub async fn stages_prompt_stages_destroy(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
) -> Result<(), Error<StagesPromptStagesDestroyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;

    let uri_str = format!(
        "{}/stages/prompt/stages/{stage_uuid}/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesPromptStagesDestroyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// PromptStage Viewset
pub async fn stages_prompt_stages_list(
    configuration: &configuration::Configuration,
    fields: Option<Vec<uuid::Uuid>>,
    name: Option<&str>,
    ordering: Option<&str>,
    page: Option<i32>,
    page_size: Option<i32>,
    search: Option<&str>,
    stage_uuid: Option<&str>,
    validation_policies: Option<Vec<uuid::Uuid>>,
) -> Result<models::PaginatedPromptStageList, Error<StagesPromptStagesListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_fields = fields;
    let p_query_name = name;
    let p_query_ordering = ordering;
    let p_query_page = page;
    let p_query_page_size = page_size;
    let p_query_search = search;
    let p_query_stage_uuid = stage_uuid;
    let p_query_validation_policies = validation_policies;

    let uri_str = format!("{}/stages/prompt/stages/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_fields {
        req_builder = match "multi" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("fields".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "fields",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = p_query_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ordering {
        req_builder = req_builder.query(&[("ordering", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page_size {
        req_builder = req_builder.query(&[("page_size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_search {
        req_builder = req_builder.query(&[("search", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_stage_uuid {
        req_builder = req_builder.query(&[("stage_uuid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_validation_policies {
        req_builder = match "multi" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("validation_policies".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "validation_policies",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginatedPromptStageList`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginatedPromptStageList`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesPromptStagesListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// PromptStage Viewset
pub async fn stages_prompt_stages_partial_update(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
    patched_prompt_stage_request: Option<models::PatchedPromptStageRequest>,
) -> Result<models::PromptStage, Error<StagesPromptStagesPartialUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;
    let p_body_patched_prompt_stage_request = patched_prompt_stage_request;

    let uri_str = format!(
        "{}/stages/prompt/stages/{stage_uuid}/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_patched_prompt_stage_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::PromptStage`",
                )))
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::PromptStage`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesPromptStagesPartialUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// PromptStage Viewset
pub async fn stages_prompt_stages_retrieve(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
) -> Result<models::PromptStage, Error<StagesPromptStagesRetrieveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;

    let uri_str = format!(
        "{}/stages/prompt/stages/{stage_uuid}/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::PromptStage`",
                )))
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::PromptStage`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesPromptStagesRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// PromptStage Viewset
pub async fn stages_prompt_stages_update(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
    prompt_stage_request: models::PromptStageRequest,
) -> Result<models::PromptStage, Error<StagesPromptStagesUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;
    let p_body_prompt_stage_request = prompt_stage_request;

    let uri_str = format!(
        "{}/stages/prompt/stages/{stage_uuid}/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_prompt_stage_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::PromptStage`",
                )))
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::PromptStage`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesPromptStagesUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get a list of all objects that use this object
pub async fn stages_prompt_stages_used_by_list(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
) -> Result<Vec<models::UsedBy>, Error<StagesPromptStagesUsedByListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;

    let uri_str = format!(
        "{}/stages/prompt/stages/{stage_uuid}/used_by/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesPromptStagesUsedByListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// RedirectStage Viewset
pub async fn stages_redirect_create(
    configuration: &configuration::Configuration,
    redirect_stage_request: models::RedirectStageRequest,
) -> Result<models::RedirectStage, Error<StagesRedirectCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_redirect_stage_request = redirect_stage_request;

    let uri_str = format!("{}/stages/redirect/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_redirect_stage_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::RedirectStage`",
                )))
            }
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!(
                "Received `{unknown_type}` content type response that cannot be converted to `models::RedirectStage`"
            )))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesRedirectCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// RedirectStage Viewset
pub async fn stages_redirect_destroy(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
) -> Result<(), Error<StagesRedirectDestroyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;

    let uri_str = format!(
        "{}/stages/redirect/{stage_uuid}/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesRedirectDestroyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// RedirectStage Viewset
pub async fn stages_redirect_list(
    configuration: &configuration::Configuration,
    name: Option<&str>,
    ordering: Option<&str>,
    page: Option<i32>,
    page_size: Option<i32>,
    search: Option<&str>,
) -> Result<models::PaginatedRedirectStageList, Error<StagesRedirectListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_name = name;
    let p_query_ordering = ordering;
    let p_query_page = page;
    let p_query_page_size = page_size;
    let p_query_search = search;

    let uri_str = format!("{}/stages/redirect/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ordering {
        req_builder = req_builder.query(&[("ordering", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page_size {
        req_builder = req_builder.query(&[("page_size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_search {
        req_builder = req_builder.query(&[("search", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginatedRedirectStageList`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginatedRedirectStageList`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesRedirectListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// RedirectStage Viewset
pub async fn stages_redirect_partial_update(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
    patched_redirect_stage_request: Option<models::PatchedRedirectStageRequest>,
) -> Result<models::RedirectStage, Error<StagesRedirectPartialUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;
    let p_body_patched_redirect_stage_request = patched_redirect_stage_request;

    let uri_str = format!(
        "{}/stages/redirect/{stage_uuid}/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_patched_redirect_stage_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::RedirectStage`",
                )))
            }
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!(
                "Received `{unknown_type}` content type response that cannot be converted to `models::RedirectStage`"
            )))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesRedirectPartialUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// RedirectStage Viewset
pub async fn stages_redirect_retrieve(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
) -> Result<models::RedirectStage, Error<StagesRedirectRetrieveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;

    let uri_str = format!(
        "{}/stages/redirect/{stage_uuid}/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::RedirectStage`",
                )))
            }
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!(
                "Received `{unknown_type}` content type response that cannot be converted to `models::RedirectStage`"
            )))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesRedirectRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// RedirectStage Viewset
pub async fn stages_redirect_update(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
    redirect_stage_request: models::RedirectStageRequest,
) -> Result<models::RedirectStage, Error<StagesRedirectUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;
    let p_body_redirect_stage_request = redirect_stage_request;

    let uri_str = format!(
        "{}/stages/redirect/{stage_uuid}/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_redirect_stage_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::RedirectStage`",
                )))
            }
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!(
                "Received `{unknown_type}` content type response that cannot be converted to `models::RedirectStage`"
            )))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesRedirectUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get a list of all objects that use this object
pub async fn stages_redirect_used_by_list(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
) -> Result<Vec<models::UsedBy>, Error<StagesRedirectUsedByListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;

    let uri_str = format!(
        "{}/stages/redirect/{stage_uuid}/used_by/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesRedirectUsedByListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// SourceStage Viewset
pub async fn stages_source_create(
    configuration: &configuration::Configuration,
    source_stage_request: models::SourceStageRequest,
) -> Result<models::SourceStage, Error<StagesSourceCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_source_stage_request = source_stage_request;

    let uri_str = format!("{}/stages/source/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_source_stage_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::SourceStage`",
                )))
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::SourceStage`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesSourceCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// SourceStage Viewset
pub async fn stages_source_destroy(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
) -> Result<(), Error<StagesSourceDestroyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;

    let uri_str = format!(
        "{}/stages/source/{stage_uuid}/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesSourceDestroyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// SourceStage Viewset
pub async fn stages_source_list(
    configuration: &configuration::Configuration,
    name: Option<&str>,
    ordering: Option<&str>,
    page: Option<i32>,
    page_size: Option<i32>,
    resume_timeout: Option<&str>,
    search: Option<&str>,
    source: Option<&str>,
    stage_uuid: Option<&str>,
) -> Result<models::PaginatedSourceStageList, Error<StagesSourceListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_name = name;
    let p_query_ordering = ordering;
    let p_query_page = page;
    let p_query_page_size = page_size;
    let p_query_resume_timeout = resume_timeout;
    let p_query_search = search;
    let p_query_source = source;
    let p_query_stage_uuid = stage_uuid;

    let uri_str = format!("{}/stages/source/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ordering {
        req_builder = req_builder.query(&[("ordering", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page_size {
        req_builder = req_builder.query(&[("page_size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_resume_timeout {
        req_builder = req_builder.query(&[("resume_timeout", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_search {
        req_builder = req_builder.query(&[("search", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_source {
        req_builder = req_builder.query(&[("source", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_stage_uuid {
        req_builder = req_builder.query(&[("stage_uuid", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginatedSourceStageList`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginatedSourceStageList`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesSourceListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// SourceStage Viewset
pub async fn stages_source_partial_update(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
    patched_source_stage_request: Option<models::PatchedSourceStageRequest>,
) -> Result<models::SourceStage, Error<StagesSourcePartialUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;
    let p_body_patched_source_stage_request = patched_source_stage_request;

    let uri_str = format!(
        "{}/stages/source/{stage_uuid}/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_patched_source_stage_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::SourceStage`",
                )))
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::SourceStage`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesSourcePartialUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// SourceStage Viewset
pub async fn stages_source_retrieve(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
) -> Result<models::SourceStage, Error<StagesSourceRetrieveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;

    let uri_str = format!(
        "{}/stages/source/{stage_uuid}/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::SourceStage`",
                )))
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::SourceStage`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesSourceRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// SourceStage Viewset
pub async fn stages_source_update(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
    source_stage_request: models::SourceStageRequest,
) -> Result<models::SourceStage, Error<StagesSourceUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;
    let p_body_source_stage_request = source_stage_request;

    let uri_str = format!(
        "{}/stages/source/{stage_uuid}/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_source_stage_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::SourceStage`",
                )))
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::SourceStage`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesSourceUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get a list of all objects that use this object
pub async fn stages_source_used_by_list(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
) -> Result<Vec<models::UsedBy>, Error<StagesSourceUsedByListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;

    let uri_str = format!(
        "{}/stages/source/{stage_uuid}/used_by/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesSourceUsedByListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// UserDeleteStage Viewset
pub async fn stages_user_delete_create(
    configuration: &configuration::Configuration,
    user_delete_stage_request: models::UserDeleteStageRequest,
) -> Result<models::UserDeleteStage, Error<StagesUserDeleteCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_user_delete_stage_request = user_delete_stage_request;

    let uri_str = format!("{}/stages/user_delete/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_user_delete_stage_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::UserDeleteStage`",
                )))
            }
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!(
                "Received `{unknown_type}` content type response that cannot be converted to `models::UserDeleteStage`"
            )))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesUserDeleteCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// UserDeleteStage Viewset
pub async fn stages_user_delete_destroy(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
) -> Result<(), Error<StagesUserDeleteDestroyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;

    let uri_str = format!(
        "{}/stages/user_delete/{stage_uuid}/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesUserDeleteDestroyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// UserDeleteStage Viewset
pub async fn stages_user_delete_list(
    configuration: &configuration::Configuration,
    name: Option<&str>,
    ordering: Option<&str>,
    page: Option<i32>,
    page_size: Option<i32>,
    search: Option<&str>,
    stage_uuid: Option<&str>,
) -> Result<models::PaginatedUserDeleteStageList, Error<StagesUserDeleteListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_name = name;
    let p_query_ordering = ordering;
    let p_query_page = page;
    let p_query_page_size = page_size;
    let p_query_search = search;
    let p_query_stage_uuid = stage_uuid;

    let uri_str = format!("{}/stages/user_delete/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ordering {
        req_builder = req_builder.query(&[("ordering", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page_size {
        req_builder = req_builder.query(&[("page_size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_search {
        req_builder = req_builder.query(&[("search", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_stage_uuid {
        req_builder = req_builder.query(&[("stage_uuid", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginatedUserDeleteStageList`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginatedUserDeleteStageList`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesUserDeleteListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// UserDeleteStage Viewset
pub async fn stages_user_delete_partial_update(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
    patched_user_delete_stage_request: Option<models::PatchedUserDeleteStageRequest>,
) -> Result<models::UserDeleteStage, Error<StagesUserDeletePartialUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;
    let p_body_patched_user_delete_stage_request = patched_user_delete_stage_request;

    let uri_str = format!(
        "{}/stages/user_delete/{stage_uuid}/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_patched_user_delete_stage_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::UserDeleteStage`",
                )))
            }
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!(
                "Received `{unknown_type}` content type response that cannot be converted to `models::UserDeleteStage`"
            )))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesUserDeletePartialUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// UserDeleteStage Viewset
pub async fn stages_user_delete_retrieve(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
) -> Result<models::UserDeleteStage, Error<StagesUserDeleteRetrieveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;

    let uri_str = format!(
        "{}/stages/user_delete/{stage_uuid}/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::UserDeleteStage`",
                )))
            }
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!(
                "Received `{unknown_type}` content type response that cannot be converted to `models::UserDeleteStage`"
            )))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesUserDeleteRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// UserDeleteStage Viewset
pub async fn stages_user_delete_update(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
    user_delete_stage_request: models::UserDeleteStageRequest,
) -> Result<models::UserDeleteStage, Error<StagesUserDeleteUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;
    let p_body_user_delete_stage_request = user_delete_stage_request;

    let uri_str = format!(
        "{}/stages/user_delete/{stage_uuid}/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_user_delete_stage_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::UserDeleteStage`",
                )))
            }
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!(
                "Received `{unknown_type}` content type response that cannot be converted to `models::UserDeleteStage`"
            )))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesUserDeleteUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get a list of all objects that use this object
pub async fn stages_user_delete_used_by_list(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
) -> Result<Vec<models::UsedBy>, Error<StagesUserDeleteUsedByListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;

    let uri_str = format!(
        "{}/stages/user_delete/{stage_uuid}/used_by/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesUserDeleteUsedByListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// UserLoginStage Viewset
pub async fn stages_user_login_create(
    configuration: &configuration::Configuration,
    user_login_stage_request: models::UserLoginStageRequest,
) -> Result<models::UserLoginStage, Error<StagesUserLoginCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_user_login_stage_request = user_login_stage_request;

    let uri_str = format!("{}/stages/user_login/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_user_login_stage_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::UserLoginStage`",
                )))
            }
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!(
                "Received `{unknown_type}` content type response that cannot be converted to `models::UserLoginStage`"
            )))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesUserLoginCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// UserLoginStage Viewset
pub async fn stages_user_login_destroy(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
) -> Result<(), Error<StagesUserLoginDestroyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;

    let uri_str = format!(
        "{}/stages/user_login/{stage_uuid}/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesUserLoginDestroyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// UserLoginStage Viewset
pub async fn stages_user_login_list(
    configuration: &configuration::Configuration,
    geoip_binding: Option<&str>,
    name: Option<&str>,
    network_binding: Option<&str>,
    ordering: Option<&str>,
    page: Option<i32>,
    page_size: Option<i32>,
    remember_me_offset: Option<&str>,
    search: Option<&str>,
    session_duration: Option<&str>,
    stage_uuid: Option<&str>,
    terminate_other_sessions: Option<bool>,
) -> Result<models::PaginatedUserLoginStageList, Error<StagesUserLoginListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_geoip_binding = geoip_binding;
    let p_query_name = name;
    let p_query_network_binding = network_binding;
    let p_query_ordering = ordering;
    let p_query_page = page;
    let p_query_page_size = page_size;
    let p_query_remember_me_offset = remember_me_offset;
    let p_query_search = search;
    let p_query_session_duration = session_duration;
    let p_query_stage_uuid = stage_uuid;
    let p_query_terminate_other_sessions = terminate_other_sessions;

    let uri_str = format!("{}/stages/user_login/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_geoip_binding {
        req_builder = req_builder.query(&[("geoip_binding", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_network_binding {
        req_builder = req_builder.query(&[("network_binding", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ordering {
        req_builder = req_builder.query(&[("ordering", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page_size {
        req_builder = req_builder.query(&[("page_size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_remember_me_offset {
        req_builder = req_builder.query(&[("remember_me_offset", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_search {
        req_builder = req_builder.query(&[("search", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_session_duration {
        req_builder = req_builder.query(&[("session_duration", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_stage_uuid {
        req_builder = req_builder.query(&[("stage_uuid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_terminate_other_sessions {
        req_builder = req_builder.query(&[("terminate_other_sessions", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginatedUserLoginStageList`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginatedUserLoginStageList`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesUserLoginListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// UserLoginStage Viewset
pub async fn stages_user_login_partial_update(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
    patched_user_login_stage_request: Option<models::PatchedUserLoginStageRequest>,
) -> Result<models::UserLoginStage, Error<StagesUserLoginPartialUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;
    let p_body_patched_user_login_stage_request = patched_user_login_stage_request;

    let uri_str = format!(
        "{}/stages/user_login/{stage_uuid}/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_patched_user_login_stage_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::UserLoginStage`",
                )))
            }
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!(
                "Received `{unknown_type}` content type response that cannot be converted to `models::UserLoginStage`"
            )))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesUserLoginPartialUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// UserLoginStage Viewset
pub async fn stages_user_login_retrieve(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
) -> Result<models::UserLoginStage, Error<StagesUserLoginRetrieveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;

    let uri_str = format!(
        "{}/stages/user_login/{stage_uuid}/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::UserLoginStage`",
                )))
            }
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!(
                "Received `{unknown_type}` content type response that cannot be converted to `models::UserLoginStage`"
            )))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesUserLoginRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// UserLoginStage Viewset
pub async fn stages_user_login_update(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
    user_login_stage_request: models::UserLoginStageRequest,
) -> Result<models::UserLoginStage, Error<StagesUserLoginUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;
    let p_body_user_login_stage_request = user_login_stage_request;

    let uri_str = format!(
        "{}/stages/user_login/{stage_uuid}/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_user_login_stage_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::UserLoginStage`",
                )))
            }
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!(
                "Received `{unknown_type}` content type response that cannot be converted to `models::UserLoginStage`"
            )))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesUserLoginUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get a list of all objects that use this object
pub async fn stages_user_login_used_by_list(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
) -> Result<Vec<models::UsedBy>, Error<StagesUserLoginUsedByListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;

    let uri_str = format!(
        "{}/stages/user_login/{stage_uuid}/used_by/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesUserLoginUsedByListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// UserLogoutStage Viewset
pub async fn stages_user_logout_create(
    configuration: &configuration::Configuration,
    user_logout_stage_request: models::UserLogoutStageRequest,
) -> Result<models::UserLogoutStage, Error<StagesUserLogoutCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_user_logout_stage_request = user_logout_stage_request;

    let uri_str = format!("{}/stages/user_logout/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_user_logout_stage_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::UserLogoutStage`",
                )))
            }
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!(
                "Received `{unknown_type}` content type response that cannot be converted to `models::UserLogoutStage`"
            )))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesUserLogoutCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// UserLogoutStage Viewset
pub async fn stages_user_logout_destroy(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
) -> Result<(), Error<StagesUserLogoutDestroyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;

    let uri_str = format!(
        "{}/stages/user_logout/{stage_uuid}/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesUserLogoutDestroyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// UserLogoutStage Viewset
pub async fn stages_user_logout_list(
    configuration: &configuration::Configuration,
    name: Option<&str>,
    ordering: Option<&str>,
    page: Option<i32>,
    page_size: Option<i32>,
    search: Option<&str>,
    stage_uuid: Option<&str>,
) -> Result<models::PaginatedUserLogoutStageList, Error<StagesUserLogoutListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_name = name;
    let p_query_ordering = ordering;
    let p_query_page = page;
    let p_query_page_size = page_size;
    let p_query_search = search;
    let p_query_stage_uuid = stage_uuid;

    let uri_str = format!("{}/stages/user_logout/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ordering {
        req_builder = req_builder.query(&[("ordering", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page_size {
        req_builder = req_builder.query(&[("page_size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_search {
        req_builder = req_builder.query(&[("search", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_stage_uuid {
        req_builder = req_builder.query(&[("stage_uuid", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginatedUserLogoutStageList`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginatedUserLogoutStageList`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesUserLogoutListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// UserLogoutStage Viewset
pub async fn stages_user_logout_partial_update(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
    patched_user_logout_stage_request: Option<models::PatchedUserLogoutStageRequest>,
) -> Result<models::UserLogoutStage, Error<StagesUserLogoutPartialUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;
    let p_body_patched_user_logout_stage_request = patched_user_logout_stage_request;

    let uri_str = format!(
        "{}/stages/user_logout/{stage_uuid}/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_patched_user_logout_stage_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::UserLogoutStage`",
                )))
            }
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!(
                "Received `{unknown_type}` content type response that cannot be converted to `models::UserLogoutStage`"
            )))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesUserLogoutPartialUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// UserLogoutStage Viewset
pub async fn stages_user_logout_retrieve(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
) -> Result<models::UserLogoutStage, Error<StagesUserLogoutRetrieveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;

    let uri_str = format!(
        "{}/stages/user_logout/{stage_uuid}/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::UserLogoutStage`",
                )))
            }
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!(
                "Received `{unknown_type}` content type response that cannot be converted to `models::UserLogoutStage`"
            )))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesUserLogoutRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// UserLogoutStage Viewset
pub async fn stages_user_logout_update(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
    user_logout_stage_request: models::UserLogoutStageRequest,
) -> Result<models::UserLogoutStage, Error<StagesUserLogoutUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;
    let p_body_user_logout_stage_request = user_logout_stage_request;

    let uri_str = format!(
        "{}/stages/user_logout/{stage_uuid}/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_user_logout_stage_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::UserLogoutStage`",
                )))
            }
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!(
                "Received `{unknown_type}` content type response that cannot be converted to `models::UserLogoutStage`"
            )))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesUserLogoutUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get a list of all objects that use this object
pub async fn stages_user_logout_used_by_list(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
) -> Result<Vec<models::UsedBy>, Error<StagesUserLogoutUsedByListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;

    let uri_str = format!(
        "{}/stages/user_logout/{stage_uuid}/used_by/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesUserLogoutUsedByListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// UserWriteStage Viewset
pub async fn stages_user_write_create(
    configuration: &configuration::Configuration,
    user_write_stage_request: models::UserWriteStageRequest,
) -> Result<models::UserWriteStage, Error<StagesUserWriteCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_user_write_stage_request = user_write_stage_request;

    let uri_str = format!("{}/stages/user_write/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_user_write_stage_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::UserWriteStage`",
                )))
            }
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!(
                "Received `{unknown_type}` content type response that cannot be converted to `models::UserWriteStage`"
            )))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesUserWriteCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// UserWriteStage Viewset
pub async fn stages_user_write_destroy(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
) -> Result<(), Error<StagesUserWriteDestroyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;

    let uri_str = format!(
        "{}/stages/user_write/{stage_uuid}/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesUserWriteDestroyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// UserWriteStage Viewset
pub async fn stages_user_write_list(
    configuration: &configuration::Configuration,
    create_users_as_inactive: Option<bool>,
    create_users_group: Option<&str>,
    name: Option<&str>,
    ordering: Option<&str>,
    page: Option<i32>,
    page_size: Option<i32>,
    search: Option<&str>,
    stage_uuid: Option<&str>,
    user_creation_mode: Option<&str>,
    user_path_template: Option<&str>,
    user_type: Option<&str>,
) -> Result<models::PaginatedUserWriteStageList, Error<StagesUserWriteListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_create_users_as_inactive = create_users_as_inactive;
    let p_query_create_users_group = create_users_group;
    let p_query_name = name;
    let p_query_ordering = ordering;
    let p_query_page = page;
    let p_query_page_size = page_size;
    let p_query_search = search;
    let p_query_stage_uuid = stage_uuid;
    let p_query_user_creation_mode = user_creation_mode;
    let p_query_user_path_template = user_path_template;
    let p_query_user_type = user_type;

    let uri_str = format!("{}/stages/user_write/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_create_users_as_inactive {
        req_builder = req_builder.query(&[("create_users_as_inactive", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_create_users_group {
        req_builder = req_builder.query(&[("create_users_group", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ordering {
        req_builder = req_builder.query(&[("ordering", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page_size {
        req_builder = req_builder.query(&[("page_size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_search {
        req_builder = req_builder.query(&[("search", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_stage_uuid {
        req_builder = req_builder.query(&[("stage_uuid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_user_creation_mode {
        req_builder = req_builder.query(&[("user_creation_mode", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_user_path_template {
        req_builder = req_builder.query(&[("user_path_template", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_user_type {
        req_builder = req_builder.query(&[("user_type", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginatedUserWriteStageList`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginatedUserWriteStageList`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesUserWriteListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// UserWriteStage Viewset
pub async fn stages_user_write_partial_update(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
    patched_user_write_stage_request: Option<models::PatchedUserWriteStageRequest>,
) -> Result<models::UserWriteStage, Error<StagesUserWritePartialUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;
    let p_body_patched_user_write_stage_request = patched_user_write_stage_request;

    let uri_str = format!(
        "{}/stages/user_write/{stage_uuid}/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_patched_user_write_stage_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::UserWriteStage`",
                )))
            }
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!(
                "Received `{unknown_type}` content type response that cannot be converted to `models::UserWriteStage`"
            )))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesUserWritePartialUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// UserWriteStage Viewset
pub async fn stages_user_write_retrieve(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
) -> Result<models::UserWriteStage, Error<StagesUserWriteRetrieveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;

    let uri_str = format!(
        "{}/stages/user_write/{stage_uuid}/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::UserWriteStage`",
                )))
            }
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!(
                "Received `{unknown_type}` content type response that cannot be converted to `models::UserWriteStage`"
            )))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesUserWriteRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// UserWriteStage Viewset
pub async fn stages_user_write_update(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
    user_write_stage_request: models::UserWriteStageRequest,
) -> Result<models::UserWriteStage, Error<StagesUserWriteUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;
    let p_body_user_write_stage_request = user_write_stage_request;

    let uri_str = format!(
        "{}/stages/user_write/{stage_uuid}/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_user_write_stage_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::UserWriteStage`",
                )))
            }
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!(
                "Received `{unknown_type}` content type response that cannot be converted to `models::UserWriteStage`"
            )))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesUserWriteUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get a list of all objects that use this object
pub async fn stages_user_write_used_by_list(
    configuration: &configuration::Configuration,
    stage_uuid: &str,
) -> Result<Vec<models::UsedBy>, Error<StagesUserWriteUsedByListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_stage_uuid = stage_uuid;

    let uri_str = format!(
        "{}/stages/user_write/{stage_uuid}/used_by/",
        configuration.base_path,
        stage_uuid = crate::apis::urlencode(p_path_stage_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<StagesUserWriteUsedByListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
