/*
 * authentik
 *
 * Making authentication simple.
 *
 * The version of the OpenAPI document: 2025.2.2
 * Contact: hello@goauthentik.io
 * Generated by: https://openapi-generator.tech
 */

use super::{configuration, ContentType, Error};
use crate::{apis::ResponseContent, models};
use reqwest;
use serde::{de::Error as _, Deserialize, Serialize};
use tokio::fs::File as TokioFile;
use tokio_util::codec::{BytesCodec, FramedRead};

/// struct for typed errors of method [`core_application_entitlements_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CoreApplicationEntitlementsCreateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`core_application_entitlements_destroy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CoreApplicationEntitlementsDestroyError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`core_application_entitlements_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CoreApplicationEntitlementsListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`core_application_entitlements_partial_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CoreApplicationEntitlementsPartialUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`core_application_entitlements_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CoreApplicationEntitlementsRetrieveError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`core_application_entitlements_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CoreApplicationEntitlementsUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`core_application_entitlements_used_by_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CoreApplicationEntitlementsUsedByListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`core_applications_check_access_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CoreApplicationsCheckAccessRetrieveError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`core_applications_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CoreApplicationsCreateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`core_applications_destroy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CoreApplicationsDestroyError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`core_applications_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CoreApplicationsListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`core_applications_metrics_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CoreApplicationsMetricsListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`core_applications_partial_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CoreApplicationsPartialUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`core_applications_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CoreApplicationsRetrieveError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`core_applications_set_icon_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CoreApplicationsSetIconCreateError {
    Status400(),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`core_applications_set_icon_url_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CoreApplicationsSetIconUrlCreateError {
    Status400(),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`core_applications_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CoreApplicationsUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`core_applications_used_by_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CoreApplicationsUsedByListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`core_authenticated_sessions_destroy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CoreAuthenticatedSessionsDestroyError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`core_authenticated_sessions_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CoreAuthenticatedSessionsListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`core_authenticated_sessions_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CoreAuthenticatedSessionsRetrieveError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`core_authenticated_sessions_used_by_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CoreAuthenticatedSessionsUsedByListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`core_brands_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CoreBrandsCreateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`core_brands_current_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CoreBrandsCurrentRetrieveError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`core_brands_destroy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CoreBrandsDestroyError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`core_brands_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CoreBrandsListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`core_brands_partial_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CoreBrandsPartialUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`core_brands_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CoreBrandsRetrieveError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`core_brands_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CoreBrandsUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`core_brands_used_by_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CoreBrandsUsedByListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`core_groups_add_user_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CoreGroupsAddUserCreateError {
    Status404(),
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`core_groups_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CoreGroupsCreateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`core_groups_destroy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CoreGroupsDestroyError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`core_groups_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CoreGroupsListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`core_groups_partial_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CoreGroupsPartialUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`core_groups_remove_user_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CoreGroupsRemoveUserCreateError {
    Status404(),
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`core_groups_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CoreGroupsRetrieveError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`core_groups_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CoreGroupsUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`core_groups_used_by_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CoreGroupsUsedByListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`core_tokens_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CoreTokensCreateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`core_tokens_destroy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CoreTokensDestroyError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`core_tokens_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CoreTokensListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`core_tokens_partial_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CoreTokensPartialUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`core_tokens_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CoreTokensRetrieveError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`core_tokens_set_key_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CoreTokensSetKeyCreateError {
    Status400(),
    Status404(),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`core_tokens_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CoreTokensUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`core_tokens_used_by_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CoreTokensUsedByListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`core_tokens_view_key_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CoreTokensViewKeyRetrieveError {
    Status404(),
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`core_transactional_applications_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CoreTransactionalApplicationsUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`core_user_consent_destroy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CoreUserConsentDestroyError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`core_user_consent_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CoreUserConsentListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`core_user_consent_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CoreUserConsentRetrieveError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`core_user_consent_used_by_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CoreUserConsentUsedByListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`core_users_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CoreUsersCreateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`core_users_destroy`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CoreUsersDestroyError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`core_users_impersonate_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CoreUsersImpersonateCreateError {
    Status401(),
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`core_users_impersonate_end_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CoreUsersImpersonateEndRetrieveError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`core_users_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CoreUsersListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`core_users_me_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CoreUsersMeRetrieveError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`core_users_metrics_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CoreUsersMetricsRetrieveError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`core_users_partial_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CoreUsersPartialUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`core_users_paths_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CoreUsersPathsRetrieveError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`core_users_recovery_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CoreUsersRecoveryCreateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`core_users_recovery_email_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CoreUsersRecoveryEmailCreateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`core_users_retrieve`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CoreUsersRetrieveError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`core_users_service_account_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CoreUsersServiceAccountCreateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`core_users_set_password_create`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CoreUsersSetPasswordCreateError {
    Status400(),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`core_users_update`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CoreUsersUpdateError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`core_users_used_by_list`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CoreUsersUsedByListError {
    Status400(models::ValidationError),
    Status403(models::GenericError),
    UnknownValue(serde_json::Value),
}

/// ApplicationEntitlement Viewset
pub async fn core_application_entitlements_create(
    configuration: &configuration::Configuration,
    application_entitlement_request: models::ApplicationEntitlementRequest,
) -> Result<models::ApplicationEntitlement, Error<CoreApplicationEntitlementsCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_application_entitlement_request = application_entitlement_request;

    let uri_str = format!("{}/core/application_entitlements/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_application_entitlement_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ApplicationEntitlement`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ApplicationEntitlement`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CoreApplicationEntitlementsCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// ApplicationEntitlement Viewset
pub async fn core_application_entitlements_destroy(
    configuration: &configuration::Configuration,
    pbm_uuid: &str,
) -> Result<(), Error<CoreApplicationEntitlementsDestroyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_pbm_uuid = pbm_uuid;

    let uri_str = format!(
        "{}/core/application_entitlements/{pbm_uuid}/",
        configuration.base_path,
        pbm_uuid = crate::apis::urlencode(p_path_pbm_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<CoreApplicationEntitlementsDestroyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// ApplicationEntitlement Viewset
pub async fn core_application_entitlements_list(
    configuration: &configuration::Configuration,
    app: Option<&str>,
    name: Option<&str>,
    ordering: Option<&str>,
    page: Option<i32>,
    page_size: Option<i32>,
    pbm_uuid: Option<&str>,
    search: Option<&str>,
) -> Result<models::PaginatedApplicationEntitlementList, Error<CoreApplicationEntitlementsListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_app = app;
    let p_query_name = name;
    let p_query_ordering = ordering;
    let p_query_page = page;
    let p_query_page_size = page_size;
    let p_query_pbm_uuid = pbm_uuid;
    let p_query_search = search;

    let uri_str = format!("{}/core/application_entitlements/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_app {
        req_builder = req_builder.query(&[("app", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ordering {
        req_builder = req_builder.query(&[("ordering", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page_size {
        req_builder = req_builder.query(&[("page_size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_pbm_uuid {
        req_builder = req_builder.query(&[("pbm_uuid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_search {
        req_builder = req_builder.query(&[("search", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginatedApplicationEntitlementList`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginatedApplicationEntitlementList`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CoreApplicationEntitlementsListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// ApplicationEntitlement Viewset
pub async fn core_application_entitlements_partial_update(
    configuration: &configuration::Configuration,
    pbm_uuid: &str,
    patched_application_entitlement_request: Option<models::PatchedApplicationEntitlementRequest>,
) -> Result<models::ApplicationEntitlement, Error<CoreApplicationEntitlementsPartialUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_pbm_uuid = pbm_uuid;
    let p_body_patched_application_entitlement_request = patched_application_entitlement_request;

    let uri_str = format!(
        "{}/core/application_entitlements/{pbm_uuid}/",
        configuration.base_path,
        pbm_uuid = crate::apis::urlencode(p_path_pbm_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_patched_application_entitlement_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ApplicationEntitlement`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ApplicationEntitlement`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CoreApplicationEntitlementsPartialUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// ApplicationEntitlement Viewset
pub async fn core_application_entitlements_retrieve(
    configuration: &configuration::Configuration,
    pbm_uuid: &str,
) -> Result<models::ApplicationEntitlement, Error<CoreApplicationEntitlementsRetrieveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_pbm_uuid = pbm_uuid;

    let uri_str = format!(
        "{}/core/application_entitlements/{pbm_uuid}/",
        configuration.base_path,
        pbm_uuid = crate::apis::urlencode(p_path_pbm_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ApplicationEntitlement`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ApplicationEntitlement`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CoreApplicationEntitlementsRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// ApplicationEntitlement Viewset
pub async fn core_application_entitlements_update(
    configuration: &configuration::Configuration,
    pbm_uuid: &str,
    application_entitlement_request: models::ApplicationEntitlementRequest,
) -> Result<models::ApplicationEntitlement, Error<CoreApplicationEntitlementsUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_pbm_uuid = pbm_uuid;
    let p_body_application_entitlement_request = application_entitlement_request;

    let uri_str = format!(
        "{}/core/application_entitlements/{pbm_uuid}/",
        configuration.base_path,
        pbm_uuid = crate::apis::urlencode(p_path_pbm_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_application_entitlement_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ApplicationEntitlement`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ApplicationEntitlement`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CoreApplicationEntitlementsUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get a list of all objects that use this object
pub async fn core_application_entitlements_used_by_list(
    configuration: &configuration::Configuration,
    pbm_uuid: &str,
) -> Result<Vec<models::UsedBy>, Error<CoreApplicationEntitlementsUsedByListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_pbm_uuid = pbm_uuid;

    let uri_str = format!(
        "{}/core/application_entitlements/{pbm_uuid}/used_by/",
        configuration.base_path,
        pbm_uuid = crate::apis::urlencode(p_path_pbm_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CoreApplicationEntitlementsUsedByListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Check access to a single application by slug
pub async fn core_applications_check_access_retrieve(
    configuration: &configuration::Configuration,
    slug: &str,
    for_user: Option<i32>,
) -> Result<models::PolicyTestResult, Error<CoreApplicationsCheckAccessRetrieveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_slug = slug;
    let p_query_for_user = for_user;

    let uri_str = format!(
        "{}/core/applications/{slug}/check_access/",
        configuration.base_path,
        slug = crate::apis::urlencode(p_path_slug)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_for_user {
        req_builder = req_builder.query(&[("for_user", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PolicyTestResult`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PolicyTestResult`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CoreApplicationsCheckAccessRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Application Viewset
pub async fn core_applications_create(
    configuration: &configuration::Configuration,
    application_request: models::ApplicationRequest,
) -> Result<models::Application, Error<CoreApplicationsCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_application_request = application_request;

    let uri_str = format!("{}/core/applications/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_application_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::Application`",
                )))
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::Application`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CoreApplicationsCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Application Viewset
pub async fn core_applications_destroy(
    configuration: &configuration::Configuration,
    slug: &str,
) -> Result<(), Error<CoreApplicationsDestroyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_slug = slug;

    let uri_str = format!(
        "{}/core/applications/{slug}/",
        configuration.base_path,
        slug = crate::apis::urlencode(p_path_slug)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<CoreApplicationsDestroyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Custom list method that checks Policy based access instead of guardian
pub async fn core_applications_list(
    configuration: &configuration::Configuration,
    for_user: Option<i32>,
    group: Option<&str>,
    meta_description: Option<&str>,
    meta_launch_url: Option<&str>,
    meta_publisher: Option<&str>,
    name: Option<&str>,
    only_with_launch_url: Option<bool>,
    ordering: Option<&str>,
    page: Option<i32>,
    page_size: Option<i32>,
    search: Option<&str>,
    slug: Option<&str>,
    superuser_full_list: Option<bool>,
) -> Result<models::PaginatedApplicationList, Error<CoreApplicationsListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_for_user = for_user;
    let p_query_group = group;
    let p_query_meta_description = meta_description;
    let p_query_meta_launch_url = meta_launch_url;
    let p_query_meta_publisher = meta_publisher;
    let p_query_name = name;
    let p_query_only_with_launch_url = only_with_launch_url;
    let p_query_ordering = ordering;
    let p_query_page = page;
    let p_query_page_size = page_size;
    let p_query_search = search;
    let p_query_slug = slug;
    let p_query_superuser_full_list = superuser_full_list;

    let uri_str = format!("{}/core/applications/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_for_user {
        req_builder = req_builder.query(&[("for_user", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_group {
        req_builder = req_builder.query(&[("group", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_meta_description {
        req_builder = req_builder.query(&[("meta_description", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_meta_launch_url {
        req_builder = req_builder.query(&[("meta_launch_url", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_meta_publisher {
        req_builder = req_builder.query(&[("meta_publisher", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_only_with_launch_url {
        req_builder = req_builder.query(&[("only_with_launch_url", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ordering {
        req_builder = req_builder.query(&[("ordering", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page_size {
        req_builder = req_builder.query(&[("page_size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_search {
        req_builder = req_builder.query(&[("search", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_slug {
        req_builder = req_builder.query(&[("slug", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_superuser_full_list {
        req_builder = req_builder.query(&[("superuser_full_list", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginatedApplicationList`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginatedApplicationList`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CoreApplicationsListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Metrics for application logins
pub async fn core_applications_metrics_list(
    configuration: &configuration::Configuration,
    slug: &str,
) -> Result<Vec<models::Coordinate>, Error<CoreApplicationsMetricsListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_slug = slug;

    let uri_str = format!(
        "{}/core/applications/{slug}/metrics/",
        configuration.base_path,
        slug = crate::apis::urlencode(p_path_slug)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::Coordinate&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::Coordinate&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CoreApplicationsMetricsListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Application Viewset
pub async fn core_applications_partial_update(
    configuration: &configuration::Configuration,
    slug: &str,
    patched_application_request: Option<models::PatchedApplicationRequest>,
) -> Result<models::Application, Error<CoreApplicationsPartialUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_slug = slug;
    let p_body_patched_application_request = patched_application_request;

    let uri_str = format!(
        "{}/core/applications/{slug}/",
        configuration.base_path,
        slug = crate::apis::urlencode(p_path_slug)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_patched_application_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::Application`",
                )))
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::Application`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CoreApplicationsPartialUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Application Viewset
pub async fn core_applications_retrieve(
    configuration: &configuration::Configuration,
    slug: &str,
) -> Result<models::Application, Error<CoreApplicationsRetrieveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_slug = slug;

    let uri_str = format!(
        "{}/core/applications/{slug}/",
        configuration.base_path,
        slug = crate::apis::urlencode(p_path_slug)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::Application`",
                )))
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::Application`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CoreApplicationsRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Set application icon
pub async fn core_applications_set_icon_create(
    configuration: &configuration::Configuration,
    slug: &str,
    file: Option<std::path::PathBuf>,
    clear: Option<bool>,
) -> Result<(), Error<CoreApplicationsSetIconCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_slug = slug;
    let p_form_file = file;
    let p_form_clear = clear;

    let uri_str = format!(
        "{}/core/applications/{slug}/set_icon/",
        configuration.base_path,
        slug = crate::apis::urlencode(p_path_slug)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    let mut multipart_form = reqwest::multipart::Form::new();
    // TODO: support file upload for 'file' parameter
    if let Some(param_value) = p_form_clear {
        multipart_form = multipart_form.text("clear", param_value.to_string());
    }
    req_builder = req_builder.multipart(multipart_form);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<CoreApplicationsSetIconCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Set application icon (as URL)
pub async fn core_applications_set_icon_url_create(
    configuration: &configuration::Configuration,
    slug: &str,
    file_path_request: models::FilePathRequest,
) -> Result<(), Error<CoreApplicationsSetIconUrlCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_slug = slug;
    let p_body_file_path_request = file_path_request;

    let uri_str = format!(
        "{}/core/applications/{slug}/set_icon_url/",
        configuration.base_path,
        slug = crate::apis::urlencode(p_path_slug)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_file_path_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<CoreApplicationsSetIconUrlCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Application Viewset
pub async fn core_applications_update(
    configuration: &configuration::Configuration,
    slug: &str,
    application_request: models::ApplicationRequest,
) -> Result<models::Application, Error<CoreApplicationsUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_slug = slug;
    let p_body_application_request = application_request;

    let uri_str = format!(
        "{}/core/applications/{slug}/",
        configuration.base_path,
        slug = crate::apis::urlencode(p_path_slug)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_application_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::Application`",
                )))
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::Application`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CoreApplicationsUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get a list of all objects that use this object
pub async fn core_applications_used_by_list(
    configuration: &configuration::Configuration,
    slug: &str,
) -> Result<Vec<models::UsedBy>, Error<CoreApplicationsUsedByListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_slug = slug;

    let uri_str = format!(
        "{}/core/applications/{slug}/used_by/",
        configuration.base_path,
        slug = crate::apis::urlencode(p_path_slug)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CoreApplicationsUsedByListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// AuthenticatedSession Viewset
pub async fn core_authenticated_sessions_destroy(
    configuration: &configuration::Configuration,
    uuid: &str,
) -> Result<(), Error<CoreAuthenticatedSessionsDestroyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_uuid = uuid;

    let uri_str = format!(
        "{}/core/authenticated_sessions/{uuid}/",
        configuration.base_path,
        uuid = crate::apis::urlencode(p_path_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<CoreAuthenticatedSessionsDestroyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// AuthenticatedSession Viewset
pub async fn core_authenticated_sessions_list(
    configuration: &configuration::Configuration,
    last_ip: Option<&str>,
    last_user_agent: Option<&str>,
    ordering: Option<&str>,
    page: Option<i32>,
    page_size: Option<i32>,
    search: Option<&str>,
    user__username: Option<&str>,
) -> Result<models::PaginatedAuthenticatedSessionList, Error<CoreAuthenticatedSessionsListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_last_ip = last_ip;
    let p_query_last_user_agent = last_user_agent;
    let p_query_ordering = ordering;
    let p_query_page = page;
    let p_query_page_size = page_size;
    let p_query_search = search;
    let p_query_user__username = user__username;

    let uri_str = format!("{}/core/authenticated_sessions/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_last_ip {
        req_builder = req_builder.query(&[("last_ip", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_last_user_agent {
        req_builder = req_builder.query(&[("last_user_agent", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ordering {
        req_builder = req_builder.query(&[("ordering", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page_size {
        req_builder = req_builder.query(&[("page_size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_search {
        req_builder = req_builder.query(&[("search", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_user__username {
        req_builder = req_builder.query(&[("user__username", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginatedAuthenticatedSessionList`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginatedAuthenticatedSessionList`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CoreAuthenticatedSessionsListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// AuthenticatedSession Viewset
pub async fn core_authenticated_sessions_retrieve(
    configuration: &configuration::Configuration,
    uuid: &str,
) -> Result<models::AuthenticatedSession, Error<CoreAuthenticatedSessionsRetrieveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_uuid = uuid;

    let uri_str = format!(
        "{}/core/authenticated_sessions/{uuid}/",
        configuration.base_path,
        uuid = crate::apis::urlencode(p_path_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AuthenticatedSession`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AuthenticatedSession`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CoreAuthenticatedSessionsRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get a list of all objects that use this object
pub async fn core_authenticated_sessions_used_by_list(
    configuration: &configuration::Configuration,
    uuid: &str,
) -> Result<Vec<models::UsedBy>, Error<CoreAuthenticatedSessionsUsedByListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_uuid = uuid;

    let uri_str = format!(
        "{}/core/authenticated_sessions/{uuid}/used_by/",
        configuration.base_path,
        uuid = crate::apis::urlencode(p_path_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CoreAuthenticatedSessionsUsedByListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Brand Viewset
pub async fn core_brands_create(
    configuration: &configuration::Configuration,
    brand_request: models::BrandRequest,
) -> Result<models::Brand, Error<CoreBrandsCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_brand_request = brand_request;

    let uri_str = format!("{}/core/brands/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_brand_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::Brand`",
                )))
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::Brand`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CoreBrandsCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get current brand
pub async fn core_brands_current_retrieve(
    configuration: &configuration::Configuration,
) -> Result<models::CurrentBrand, Error<CoreBrandsCurrentRetrieveError>> {
    let uri_str = format!("{}/core/brands/current/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::CurrentBrand`",
                )))
            }
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!(
                "Received `{unknown_type}` content type response that cannot be converted to `models::CurrentBrand`"
            )))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CoreBrandsCurrentRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Brand Viewset
pub async fn core_brands_destroy(
    configuration: &configuration::Configuration,
    brand_uuid: &str,
) -> Result<(), Error<CoreBrandsDestroyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_brand_uuid = brand_uuid;

    let uri_str = format!(
        "{}/core/brands/{brand_uuid}/",
        configuration.base_path,
        brand_uuid = crate::apis::urlencode(p_path_brand_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<CoreBrandsDestroyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Brand Viewset
pub async fn core_brands_list(
    configuration: &configuration::Configuration,
    brand_uuid: Option<&str>,
    branding_favicon: Option<&str>,
    branding_logo: Option<&str>,
    branding_title: Option<&str>,
    default: Option<bool>,
    domain: Option<&str>,
    flow_authentication: Option<&str>,
    flow_device_code: Option<&str>,
    flow_invalidation: Option<&str>,
    flow_recovery: Option<&str>,
    flow_unenrollment: Option<&str>,
    flow_user_settings: Option<&str>,
    ordering: Option<&str>,
    page: Option<i32>,
    page_size: Option<i32>,
    search: Option<&str>,
    web_certificate: Option<&str>,
) -> Result<models::PaginatedBrandList, Error<CoreBrandsListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_brand_uuid = brand_uuid;
    let p_query_branding_favicon = branding_favicon;
    let p_query_branding_logo = branding_logo;
    let p_query_branding_title = branding_title;
    let p_query_default = default;
    let p_query_domain = domain;
    let p_query_flow_authentication = flow_authentication;
    let p_query_flow_device_code = flow_device_code;
    let p_query_flow_invalidation = flow_invalidation;
    let p_query_flow_recovery = flow_recovery;
    let p_query_flow_unenrollment = flow_unenrollment;
    let p_query_flow_user_settings = flow_user_settings;
    let p_query_ordering = ordering;
    let p_query_page = page;
    let p_query_page_size = page_size;
    let p_query_search = search;
    let p_query_web_certificate = web_certificate;

    let uri_str = format!("{}/core/brands/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_brand_uuid {
        req_builder = req_builder.query(&[("brand_uuid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_branding_favicon {
        req_builder = req_builder.query(&[("branding_favicon", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_branding_logo {
        req_builder = req_builder.query(&[("branding_logo", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_branding_title {
        req_builder = req_builder.query(&[("branding_title", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_default {
        req_builder = req_builder.query(&[("default", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_domain {
        req_builder = req_builder.query(&[("domain", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_flow_authentication {
        req_builder = req_builder.query(&[("flow_authentication", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_flow_device_code {
        req_builder = req_builder.query(&[("flow_device_code", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_flow_invalidation {
        req_builder = req_builder.query(&[("flow_invalidation", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_flow_recovery {
        req_builder = req_builder.query(&[("flow_recovery", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_flow_unenrollment {
        req_builder = req_builder.query(&[("flow_unenrollment", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_flow_user_settings {
        req_builder = req_builder.query(&[("flow_user_settings", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ordering {
        req_builder = req_builder.query(&[("ordering", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page_size {
        req_builder = req_builder.query(&[("page_size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_search {
        req_builder = req_builder.query(&[("search", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_web_certificate {
        req_builder = req_builder.query(&[("web_certificate", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginatedBrandList`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginatedBrandList`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CoreBrandsListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Brand Viewset
pub async fn core_brands_partial_update(
    configuration: &configuration::Configuration,
    brand_uuid: &str,
    patched_brand_request: Option<models::PatchedBrandRequest>,
) -> Result<models::Brand, Error<CoreBrandsPartialUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_brand_uuid = brand_uuid;
    let p_body_patched_brand_request = patched_brand_request;

    let uri_str = format!(
        "{}/core/brands/{brand_uuid}/",
        configuration.base_path,
        brand_uuid = crate::apis::urlencode(p_path_brand_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_patched_brand_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::Brand`",
                )))
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::Brand`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CoreBrandsPartialUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Brand Viewset
pub async fn core_brands_retrieve(
    configuration: &configuration::Configuration,
    brand_uuid: &str,
) -> Result<models::Brand, Error<CoreBrandsRetrieveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_brand_uuid = brand_uuid;

    let uri_str = format!(
        "{}/core/brands/{brand_uuid}/",
        configuration.base_path,
        brand_uuid = crate::apis::urlencode(p_path_brand_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::Brand`",
                )))
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::Brand`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CoreBrandsRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Brand Viewset
pub async fn core_brands_update(
    configuration: &configuration::Configuration,
    brand_uuid: &str,
    brand_request: models::BrandRequest,
) -> Result<models::Brand, Error<CoreBrandsUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_brand_uuid = brand_uuid;
    let p_body_brand_request = brand_request;

    let uri_str = format!(
        "{}/core/brands/{brand_uuid}/",
        configuration.base_path,
        brand_uuid = crate::apis::urlencode(p_path_brand_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_brand_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::Brand`",
                )))
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::Brand`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CoreBrandsUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get a list of all objects that use this object
pub async fn core_brands_used_by_list(
    configuration: &configuration::Configuration,
    brand_uuid: &str,
) -> Result<Vec<models::UsedBy>, Error<CoreBrandsUsedByListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_brand_uuid = brand_uuid;

    let uri_str = format!(
        "{}/core/brands/{brand_uuid}/used_by/",
        configuration.base_path,
        brand_uuid = crate::apis::urlencode(p_path_brand_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CoreBrandsUsedByListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Add user to group
pub async fn core_groups_add_user_create(
    configuration: &configuration::Configuration,
    group_uuid: &str,
    user_account_request: models::UserAccountRequest,
) -> Result<(), Error<CoreGroupsAddUserCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_group_uuid = group_uuid;
    let p_body_user_account_request = user_account_request;

    let uri_str = format!(
        "{}/core/groups/{group_uuid}/add_user/",
        configuration.base_path,
        group_uuid = crate::apis::urlencode(p_path_group_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_user_account_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<CoreGroupsAddUserCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Group Viewset
pub async fn core_groups_create(
    configuration: &configuration::Configuration,
    group_request: models::GroupRequest,
) -> Result<models::Group, Error<CoreGroupsCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_group_request = group_request;

    let uri_str = format!("{}/core/groups/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_group_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::Group`",
                )))
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::Group`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CoreGroupsCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Group Viewset
pub async fn core_groups_destroy(
    configuration: &configuration::Configuration,
    group_uuid: &str,
) -> Result<(), Error<CoreGroupsDestroyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_group_uuid = group_uuid;

    let uri_str = format!(
        "{}/core/groups/{group_uuid}/",
        configuration.base_path,
        group_uuid = crate::apis::urlencode(p_path_group_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<CoreGroupsDestroyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Group Viewset
pub async fn core_groups_list(
    configuration: &configuration::Configuration,
    attributes: Option<&str>,
    include_users: Option<bool>,
    is_superuser: Option<bool>,
    members_by_pk: Option<Vec<i32>>,
    members_by_username: Option<Vec<String>>,
    name: Option<&str>,
    ordering: Option<&str>,
    page: Option<i32>,
    page_size: Option<i32>,
    search: Option<&str>,
) -> Result<models::PaginatedGroupList, Error<CoreGroupsListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_attributes = attributes;
    let p_query_include_users = include_users;
    let p_query_is_superuser = is_superuser;
    let p_query_members_by_pk = members_by_pk;
    let p_query_members_by_username = members_by_username;
    let p_query_name = name;
    let p_query_ordering = ordering;
    let p_query_page = page;
    let p_query_page_size = page_size;
    let p_query_search = search;

    let uri_str = format!("{}/core/groups/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_attributes {
        req_builder = req_builder.query(&[("attributes", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_include_users {
        req_builder = req_builder.query(&[("include_users", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_is_superuser {
        req_builder = req_builder.query(&[("is_superuser", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_members_by_pk {
        req_builder = match "multi" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("members_by_pk".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "members_by_pk",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = p_query_members_by_username {
        req_builder = match "multi" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("members_by_username".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "members_by_username",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = p_query_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ordering {
        req_builder = req_builder.query(&[("ordering", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page_size {
        req_builder = req_builder.query(&[("page_size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_search {
        req_builder = req_builder.query(&[("search", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginatedGroupList`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginatedGroupList`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CoreGroupsListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Group Viewset
pub async fn core_groups_partial_update(
    configuration: &configuration::Configuration,
    group_uuid: &str,
    patched_group_request: Option<models::PatchedGroupRequest>,
) -> Result<models::Group, Error<CoreGroupsPartialUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_group_uuid = group_uuid;
    let p_body_patched_group_request = patched_group_request;

    let uri_str = format!(
        "{}/core/groups/{group_uuid}/",
        configuration.base_path,
        group_uuid = crate::apis::urlencode(p_path_group_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_patched_group_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::Group`",
                )))
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::Group`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CoreGroupsPartialUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Add user to group
pub async fn core_groups_remove_user_create(
    configuration: &configuration::Configuration,
    group_uuid: &str,
    user_account_request: models::UserAccountRequest,
) -> Result<(), Error<CoreGroupsRemoveUserCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_group_uuid = group_uuid;
    let p_body_user_account_request = user_account_request;

    let uri_str = format!(
        "{}/core/groups/{group_uuid}/remove_user/",
        configuration.base_path,
        group_uuid = crate::apis::urlencode(p_path_group_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_user_account_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<CoreGroupsRemoveUserCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Group Viewset
pub async fn core_groups_retrieve(
    configuration: &configuration::Configuration,
    group_uuid: &str,
    include_users: Option<bool>,
) -> Result<models::Group, Error<CoreGroupsRetrieveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_group_uuid = group_uuid;
    let p_query_include_users = include_users;

    let uri_str = format!(
        "{}/core/groups/{group_uuid}/",
        configuration.base_path,
        group_uuid = crate::apis::urlencode(p_path_group_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_include_users {
        req_builder = req_builder.query(&[("include_users", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::Group`",
                )))
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::Group`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CoreGroupsRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Group Viewset
pub async fn core_groups_update(
    configuration: &configuration::Configuration,
    group_uuid: &str,
    group_request: models::GroupRequest,
) -> Result<models::Group, Error<CoreGroupsUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_group_uuid = group_uuid;
    let p_body_group_request = group_request;

    let uri_str = format!(
        "{}/core/groups/{group_uuid}/",
        configuration.base_path,
        group_uuid = crate::apis::urlencode(p_path_group_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_group_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::Group`",
                )))
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::Group`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CoreGroupsUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get a list of all objects that use this object
pub async fn core_groups_used_by_list(
    configuration: &configuration::Configuration,
    group_uuid: &str,
) -> Result<Vec<models::UsedBy>, Error<CoreGroupsUsedByListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_group_uuid = group_uuid;

    let uri_str = format!(
        "{}/core/groups/{group_uuid}/used_by/",
        configuration.base_path,
        group_uuid = crate::apis::urlencode(p_path_group_uuid)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CoreGroupsUsedByListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Token Viewset
pub async fn core_tokens_create(
    configuration: &configuration::Configuration,
    token_request: models::TokenRequest,
) -> Result<models::Token, Error<CoreTokensCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_token_request = token_request;

    let uri_str = format!("{}/core/tokens/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_token_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::Token`",
                )))
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::Token`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CoreTokensCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Token Viewset
pub async fn core_tokens_destroy(
    configuration: &configuration::Configuration,
    identifier: &str,
) -> Result<(), Error<CoreTokensDestroyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_identifier = identifier;

    let uri_str = format!(
        "{}/core/tokens/{identifier}/",
        configuration.base_path,
        identifier = crate::apis::urlencode(p_path_identifier)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<CoreTokensDestroyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Token Viewset
pub async fn core_tokens_list(
    configuration: &configuration::Configuration,
    description: Option<&str>,
    expires: Option<String>,
    expiring: Option<bool>,
    identifier: Option<&str>,
    intent: Option<&str>,
    managed: Option<&str>,
    ordering: Option<&str>,
    page: Option<i32>,
    page_size: Option<i32>,
    search: Option<&str>,
    user__username: Option<&str>,
) -> Result<models::PaginatedTokenList, Error<CoreTokensListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_description = description;
    let p_query_expires = expires;
    let p_query_expiring = expiring;
    let p_query_identifier = identifier;
    let p_query_intent = intent;
    let p_query_managed = managed;
    let p_query_ordering = ordering;
    let p_query_page = page;
    let p_query_page_size = page_size;
    let p_query_search = search;
    let p_query_user__username = user__username;

    let uri_str = format!("{}/core/tokens/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_description {
        req_builder = req_builder.query(&[("description", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_expires {
        req_builder = req_builder.query(&[("expires", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_expiring {
        req_builder = req_builder.query(&[("expiring", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_identifier {
        req_builder = req_builder.query(&[("identifier", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_intent {
        req_builder = req_builder.query(&[("intent", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_managed {
        req_builder = req_builder.query(&[("managed", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ordering {
        req_builder = req_builder.query(&[("ordering", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page_size {
        req_builder = req_builder.query(&[("page_size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_search {
        req_builder = req_builder.query(&[("search", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_user__username {
        req_builder = req_builder.query(&[("user__username", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginatedTokenList`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginatedTokenList`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CoreTokensListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Token Viewset
pub async fn core_tokens_partial_update(
    configuration: &configuration::Configuration,
    identifier: &str,
    patched_token_request: Option<models::PatchedTokenRequest>,
) -> Result<models::Token, Error<CoreTokensPartialUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_identifier = identifier;
    let p_body_patched_token_request = patched_token_request;

    let uri_str = format!(
        "{}/core/tokens/{identifier}/",
        configuration.base_path,
        identifier = crate::apis::urlencode(p_path_identifier)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_patched_token_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::Token`",
                )))
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::Token`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CoreTokensPartialUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Token Viewset
pub async fn core_tokens_retrieve(
    configuration: &configuration::Configuration,
    identifier: &str,
) -> Result<models::Token, Error<CoreTokensRetrieveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_identifier = identifier;

    let uri_str = format!(
        "{}/core/tokens/{identifier}/",
        configuration.base_path,
        identifier = crate::apis::urlencode(p_path_identifier)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::Token`",
                )))
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::Token`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CoreTokensRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Set token key. Action is logged as event. `authentik_core.set_token_key` permission is required.
pub async fn core_tokens_set_key_create(
    configuration: &configuration::Configuration,
    identifier: &str,
    token_set_key_request: models::TokenSetKeyRequest,
) -> Result<(), Error<CoreTokensSetKeyCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_identifier = identifier;
    let p_body_token_set_key_request = token_set_key_request;

    let uri_str = format!(
        "{}/core/tokens/{identifier}/set_key/",
        configuration.base_path,
        identifier = crate::apis::urlencode(p_path_identifier)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_token_set_key_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<CoreTokensSetKeyCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Token Viewset
pub async fn core_tokens_update(
    configuration: &configuration::Configuration,
    identifier: &str,
    token_request: models::TokenRequest,
) -> Result<models::Token, Error<CoreTokensUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_identifier = identifier;
    let p_body_token_request = token_request;

    let uri_str = format!(
        "{}/core/tokens/{identifier}/",
        configuration.base_path,
        identifier = crate::apis::urlencode(p_path_identifier)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_token_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::Token`",
                )))
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::Token`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CoreTokensUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get a list of all objects that use this object
pub async fn core_tokens_used_by_list(
    configuration: &configuration::Configuration,
    identifier: &str,
) -> Result<Vec<models::UsedBy>, Error<CoreTokensUsedByListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_identifier = identifier;

    let uri_str = format!(
        "{}/core/tokens/{identifier}/used_by/",
        configuration.base_path,
        identifier = crate::apis::urlencode(p_path_identifier)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CoreTokensUsedByListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Return token key and log access
pub async fn core_tokens_view_key_retrieve(
    configuration: &configuration::Configuration,
    identifier: &str,
) -> Result<models::TokenView, Error<CoreTokensViewKeyRetrieveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_identifier = identifier;

    let uri_str = format!(
        "{}/core/tokens/{identifier}/view_key/",
        configuration.base_path,
        identifier = crate::apis::urlencode(p_path_identifier)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::TokenView`",
                )))
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::TokenView`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CoreTokensViewKeyRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Convert data into a blueprint, validate it and apply it
pub async fn core_transactional_applications_update(
    configuration: &configuration::Configuration,
    transaction_application_request: models::TransactionApplicationRequest,
) -> Result<models::TransactionApplicationResponse, Error<CoreTransactionalApplicationsUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_transaction_application_request = transaction_application_request;

    let uri_str = format!("{}/core/transactional/applications/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_transaction_application_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::TransactionApplicationResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::TransactionApplicationResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CoreTransactionalApplicationsUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// UserConsent Viewset
pub async fn core_user_consent_destroy(
    configuration: &configuration::Configuration,
    id: i32,
) -> Result<(), Error<CoreUserConsentDestroyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;

    let uri_str = format!("{}/core/user_consent/{id}/", configuration.base_path, id = p_path_id);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<CoreUserConsentDestroyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// UserConsent Viewset
pub async fn core_user_consent_list(
    configuration: &configuration::Configuration,
    application: Option<&str>,
    ordering: Option<&str>,
    page: Option<i32>,
    page_size: Option<i32>,
    search: Option<&str>,
    user: Option<i32>,
) -> Result<models::PaginatedUserConsentList, Error<CoreUserConsentListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_application = application;
    let p_query_ordering = ordering;
    let p_query_page = page;
    let p_query_page_size = page_size;
    let p_query_search = search;
    let p_query_user = user;

    let uri_str = format!("{}/core/user_consent/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_application {
        req_builder = req_builder.query(&[("application", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ordering {
        req_builder = req_builder.query(&[("ordering", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page_size {
        req_builder = req_builder.query(&[("page_size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_search {
        req_builder = req_builder.query(&[("search", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_user {
        req_builder = req_builder.query(&[("user", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginatedUserConsentList`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginatedUserConsentList`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CoreUserConsentListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// UserConsent Viewset
pub async fn core_user_consent_retrieve(
    configuration: &configuration::Configuration,
    id: i32,
) -> Result<models::UserConsent, Error<CoreUserConsentRetrieveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;

    let uri_str = format!("{}/core/user_consent/{id}/", configuration.base_path, id = p_path_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::UserConsent`",
                )))
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::UserConsent`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CoreUserConsentRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get a list of all objects that use this object
pub async fn core_user_consent_used_by_list(
    configuration: &configuration::Configuration,
    id: i32,
) -> Result<Vec<models::UsedBy>, Error<CoreUserConsentUsedByListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;

    let uri_str = format!(
        "{}/core/user_consent/{id}/used_by/",
        configuration.base_path,
        id = p_path_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CoreUserConsentUsedByListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// User Viewset
pub async fn core_users_create(
    configuration: &configuration::Configuration,
    user_request: models::UserRequest,
) -> Result<models::User, Error<CoreUsersCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_user_request = user_request;

    let uri_str = format!("{}/core/users/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_user_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::User`",
                )))
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::User`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CoreUsersCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// User Viewset
pub async fn core_users_destroy(
    configuration: &configuration::Configuration,
    id: i32,
) -> Result<(), Error<CoreUsersDestroyError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;

    let uri_str = format!("{}/core/users/{id}/", configuration.base_path, id = p_path_id);
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<CoreUsersDestroyError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Impersonate a user
pub async fn core_users_impersonate_create(
    configuration: &configuration::Configuration,
    id: i32,
    impersonation_request: models::ImpersonationRequest,
) -> Result<(), Error<CoreUsersImpersonateCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;
    let p_body_impersonation_request = impersonation_request;

    let uri_str = format!(
        "{}/core/users/{id}/impersonate/",
        configuration.base_path,
        id = p_path_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_impersonation_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<CoreUsersImpersonateCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// End Impersonation a user
pub async fn core_users_impersonate_end_retrieve(
    configuration: &configuration::Configuration,
) -> Result<(), Error<CoreUsersImpersonateEndRetrieveError>> {
    let uri_str = format!("{}/core/users/impersonate_end/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<CoreUsersImpersonateEndRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// User Viewset
pub async fn core_users_list(
    configuration: &configuration::Configuration,
    attributes: Option<&str>,
    email: Option<&str>,
    groups_by_name: Option<Vec<String>>,
    groups_by_pk: Option<Vec<uuid::Uuid>>,
    include_groups: Option<bool>,
    is_active: Option<bool>,
    is_superuser: Option<bool>,
    name: Option<&str>,
    ordering: Option<&str>,
    page: Option<i32>,
    page_size: Option<i32>,
    path: Option<&str>,
    path_startswith: Option<&str>,
    search: Option<&str>,
    r#type: Option<Vec<String>>,
    username: Option<&str>,
    uuid: Option<&str>,
) -> Result<models::PaginatedUserList, Error<CoreUsersListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_attributes = attributes;
    let p_query_email = email;
    let p_query_groups_by_name = groups_by_name;
    let p_query_groups_by_pk = groups_by_pk;
    let p_query_include_groups = include_groups;
    let p_query_is_active = is_active;
    let p_query_is_superuser = is_superuser;
    let p_query_name = name;
    let p_query_ordering = ordering;
    let p_query_page = page;
    let p_query_page_size = page_size;
    let p_query_path = path;
    let p_query_path_startswith = path_startswith;
    let p_query_search = search;
    let p_query_type = r#type;
    let p_query_username = username;
    let p_query_uuid = uuid;

    let uri_str = format!("{}/core/users/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_attributes {
        req_builder = req_builder.query(&[("attributes", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_email {
        req_builder = req_builder.query(&[("email", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_groups_by_name {
        req_builder = match "multi" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("groups_by_name".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "groups_by_name",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = p_query_groups_by_pk {
        req_builder = match "multi" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("groups_by_pk".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "groups_by_pk",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = p_query_include_groups {
        req_builder = req_builder.query(&[("include_groups", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_is_active {
        req_builder = req_builder.query(&[("is_active", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_is_superuser {
        req_builder = req_builder.query(&[("is_superuser", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_name {
        req_builder = req_builder.query(&[("name", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_ordering {
        req_builder = req_builder.query(&[("ordering", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_page_size {
        req_builder = req_builder.query(&[("page_size", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_path {
        req_builder = req_builder.query(&[("path", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_path_startswith {
        req_builder = req_builder.query(&[("path_startswith", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_search {
        req_builder = req_builder.query(&[("search", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_type {
        req_builder = match "multi" {
            "multi" => req_builder.query(
                &param_value
                    .into_iter()
                    .map(|p| ("type".to_owned(), p.to_string()))
                    .collect::<Vec<(std::string::String, std::string::String)>>(),
            ),
            _ => req_builder.query(&[(
                "type",
                &param_value
                    .into_iter()
                    .map(|p| p.to_string())
                    .collect::<Vec<String>>()
                    .join(",")
                    .to_string(),
            )]),
        };
    }
    if let Some(ref param_value) = p_query_username {
        req_builder = req_builder.query(&[("username", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_uuid {
        req_builder = req_builder.query(&[("uuid", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::PaginatedUserList`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::PaginatedUserList`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CoreUsersListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get information about current user
pub async fn core_users_me_retrieve(
    configuration: &configuration::Configuration,
) -> Result<models::SessionUser, Error<CoreUsersMeRetrieveError>> {
    let uri_str = format!("{}/core/users/me/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::SessionUser`",
                )))
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::SessionUser`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CoreUsersMeRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// User metrics per 1h
pub async fn core_users_metrics_retrieve(
    configuration: &configuration::Configuration,
    id: i32,
) -> Result<models::UserMetrics, Error<CoreUsersMetricsRetrieveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;

    let uri_str = format!("{}/core/users/{id}/metrics/", configuration.base_path, id = p_path_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::UserMetrics`",
                )))
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::UserMetrics`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CoreUsersMetricsRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// User Viewset
pub async fn core_users_partial_update(
    configuration: &configuration::Configuration,
    id: i32,
    patched_user_request: Option<models::PatchedUserRequest>,
) -> Result<models::User, Error<CoreUsersPartialUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;
    let p_body_patched_user_request = patched_user_request;

    let uri_str = format!("{}/core/users/{id}/", configuration.base_path, id = p_path_id);
    let mut req_builder = configuration.client.request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_patched_user_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::User`",
                )))
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::User`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CoreUsersPartialUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get all user paths
pub async fn core_users_paths_retrieve(
    configuration: &configuration::Configuration,
    search: Option<&str>,
) -> Result<models::UserPath, Error<CoreUsersPathsRetrieveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_search = search;

    let uri_str = format!("{}/core/users/paths/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_search {
        req_builder = req_builder.query(&[("search", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::UserPath`",
                )))
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::UserPath`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CoreUsersPathsRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Create a temporary link that a user can use to recover their accounts
pub async fn core_users_recovery_create(
    configuration: &configuration::Configuration,
    id: i32,
) -> Result<models::Link, Error<CoreUsersRecoveryCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;

    let uri_str = format!("{}/core/users/{id}/recovery/", configuration.base_path, id = p_path_id);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::Link`",
                )))
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::Link`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CoreUsersRecoveryCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Create a temporary link that a user can use to recover their accounts
pub async fn core_users_recovery_email_create(
    configuration: &configuration::Configuration,
    email_stage: &str,
    id: i32,
) -> Result<(), Error<CoreUsersRecoveryEmailCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_email_stage = email_stage;
    let p_path_id = id;

    let uri_str = format!(
        "{}/core/users/{id}/recovery_email/",
        configuration.base_path,
        id = p_path_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    req_builder = req_builder.query(&[("email_stage", &p_query_email_stage.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<CoreUsersRecoveryEmailCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// User Viewset
pub async fn core_users_retrieve(
    configuration: &configuration::Configuration,
    id: i32,
) -> Result<models::User, Error<CoreUsersRetrieveError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;

    let uri_str = format!("{}/core/users/{id}/", configuration.base_path, id = p_path_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::User`",
                )))
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::User`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CoreUsersRetrieveError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Create a new user account that is marked as a service account
pub async fn core_users_service_account_create(
    configuration: &configuration::Configuration,
    user_service_account_request: models::UserServiceAccountRequest,
) -> Result<models::UserServiceAccountResponse, Error<CoreUsersServiceAccountCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_user_service_account_request = user_service_account_request;

    let uri_str = format!("{}/core/users/service_account/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_user_service_account_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::UserServiceAccountResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::UserServiceAccountResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CoreUsersServiceAccountCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Set password for user
pub async fn core_users_set_password_create(
    configuration: &configuration::Configuration,
    id: i32,
    user_password_set_request: models::UserPasswordSetRequest,
) -> Result<(), Error<CoreUsersSetPasswordCreateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;
    let p_body_user_password_set_request = user_password_set_request;

    let uri_str = format!(
        "{}/core/users/{id}/set_password/",
        configuration.base_path,
        id = p_path_id
    );
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_user_password_set_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<CoreUsersSetPasswordCreateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// User Viewset
pub async fn core_users_update(
    configuration: &configuration::Configuration,
    id: i32,
    user_request: models::UserRequest,
) -> Result<models::User, Error<CoreUsersUpdateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;
    let p_body_user_request = user_request;

    let uri_str = format!("{}/core/users/{id}/", configuration.base_path, id = p_path_id);
    let mut req_builder = configuration.client.request(reqwest::Method::PUT, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_user_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => {
                return Err(Error::from(serde_json::Error::custom(
                    "Received `text/plain` content type response that cannot be converted to `models::User`",
                )))
            }
            ContentType::Unsupported(unknown_type) => {
                return Err(Error::from(serde_json::Error::custom(format!(
                    "Received `{unknown_type}` content type response that cannot be converted to `models::User`"
                ))))
            }
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CoreUsersUpdateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// Get a list of all objects that use this object
pub async fn core_users_used_by_list(
    configuration: &configuration::Configuration,
    id: i32,
) -> Result<Vec<models::UsedBy>, Error<CoreUsersUsedByListError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_id = id;

    let uri_str = format!("{}/core/users/{id}/used_by/", configuration.base_path, id = p_path_id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::UsedBy&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CoreUsersUsedByListError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
